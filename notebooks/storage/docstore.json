{"docstore/metadata": {"1955f812-c049-4b9a-a5e2-a3ff2b394541": {"doc_hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7"}, "34489436-cae2-4523-9287-3364957dd669": {"doc_hash": "95aa76feaad30fd5eb9dc01c3e1b0097fd7413f61ef10d51d592d99c2845d45a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "73bd3a44-5f9c-4ada-90d0-6a232bf6b973": {"doc_hash": "6c273ca987e839d0c00f8a814e2f8d84b9f4f4bf24dc928304cb3a7a677ce79c", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "925ab3a0-1a19-4dce-8c8f-5843901ff1bc": {"doc_hash": "6f525e7c97854b1bda0bb3b972b7db95ef6c4cf11fa2f261042e380a9598e20a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "0f18dbdf-03f7-4afd-8b5a-b883eee4490e": {"doc_hash": "88cd138c8f29544e9b86b0a6ea21a06b566b9c1d2d638f54cb9cce3d105deddb", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e5f3c955-d456-4449-8a6f-a82304e9acd5": {"doc_hash": "69a1bd1e2f9673f6bb0262a067e54e971afed2b0d9f319878dfa248d01485979", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "a23085ae-b0a8-44d0-8af9-0454c89cc701": {"doc_hash": "43a8bc9c45007eca644d5c927b77d248cd82fef8e7fffa2d569f834cde11ed43", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c549c20d-91eb-4b4e-a135-3c2ab732ac8f": {"doc_hash": "6ded0dc598d840dccf4ecc2d7dd2e275f4700c9d68857a3bd8cadfcc3c2734a0", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "34417008-d287-4ec6-8824-9c4a9933dadb": {"doc_hash": "f74fbb5d7c377f7e5c1a882944590d8af496f508e888bfe00fdc52c4f80f9e39", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "41fbfc9f-e337-43b9-b0a7-37bb0df3e3a5": {"doc_hash": "ce816c41c4ed5f6a93e7bd6fd5df48d34552d1b2e114b9bd0a946aaf78975b20", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "3d640b84-a669-4a62-87c0-7b9bffae4355": {"doc_hash": "59eb18f438944c75f32df3493f5060cc9055b5647c02bb43fdcd8d296565fb63", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "0011a0e6-717f-46ae-ac2c-969b0bbacc17": {"doc_hash": "2600f91ce6583365342e9bb898b9d8704262618c9fb36543c51053d0594d042f", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "547a846e-32a9-49f1-b232-d23b43ec936d": {"doc_hash": "427208e003f93c35e11ae9a319f194c17df567fe801dc1f06681412bdf435e2e", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ff0550ba-a042-4733-a9bc-58c67f3ee653": {"doc_hash": "c8f1753224fee049b6ad43171f88f25312e4f9eef6b274724e9bf86409a4861a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "7208c8a8-83ca-44e0-a1fa-e344602ee6ad": {"doc_hash": "6da23f79f8afe683021c58f381efab171425ce0599b97b4f54677d82b924a5a3", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "a204aba6-d397-475b-bcb9-cb577a450202": {"doc_hash": "9d905112c13248618e9cc0ac40820fa5274643994b2be1f572b1d2a3ff0c3b88", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "b3843e16-8251-4032-b8c1-0ed0f9209e73": {"doc_hash": "990dd372bfe89385399339a700f187771309fa0d468e5d7e1f7a6d1a31e13fd3", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "86ff8e56-9330-43f8-8440-f649b9cd0bdb": {"doc_hash": "e3d754548d11ba4d62eb2c6d3ab8b191269addceb3bec814b62ba22fdda00a5d", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "bf070696-46bc-4850-af0b-206ec2fcc097": {"doc_hash": "5eb639bde7e697645524d070cd65a17ea474d1c8954aa308e8f7cef7773daae6", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "34031934-93cc-4830-b3e3-ab9c1aec029c": {"doc_hash": "d10908b695714522af7988a39533aa3d24710e15bef6c14d2258526c17844aff", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "cf1825e8-4831-47fc-9ca6-c9dfb2b81855": {"doc_hash": "cf565da9d54ea723267dd277218b4e6efdb9b764a5ee4b2db7c1d809d0e1ffb6", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "d6943e2a-102e-4f56-848a-1c3b2ff88f9a": {"doc_hash": "f1b76203c0db3a883930bda9a8f9e1bc61d1507af96a95019e933bd084cddf87", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "33447fc7-8cb5-4459-aa82-11f6680ea241": {"doc_hash": "9e4757247c1f0e4c1f873d2a34a024c2c3eddb0ba0e14cda2267b925533a1803", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "88885557-bd8c-403d-984c-cf5894235e12": {"doc_hash": "cec1999fb8943a61e46f88e7c06bf14b1346899647356bccf56c8c09e26878c6", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "0edf1415-de36-4270-9cef-7ec443a8c197": {"doc_hash": "2ec8ace2708eed0d39941003381a30cb294430cc455a6dd4d33fc5e7d6f762aa", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "a9a3b6b9-ac9b-47b4-bb63-8933783ea95d": {"doc_hash": "5d09e004fdbdc32fad036a0a35eb7b5b46d7bbc4b0f18a76d1ec4b85e85c3e6d", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "4908e5d1-f2e8-4fdc-8a2d-729037dec439": {"doc_hash": "c46b596c39af548d5d96f8809c994b3c217bf54455ec98be2d3745be8fa4d35a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "cbcfe87f-7a52-4219-b9c2-30df358238a4": {"doc_hash": "e96ff047d9cca71427410fdccd5670fcbe199c79d6477fe6a2bf1a6975847775", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "52938472-3f0e-46be-b9b9-9aff5e70391d": {"doc_hash": "3c2af3767a52ef43dc0875c147fe5670bf50a23e9263dc09977b88ad73d259f9", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ccfc7cac-7479-4e04-97c5-a17ffd3610bf": {"doc_hash": "84f99f06102e9c59004f501faf8fcbddbd6c61a9129acdee67e3d688daaf8c04", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e476761c-7a95-4b3b-b61c-fa2eab14e5af": {"doc_hash": "eb8cdb4b03d74b8cdcc93ff070dc480865c3a8defcec1c0c1e943089caae2a8d", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "d19c585e-1e41-4651-9d48-40e3972eb08a": {"doc_hash": "d3f260cbc291a7f27407f04521097a3305f1f2e27536b883f0be74102e628eb2", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "3c8fc582-44e8-4266-bf4e-2074786d0c60": {"doc_hash": "f0c51f7baa95649e90a35a537bd5d9c23519c2321109ca2f66b0d1c4cc941b18", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "2f530467-8fbb-4808-83ec-099ae4805751": {"doc_hash": "d8fcea89241d1f63d96a615d30d05f3d995e1f628c9b80ab8bfdb117f08f8464", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "8693e9b3-d9f2-4952-8a90-8891b0455b31": {"doc_hash": "c8a1c51f221605fb0090d71ef7f1d5928a68e5ffd24541563c863141c4de692a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "9189b8e0-7f66-479a-afec-6b653f695be5": {"doc_hash": "1df9c891655090d3eb53842c0d2b86f4740ad8812ca971a30ccdb290cbe08b66", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ac8cafeb-3622-4928-991d-bd5ce6a15521": {"doc_hash": "58b4ff857d33f9f69e700cd1b48163a8a94c1ca20ffb09f80704d8a803d6c9e8", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "70c3a405-717b-499e-b5b3-2abb9dd4b19c": {"doc_hash": "a6f1cbeb6510228525a828ecbcec094ffca5c6b1d2fb7d02c53dba6b6420cb25", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c0efc1cf-f839-45d2-99a2-f73458812cef": {"doc_hash": "281db622bdac95d4b72f6890f3f242c91fb5ff0ceeb6b45e820a5dbbeb165582", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "118c9f4c-ed95-423c-ab24-c12cc0664fa8": {"doc_hash": "543fd1b18e182702461154a1a97d599cb32d3f0bcb3134c1eb29d1b53515d168", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c6fdb29b-089e-4e68-a1fe-29bd215b9666": {"doc_hash": "5bc7cc29ae3194e7bbd2b7bd7c6389d0779864ccf0fd20a62d6f31e58a56043d", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ac439d6a-4376-4bba-83b3-786ab995cdfb": {"doc_hash": "dea3cf2ba0301c447a6566bb06860192c1a921d034f9a71812db31f409fc81e4", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "d7c0aece-b729-4a43-901e-4c64c0876c83": {"doc_hash": "671d15d9a2451c3ec9f2f203c9da738e11799576e4dc66774556ad353f8f81c0", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "7346b2bf-b20f-4a61-87b0-14401e8fed02": {"doc_hash": "0def772d659ddb7a83f814be9c1dab090beaa37c0134d9b3587f1e4e6a142d27", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "a2807378-86ca-4366-984c-deeb7f761b80": {"doc_hash": "f7f6446bfab3bea7f82c40b8185d4def35494648ed7820452c95a92420dfa602", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "55bddff7-0185-4eec-843f-2b7b85d8a430": {"doc_hash": "e79b9a47d932a4b7ae357d9dc41977f84dae1339b7ff8d1344fa7c612968f56f", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "32d2c2b1-cca3-4db5-8526-9a479f487626": {"doc_hash": "64a7fe2053935f4bd55fe95d92cc11732eea6b4931148c8f37c3d888e66ecd5f", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "1c41f3b6-c094-4aea-8875-79e68c9311c2": {"doc_hash": "c263a4378f2a65c6fd470315126486ca39f935d59f46ef36f971476a45a13e28", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "4f76dce8-3ccc-4bb1-add1-175abf8d9995": {"doc_hash": "adf17850d07c2539d1636749c476a4cf58ac17c4d051fa37cc375cbc754e0ff6", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "25d66321-35b9-4363-be72-76e33629616a": {"doc_hash": "7f0eaf0bb9ee21e73a307108ff16f82fe5182b63eeb404b8e76dc48e18f4cb2b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e6928295-da83-4da1-95a5-2be6f0d6718b": {"doc_hash": "1feec2598a33960ee4df64dd0a855bcd2c90fb9e4a09c7ec8dd5c737df7d0bb0", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "2f5b5056-6011-4570-bd8f-163a18bd4b46": {"doc_hash": "5f42f52805e66392d9d4d6f6de98eb6ec2222727b8c15051a6639969e8862b47", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "88548a1f-7190-4cf4-bf1d-835c87aa68ac": {"doc_hash": "3e9916711b7bf3e409e8a3ee28f91130ff04f1ab35452c2668896036f46ec548", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "81d1a5b1-88ac-4c37-a933-c2971cb47c7b": {"doc_hash": "6796af5feaca33fd43fda41488b4420dbc2f5e3f355ec9ae15e1f4412d82c24a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "53a6498f-cbe1-40e5-8cb0-195758c1d8d5": {"doc_hash": "092dc1e3129d4b8a830610a3d26897deb56f210067fe30a547b798c6dd69f82b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "03766a7a-c507-4508-8bce-1a378a8e8272": {"doc_hash": "dba99632583edc80ab0c830e94de9ab6c46ab4cbaf51eed752dffc05eb832135", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "7b97b026-d0b9-4ab7-be8f-0326743db861": {"doc_hash": "12063448bfc1243d484551c6f262f641ef679d787ef210c6e9013a3e42529f95", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "76229b56-26d6-410d-81e1-abdd9cb2a72b": {"doc_hash": "6e19f8dc23a99907089cd4d222c53208407bd4c90b4e10c33bd3661838291366", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "7bdf8503-85ae-4272-a72e-3ee2562fc3a0": {"doc_hash": "12c96ad2f9bc98755d6e6c9ab8381e9913086b841513b8becbbe13f531033daf", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "54ecedd6-5cd5-4e61-b6b3-f01069a7927a": {"doc_hash": "72493f70809ec8e89efd917233b82c48b98de82a64d06f57a09af8b57ea88e46", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ed2dd69e-328d-4c19-953d-f3d9cc7a3895": {"doc_hash": "649778fa97b5796673835a3e628a1f5e34b2e2451c93b06b08037557431e0b84", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c21972ca-1389-4f54-be2a-b2c8854b1e56": {"doc_hash": "217ae0cac9917bf4737fd6b69ea9226d86cc180c1993aa93941caf9e223fd349", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "21b2ae83-3834-4907-afb4-0986b06ee2e9": {"doc_hash": "499cebe936efd6cbf323aabea0788d39e65e11d24cfa77673908aef31fbe6a2e", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e217dbf9-60c7-412a-a252-ea141a98edad": {"doc_hash": "043fd615c4d02b35d7ab546dfd0d3d5aaf7c7f832b0e708b891009cdc92522fe", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "076c1e04-b35c-4a6e-902b-680056f01004": {"doc_hash": "514273cd3a15c1d7bbddf33814b2cc9f6a8d5dd930b70e780f1b2b0b46807db5", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e14964cb-028f-4385-8537-37b90a5f3080": {"doc_hash": "f1fd255e80a444c8a87bee3a92b6a79e2310b58b4de4cc5a8d7fa3cd6f34d4b5", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "de0df7ac-b806-4fdb-964b-1b6fbcff1ae7": {"doc_hash": "0663878e38b833bf02c1ae69fad21f6764cf7215c563d9f9ef81823562d40711", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "6904bdec-6926-4c17-b0d9-4b23688e9672": {"doc_hash": "e423b7acb5b925ac5601bf5fc9626132e2ad56deac66f383808af5dcabec9416", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "4121a336-0668-4093-b5db-67770641776f": {"doc_hash": "a4f775e8fa71ba1fcfc94ee28313f932adb9e6f566829d931e438f145fbfb651", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "10df4883-3f01-4dc7-855f-c21452e6f3fe": {"doc_hash": "628a93f0fea69f6d16c85462ad0bb526c37f02ee0b00f93dfc642e4815ed96a8", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "5b497545-33fc-4541-9428-67df266167b4": {"doc_hash": "0979838f2e423a61a1b53f526433ef1e344149d87d62501d35d5ec6508b8f54b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ba2aeae3-a9a8-4603-9e73-b96220b79327": {"doc_hash": "7f8e8c56e30524b92a1e0a87fff13d9d96fab7bbd1dad0b4def151f780969719", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "0086a0b8-7a23-4d3c-9805-738e51efb9ed": {"doc_hash": "f82a458f905de3e6270548a792cbfde58f0722ce3e625e1e1f1eb9b643e83044", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "8bbbf261-9544-439f-a918-4ec17020447c": {"doc_hash": "c964cc9221a1926af9ca91f52033b3aa92b3e2a323592ea5d27b231030d866ea", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "2d057317-de9e-4c7a-b3f3-b6ed462c1149": {"doc_hash": "592fcf0c84bc01801690d2d003f5496d0188c04c60b0ba5306096684b28c539e", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "2ab1c494-338f-4cf5-aad1-5f9253332cdb": {"doc_hash": "4a6502fc8ae7c9cbc74fd2d364cec715ddbdf74dc56519f4f0092d3decec060b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "f92d2480-e358-4a68-a3cf-5d16bbdaa9e3": {"doc_hash": "24d5d88c58c2b88a52f29257db9904bdb8a060f4572a4553a753c5e607293068", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "f586e01e-8c96-4521-bd66-ab7d03a7f88a": {"doc_hash": "fb8b453e10206de5046cebc0d48f15e686f0791793c2155488210c626e0ade0b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c444de1f-f91d-4553-9f5e-8d36c83f4cad": {"doc_hash": "33aabe74cede4a39ff056d77f51ad2ed40b6f45fe82855d514eab84465f282bb", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e6391154-f38e-41b3-bcf3-54e2ef40c2d8": {"doc_hash": "e974c40662e926a6ae6c3f6d2d8cffcae0ed20f419628fafde9ab081ac35589f", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "a44724e1-44dd-4dc4-9a07-f500a1ae805b": {"doc_hash": "b7cbc6ef0a35c882760d94ac5c6e6e59e8f3c86befff511265009cb5bf56260b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "d3a0c950-8cb5-4290-937a-66495246d14f": {"doc_hash": "134d6b4d039044d1b6fc6136bde81216d504234b386a18c28a22f3c08f00845e", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "df8777e6-9a03-45b4-9e9a-940f6ae289f5": {"doc_hash": "367c593275cf28082941f422e2c9accc34e59f4e41f71700931205f9579b5bd3", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "6705304c-622e-4201-9e8c-4cdf5a33b542": {"doc_hash": "56a1669dc8195344ba7aeaa2637e7dc2ce921f8f84c0258d54b365601f694820", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "f2f6e694-2f58-4dcc-950a-e4a1ca0dc6e0": {"doc_hash": "bedf5e80199f7dcb443ff4a740e287f0bf4fd623d24e0345212b139ec39f5055", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "950be4a2-a43d-4b84-a984-430d561cf74a": {"doc_hash": "4ebcddea08280fa81af737be09fc314f13f679fed425030bb6bcae200c1332ba", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ac151282-3067-4f6d-9c24-3dfbbad239bd": {"doc_hash": "1bfc54472552a6c7d2a536cb385e0d8311c564780aaaa859a33c28c51cf6e5d0", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "afcc9754-0f7d-445b-8adc-46f40fbc30c7": {"doc_hash": "749d97b8d30e4ef8dd42e9d035277da345020fcb09565b84904c91387a8b03c7", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "bbb5f82b-4ebf-48de-9b0d-1b49aefe13b8": {"doc_hash": "31ebafa88d829647910f718a5bffb10f48dcecffd4e37d5f985126205e68e590", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "80ac7d83-369c-480c-a643-7ca6f1a37acc": {"doc_hash": "1563c9f31c5873b5e3ba580a9fe73367c4a9e0a7024d3ba1a69c0cb7823bee5b", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "314a4b5a-5952-4da1-9218-17074321c302": {"doc_hash": "e5f3106ef891db60251d3f2c02793c876d547129c3e2ec5fc21360e47db7566d", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "50ba301a-e6df-4641-b025-c565c6088b16": {"doc_hash": "c058610557d50ba19bc82bd92b10042cc0f50ee682112ac0337a593e877453ae", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "6aa18799-fa30-41d3-bd1f-440824be6e22": {"doc_hash": "d0e670b7c52056f0e3eafeaebde573528d9fd470a9ffab113761a21ca4d64ce7", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "baaa615a-af4a-45ba-bbf1-cfa67a4da6df": {"doc_hash": "26242a15125e422b3f055f9e642a9b4ab01c9f8cb1077162cdd1f50ebebfbf15", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e907cdcf-5dcb-4b4f-94fd-3c5842eaf70a": {"doc_hash": "162daf551e6074c2d047a371e00630f08e7a7e62833b19f264bef49ba967cf81", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "d71e50de-da67-41dd-8340-d754324987c8": {"doc_hash": "2b8727e63e03da32c63ba63d80dc1e3ef68e631421c2a85e4d979a584f02ed5a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "bbe816f8-8a7f-4e26-bf41-dd1102129f7f": {"doc_hash": "cc02c642d59c1fa13eebebfa724ac5d3c016785326a37a5ef94f02cf5900cacf", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c2c634d1-50f4-4a42-9e5f-600ecd38ec0d": {"doc_hash": "281f7cbc2c6383190408018df6873245d117ac14ca6d8b4fd0f5c6c06b42d923", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "9fea6d73-ba39-4916-8889-e3e6d0ca947a": {"doc_hash": "4c9bc9caf150e03fb129504b0167a944e213e47d7e57c8dc85927d96833aaaa4", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "750889aa-8c7f-4f64-a702-59b5978021a5": {"doc_hash": "ae152a98ecca3f23b3c6437bb616d150740cb3874f81553a1b99b043e4bb17a8", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "4d26a338-2094-415b-b90a-e4d55fb27348": {"doc_hash": "6eae498f4008a8f0e7fb5d060ab631a826206e9affbda37e9c31a93a3fda1415", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "aef1a3a4-c638-477e-b9b3-64d2e035ce76": {"doc_hash": "0ffffbbca5a8bfd4f0b3b0a830961b5cbaddd36e7ac62a8a31df4e0306ea8de7", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "b68aa1f7-767a-4429-8f99-7f64db0c7186": {"doc_hash": "76aacf4c9ac74307d6bac21d73f84c58859c5a0fd35857221b938a8fb7d4b3b8", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "46e73ea5-a864-4ee0-95b1-f43a302154a5": {"doc_hash": "6fc45ce40648b1716bac55536c308434e54d79af8801eb57d4985d9d73b3c058", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "8febec41-e86f-44d8-8ab6-7e53506d7de3": {"doc_hash": "cde665b54bf466ad94d5797bddc43439f0f42b5f338864ffd792b94230551482", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "36eeb847-6299-4dda-a0d4-073813419d88": {"doc_hash": "628e28f4026f2d849047f8c774e73b0321c9c17e04bb4774a22cb0a3d6f0b866", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c8fea01d-a524-4b90-8512-a76e2be893ee": {"doc_hash": "6a77dd888de86e98c7deda609213fab3dcb70391b99915f11ca485ed7c159a88", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "89ca04f0-cb42-49a9-a293-245323c797de": {"doc_hash": "2a85477c24f14255e53d03c1a4054a8005d6e7077df326eaac4008e6cca9d7e1", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "b361279c-08c2-4c70-b3d4-8eab9098f2e2": {"doc_hash": "647534d0984fa0f2dc96eb532ac0625576a5c20f5ad6e85ebcfc3dd30725e356", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "15349f6a-4972-4fa3-9149-6337e2c01b66": {"doc_hash": "4c7a29bd0813e23a253b5e0c7e5fead1bb38f68816fffd95909fd7eabc6455ee", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "48c4dd2e-b382-4689-94cc-181761e99161": {"doc_hash": "c70652d9f75ba3cf024d604f933df87699db6f26a4b50ca53505f3779dca8768", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "ae298954-0179-4ebb-a91b-3c238cb39670": {"doc_hash": "09b3550bfb1219bb8eedfbc93945131dc2c91f52705a2d193a80b6a3a9201f55", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e3a05eee-3e81-4991-87e8-27734709aa34": {"doc_hash": "7ec8044c26db560e91679ce96d7f5a85add6023c6a8a00b6fb483eb2a8645de4", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "c3732f34-173e-45d7-ba3d-f77a9c0d119a": {"doc_hash": "b5a080bbb4e32d98867df0bf4e266b8259287a88963252b737e206455278d8ab", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "95d6cb79-940f-47d8-ad80-f146833b0f62": {"doc_hash": "5e640a37ac66e57e87af5a1ceab4e22408ce15e19410260132ca7312b7a0ec0a", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "e863e6f1-8053-4d97-b2ef-08b8530f9c70": {"doc_hash": "453fe9ab1fd1800e52d14403cfd47848d61aa04a9d7218e028af3795d5c97064", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "0bdff3d5-ae33-4b87-970c-d8f38deb019d": {"doc_hash": "6256a2cd2c0b1fb501f4b1d8069d9f2d3d8847510d123da384dcee6e18371b21", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "524beb77-363e-48b0-8082-e82ebc147650": {"doc_hash": "35f674e19835636d9c66ee4e2535d03f2860b8d9732f53d2503c64f13100cceb", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "6291a13f-0cec-44d4-b2f0-6f06bf996e79": {"doc_hash": "3bdc192a3374810a8361c48988146ca67afe9059b3d3e78d697998ce9756efb1", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "d8055aea-7f54-4708-b218-b8e23a78c4c6": {"doc_hash": "9bb87e7b3a58c39e4b18284edbca7c890311eff2bcef7ffbf60afc0225b76b33", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "b18a7acd-ee88-4480-b9f1-4d446213ac6f": {"doc_hash": "bd91ca4b11c891cea71aea1811127df2bc88bea4a5e076931bfd81501d3ded05", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "66a3def4-f002-4286-91d6-dffc853ff270": {"doc_hash": "dd0d9daa41046d746215bcef2266a1fd850e627decb54b5eebc5960fdb06d7bf", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "0561237a-aa07-4c97-9d98-c8ba80791ef3": {"doc_hash": "e3fb93d3b0a3ce0b1884082eb3aba846a7375102a48c45def5ef7b459dc9ddb7", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "cf2a6039-d9a3-4d8c-809b-cbb70b975561": {"doc_hash": "4fccc8ca1ad6f5ced40a2c31689cd59f6b42a85d53190635d42440416a5139f5", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "65b79e60-42cc-44d8-9df3-ee7f1b87163c": {"doc_hash": "d108e0e23ee4b069347a7059bd45c49fa59e768c808d1ccdf84f7ed97ae5107f", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}, "52b82c3c-46ad-4066-bab2-ca59a9718da0": {"doc_hash": "b559b2b5c8cb3b10ac31a4f3195e27de6e4de987fdaf24779c2a1fa74011a33c", "ref_doc_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541"}}, "docstore/data": {"34489436-cae2-4523-9287-3364957dd669": {"__data__": {"id_": "34489436-cae2-4523-9287-3364957dd669", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73bd3a44-5f9c-4ada-90d0-6a232bf6b973", "node_type": "1", "metadata": {}, "hash": "6c273ca987e839d0c00f8a814e2f8d84b9f4f4bf24dc928304cb3a7a677ce79c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "P a g e  1 | 16 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview Preparation) \n \n# Day28P a g e  2 | 16 \n \nQ1. Explain StructEdit(Learning Structural Shape Variations). \nAnswer: \nThe shapes of the 3D objects exhibit remarkable diversity, both in their compositional structure in terms \nof parts, as well as in geometry of the elements themselves. Yet human  are remarkably skilled at \nimagining meaningful shape variation even from the isolated object instances. For example, having seen \na new chair, we can easily imagine its natural changes with the different height back, a wider seat, with \nor without armrests, or wit h a di verse base. In this article, we investigate how to learn such shape \nvariations directly from the 3D data. Specifically, given the  shape collection, we are interested in two \nsub-problems: first, for any given shape, we want to discover main modes of edits, which can be inferred \ndirectly from shape collection; and second, given an example edit on one shape, we want to transfer edit \nto another shape in the group, as a form of analogy -based edit transfer. This ability is useful in several \nsettings, including the design of individual 3D models, the consistent modification of the 3D model \nfamilies, and the fitting of CAD models to noisy and incomplete 3D scans.  \n \nAbove Fig: Edit generation and transfer with StructEdit.   \nWe present the StructEdit, a method that learns the distribution of shape differences between structured \nobjects that can be used to generate an ample variety of edits (in a first row); and accurately transfer edits \nbetween different purposes and across different modalities ( on the second row). Edits can b e both \ngeometric and topological.P a g e  3 | 16 \n \nThere are many challenges in capturing  space of shape vari ations. First, individual shape  can have \ndifferent representations as image, surface meshes, or point clouds; second, one needs the unified setting \nfor representing both continuous deformations as well as structural changes ; third, shape edits are not \ndirectly expressed but are only implicitly contained in shape colle ctions; and finally, learning the space \nof structural v ariations that is applicable to more than t he single shape amounts to learning mappings \nbetween different shape edit distributions, since different shapes have various types and numbers of parts \n(like tables with or without leg bars). \nIn much of the ex isting literature on 3D machine learning (ML), 3D shapes are mapped to poin ts in the \nrepresentation space whose coordinates encode latent f eatures of each shape. In such  representation, \nshape edits are encoded as vectors in that same space \u2013 in other words , as differenc es between points \nrepresenting shapes. Equivalently, we can think of forms as \u201canchored\u201d vectors rooted at  origin, while \nshape differences are \u201cfloating\u201d vectors that can be transported around in shape space. This type of vector \nspace arithmetic i s commonly \nused [wu2016learning, achlioptas2017learning, wang2018global, gao2018automatic, xia2015realtime, \nVillegas_2018_CVPR], for example, in performing analogies, where the vector that is the difference of \npossible point A from point B is added to point  C to produce an analogous point D. The challenge with \nthis view in our setting is that while Euclidean spaces are perfectly homogeneous and vectors can be \ncomfortably transported and added to points anywhere, shape spaces are far or less so. While for \ncontinuous variations, a vector space model has some plausibility, this is not so for structural variations: \nthe \u201cadd arms\u201d vector does not make sense for the point representing a chair that already has arms.  We \ntake the different approach. We consider embedding  shapes differences or deltas  directly in their own \nlatent space , separate from  general shape embedding space. Encoding and decoding such shape \ndifferences is always done through a VAE( variational autoencoder), in the context of the given source \nshape, i tself encoded through the  part hierarchy. This has the number of key advantages: (i)  allows \ncompact encodings of shape deltas, since in general , we aim to describe local variation ; (ii) encourages  \nnetwork to abstract commonalities in shape variations acros s shape space; and (iii) adapts the edit to the \nprovided source shape, suppressing the mode that are semantically implausible. \nWe have extensively evaluated  the StructEdit on publicly available  shape data sets.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4504, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73bd3a44-5f9c-4ada-90d0-6a232bf6b973": {"__data__": {"id_": "73bd3a44-5f9c-4ada-90d0-6a232bf6b973", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34489436-cae2-4523-9287-3364957dd669", "node_type": "1", "metadata": {}, "hash": "95aa76feaad30fd5eb9dc01c3e1b0097fd7413f61ef10d51d592d99c2845d45a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "925ab3a0-1a19-4dce-8c8f-5843901ff1bc", "node_type": "1", "metadata": {}, "hash": "6f525e7c97854b1bda0bb3b972b7db95ef6c4cf11fa2f261042e380a9598e20a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We have extensively evaluated  the StructEdit on publicly available  shape data sets. We introduce the  \nnew synthetic dataset with g round truth shape edits to quantitatively evaluate our method and compa re \nit against baseline alternative . We then p rovide evaluation results on  PartNet \ndataset [mo2019partnet] and provide ablation studies. Finally, we demonstrate s that extension  of our \nmethod allows the handling of both images and point cloud  as shape sources, can predict plausible edit \nmodes from single shape examples, and can also transfer example shape edit on one shape to other shapes \nin the collection.P a g e  4 | 16 \n \n \nQ2. EmpGAN: Multi -resolution Interactive Empathetic Dialogue \nGeneration \nAnswer: \nAs a vital part of human intelligence, emot ional perceptivity is playing  elemental role in various social \ncommunication scenarios, such as., education and healthcare systems . Recently, sensitive conversation \ngeneration has received an increasing amount of attention to address emotion factors in an end -to-end \nframework. However, as li2018syntactically  revealed, that conventional emotional conversation system \naims to produce more emoti on-rich responses according to the specific user -input emot ion, which \ninevitably leads to the psychological inconsistency problem. \nStudies on social psychology suggest that empathy is the crucial step towards a more humanized human-\nmachine conversation, which improves emotional perceptivity in em otion-bonding social activities. To \ndesign th e intelligent automatic dialogue system, it is essential to make a chatbot empathetic within \ndialogues. Therefore , in this paper, we focus on  a task of  empathetic dialogue generation , which  \nautomatically tracks and understands the user\u2019s emotion at each turn in multi -turn dialogue scenarios. \nDespite the achieved successes , obstacles to es tablishing the empathetic conversational system are still \nfar beyond current signs of progress: \n\uf0b7 Merely conside ring the sentence -level emotion  while neglect ing more precise token -level \nfeelings may lead  to insufficient emotion perceptivity . It is challenging to capture  nuances of \nhuman emotion accurately without mode ling multi-granularity emotion factors in the dialogue \ngeneration. \n\uf0b7 Merely relying on the di alogue history but overlooking the potential of user feedback for the \ngenerated responses further aggravates the deficiencies above , which causes undesirable \nreactions. \nIn this paper, we propose the multi-resolution adversarial empathetic dialogue generation model, named \nEmpGAN, to address the above challenges through generating more empathetic and appropriate \nresponses. To capture  nuances of user feelings sufficiently, EmpGAN make responses by taking both \ncoarse-grained sentence -level and fine -grained token -level emotions into account. The  response \ngenerator in  EmpGAN dynamically understands sentiments along wit h a conversat ion to perceive  a \nuser\u2019s emotion states in multi -turn conversations. Furthermore, an interactive adversarial learning \nframework is augmented to take  user feedbac k into account thoughtfully, where two interactive \ndiscriminators identify whether t he generated responses evoke  emotion perceptivity regarding b oth the \ndialogue history and user emotions.P a g e  5 | 16 \n \nIn particular, the EmpGAN contains the empathetic generator and two interactive inverse discriminators. \nThe empathetic generator is composed of three components: (i) A semantic understanding module based \non Seq2Seq(sequence to sequence) neural networks that maintain the multi-turn semantic context. (ii) A \nmulti-resolution emotion perception model captures the fine and coarse-grained emotion factors of each \ndialogue turn to build the emotional framework. (iii) An empathetic response decoder combines semantic \nand emotional context to produce appropriate responses in terms of both meaning and emotion. The two \ninteractive inverse discriminator additionally incorporate the user feedback and corresponding emotional \nfeedback as inverse supervised signal to induce the generator to produce a more empathetic response. \n \nQ3. G-TAD: Sub-Graph Localization for Temporal Action Detection  \nAnswer: \nVideo understanding has gained much attention from both academia and industry over recent years, given \nthe rapid growth of videos published in online platforms. Tempora l action det ection is one of  exciting \nbut challenging tasks in this  area. It involves detecting  start and the end frames of action instances, as \nwell as predicting their class label. This is onerous, especially in long untrimmed videos. \n \nVideo context is an important cue to detect actions effectively. Here, we refer to mean as frames that are \noutside the target action but carry valuable indicative information of it. Using video context to infer \npotential actions is natural for human beings.", "mimetype": "text/plain", "start_char_idx": 4419, "end_char_idx": 9333, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "925ab3a0-1a19-4dce-8c8f-5843901ff1bc": {"__data__": {"id_": "925ab3a0-1a19-4dce-8c8f-5843901ff1bc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73bd3a44-5f9c-4ada-90d0-6a232bf6b973", "node_type": "1", "metadata": {}, "hash": "6c273ca987e839d0c00f8a814e2f8d84b9f4f4bf24dc928304cb3a7a677ce79c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0f18dbdf-03f7-4afd-8b5a-b883eee4490e", "node_type": "1", "metadata": {}, "hash": "88cd138c8f29544e9b86b0a6ea21a06b566b9c1d2d638f54cb9cce3d105deddb", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Using video context to infer \npotential actions is natural for human beings. Empirical evidence shows that human can reliably predict \nor guess the occurrence of the specific type of work by only looking at short video snippets wh ere the \naction does not happen . Therefore, incorporating context into tempora l action detection has become  \nimportant strategy to boost detection accuracy in the recent literature. Researchers have proposed various \nways to take advantage  of the video context, such as extending temporal action bou ndaries by the pre-P a g e  6 | 16 \n \ndefined ratio , using dilated convolution to encode meaning into features , and aggregating definition \nfeature implicitly by way of the Gaussian curve. All these methods only utilize temporal context, which \nfollows or precedes an action instance in its immediate secular neighborhood. Howev er, real -world \nvideos vary dramatically in temporal extent, action content, and even editing preferences. The use of \nsuch temporal contexts does not fully exploit precious merits of the video context, and it may also impair \ndetection accuracy if not adequately designed for underlying videos. \nSo, what properties characterize the desirable video context for accurate action detection? First, setting \nshould be semantically  or gra mmatically correlated to the target action other than merely temporally \nlocated in its vicinity. Imagine a case where we manually stitch an action clip into some irrelevant frames; \nthe abrupt scene change surrounding the action would not benefit the action detection. On the other hand, \nsnippets located at a distance from an operation but containing similar semantic content might provide \nindicative hints for detecting the action. Second, context should be content-adaptive rather than manually \npre-defined. Considering the vast variation of videos, a framework that helps to identify different action \ninstances could be changed in lengths and locations based on the video content. Third, context should be \nbased on multiple semantic levels, since using only one form/level of meaning is unlikely to generalize \nwell. \nIn this paper, we endow video context with all the above properties by casting action detection as a sub -\ngraph localization problem based on a gra ph convolutional network (GCN) . We re present each video \nsequence as the graph, each snippet as a node, each snippet -snippet correlation as an edge, and target \nactions associated with context as sub-graphs, as shown in Fig. 1. The meaning of a snippet is considered \nto be all snippets connected to it by an edge in a video graph. We define two types of edges \u2014 temporal \ncorners and semantic edges, each corresponding to temporal context and grammatical context, \nrespectively. Temporal edges exist between each pai r of neighboring snippets, whereas semantic edges \nare dynamically learned from the video features at each GCN layer. Hence, the multi-level context of \neach snippet is gradually aggregated into the features of the snippet throughout the entire GCN. ResNeXt \ninspires the structure of each GCN block, so we name this GCN-based feature extractor GCNeXt. \nThe pipeline of our proposed Graph -Temporal Action Detection method, dubbed G -TAD, is analogous \nto faster R -CNN in object detection. There are two critical designs in G -TAD. First, GCNeXt, which \ngenerates context -enriched features, corresponds to the backbone network, anal ogous to a series of \nConvolutional Neural Network (CNN) layers in faster R-CNN. Second, to mimic RoI(region of interest) \nalignment in faster R-CNN, we design the sub-graph alignment (SGAlign) layer to generate a fixed-size \nrepresentation for each sub-graph and embed all sub-graphs into same Euclidean space. Finally, we apply \na classifier on the features of each sub-graph to obtain detection results. We summarize our contributions \nas follows.P a g e  7 | 16 \n \n(1) We present a novel GCN -based video model to exploit video context for effective temporal action \ndetection fully. Using this video GCN representation, we can adaptively incorporate multi-level semantic \nmeaning into the features of each snippet. \n(2) We propose G-TAD, a new sub -graph detection frame work, to localize actions in video graphs. G -\nTAD includes two main modules: GCNeXt and SGAlign. GCNeXt performs graph convolutions on \nvideo graphs, leveraging both temporal and semantic context. SGAlign re-arranges sub-graph features in \nthe embedded space suitable for detection. \n(3) G-TAD achieves state-of-the-art(SOTA) performance on two popular action detection benchmarks. \nOn ActityNet -1.3, it achieves an average mAP of  34.09%.", "mimetype": "text/plain", "start_char_idx": 9257, "end_char_idx": 13910, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0f18dbdf-03f7-4afd-8b5a-b883eee4490e": {"__data__": {"id_": "0f18dbdf-03f7-4afd-8b5a-b883eee4490e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "925ab3a0-1a19-4dce-8c8f-5843901ff1bc", "node_type": "1", "metadata": {}, "hash": "6f525e7c97854b1bda0bb3b972b7db95ef6c4cf11fa2f261042e380a9598e20a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e5f3c955-d456-4449-8a6f-a82304e9acd5", "node_type": "1", "metadata": {}, "hash": "69a1bd1e2f9673f6bb0262a067e54e971afed2b0d9f319878dfa248d01485979", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "On THUMOS -14, it \nreaches 40.16%mAP@0.5, beating all contemporary one-stage methods. \n \nFig: Overview of G -TAD architecture.  The input of G -TAD is t he sequence of snippet features. We \nfirst extract features using b=3 GCNeXt blocks, which gradually aggregate both temporal and multi-level \nsemantic context. Semantic context, encoded in semant ic edges, is dynamically learned from elements \nat each GCNeXt layer. Then we feed extracted features into the SGAlign layer, where sub-graphs defined \nby the set of anchors are transformed to a fixed -size representation in the Euclidean space. Finally, th e \nlocalization module scores and ranks the sub-graphs for detection.P a g e  8 | 16 \n \nQ4. What is F3Net? \nAnswer: \n \nF3Net is a combination of Fusion, Feedback, and Focus for Salient object detection (SOD) aims to \nestimate the significant visual regions of images or videos and often serves as the pre-processing step for \nmany downstream vision tasks . Earlier SOD algorithms mainly rely on heuristic priors ( e.g., color, \ntexture and contrast) to generate saliency maps. However, these hand -craft features can hardly capture \nhigh-level semantic relations and context information . T hus they are not robust enough to complex \nscenarios. Recently, convolutional neural networks (CNNs) have demonstrated its powerful feature \nextraction capability i n visual feature representation.  Many CNNs -based models  have achieved \nremarkable progress and pushed the performance of SOD to a new level. These models adopt the \nencoder-decoder architecture, which is simple in structure and computationally efficie nt. The encoder \nusually is made up of a pre -trained classification model (e.g. , ResNet and VGG ), which can extract \nmultiple features  of different semantic levels and resolutions. In the decoder, extracted features are \ncombined to generate saliency maps. \nHowever, there remain two significant challenges in accurate SOD. First, features of different levels have \ndifferent distribution chara cteristics. High-level features have rich semantics but lack precise location \ninformation. Low -level features have rich details but full of background noises. To generate better \nsaliency maps, multi-level features are combined. However, without delicate c ontrol of the information \nflow in the model, some redundant features, including noises from low-level layers and coarse boundaries \nfrom high-level layers, will pass in and possibly result in performance degradation. Second, most of the \nexisting models use binary cross-entropy that treats all pixels equally. Intuitively, different pixels deserve \ndifferent weights, e.g., pixels at the boundary are more discriminative and should be attached with more \nimportance. Various boundary losses  have been proposed to enhance the boundary detection accuracy, \nbut considering only the boundary pixels is not comprehensive enough since there are lots of pixels near \nthe boundaries prone to wrong predictions. These pixels are also essential and should be assigned withP a g e  9 | 16 \n \nlarger weights. In consequence, it is essential to design a mechanism to reduce the impact of \ninconsistency between features of different levels and assign larger weights to those significant pixels. \nTo address the above challenges, we proposed a novel SOD framework, named F 3Net, which achieves \nremarkable performance in producing high -quality saliency maps. First,  to mitigate the discrepancy \nbetween features, we design a cross-feature module (CFM), which fuses elements of different levels by \nelement-wise multiplication. Different from addition and concatenation, CFM takes a selective fusion \nstrategy, where redundant information will be suppressed to avoid the contamination between features , \nand important features will complement each other. Compared with traditional fusion methods, CFM can \nremove background noises and sharpen boundaries, as shown in Fig.  1. Second, due to downsampling, \nhigh-level features may suffer from information loss and distortion, which can not be solved by CFM. \nTherefore, we develop the cascaded feedback decoder (CFD) to refine these features iteratively. CFD \ncontains multiple sub-decoders, each of which includes both bottom-up and top-down processes. For the \nbottom-up method, multi-level features are aggregated by CFM gradually. For the top-down process, \naggregated features are feedback into previous features to refine them. Third, we propose the pixel \nposition-aware loss (PPA) to imp rove the commonly used binary cross -entropy loss , which treats all \npixels equally. Pixels located at boundaries or elongated areas are more complicated and discriminating.", "mimetype": "text/plain", "start_char_idx": 13911, "end_char_idx": 18598, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e5f3c955-d456-4449-8a6f-a82304e9acd5": {"__data__": {"id_": "e5f3c955-d456-4449-8a6f-a82304e9acd5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0f18dbdf-03f7-4afd-8b5a-b883eee4490e", "node_type": "1", "metadata": {}, "hash": "88cd138c8f29544e9b86b0a6ea21a06b566b9c1d2d638f54cb9cce3d105deddb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a23085ae-b0a8-44d0-8af9-0454c89cc701", "node_type": "1", "metadata": {}, "hash": "43a8bc9c45007eca644d5c927b77d248cd82fef8e7fffa2d569f834cde11ed43", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Pixels located at boundaries or elongated areas are more complicated and discriminating. \nPaying more attention to these hard pixels can further enhance model generaliz ation. PPA loss assigns \ndifferent weights to different pixels, which extends binary cross -entropy. The weight of each pixel is \ndetermined by its surrounding pixels. Hard pixels will get larger weights, and easy pixels will get smaller \nones. \nTo demonstrate the performance of F3Net, we report experimental results on five popular SOD datasets \nand visualize some saliency maps. We conduct a series of ablation studies to evaluate the effect of each \nmodule. Quantitative indicators and visual results show that F 3Net can obtain significantly better local \ndetails and improved saliency maps. Codes ha ve been released. In short, our main contributions can be \nsummarized as follows: \n\uf0b7 We introduce the cross feature module to fuse features of different levels, which can extract the \nshared parts between features and suppress each other\u2019s background noises and complement each \nother\u2019s missing parts. \n\uf0b7 We propose the cascaded feedback decoder for SOD, which can feedback features of both high \nresolutions and high semantics to pr evious ones to correct and refine them for better saliency \nmaps generation. \n\uf0b7 We design pixel position-aware loss to assign different weights to different positions. It can better \nmine the structure information contained in the features and help the network focus more on \ndetail regions.P a g e  10 | 16 \n \n\uf0b7 Experimental results demonstrate that the proposed model F 3Net achieves the state -of-the-art \nperformance on five datasets in terms of six metrics, which proves the effectiveness and \nsuperiority of the proposed method. \n \nQ5.Natural Language Generation using Reinforcement Learning with \nExternal Rewards \nAnswer: \nWe aim to develop models that are capable of generating language acro ss several genres of text , \nconversational texts, and restaurant re views. After all, humans are ad ept at both. Extant NLG(natural \nlanguage generation ) models work on either conversational text ( like movie dialogues) or longer text \n(e.g., stories, reviews) but not both.  Also, while the state -of-the-art(SOTA) in this field has advanc ed \nquite rapidly, current model  is prone to generate language that is s hort, dull, off -context. More \nimportantly, a generated languag e may not adequately reflect  affective content of the input. Indeed, \nhumans are already adept at t his task, as well. To address these re search challenges, we propose the \nRNN-LSTM architecture that uses an encoder-decoder network. We also use reinforcement learning(RL) \nthat incorporates internal and external rewards. Specifically, we use emotional appropriate ness as an \ninternal reward for the NLG (Natural Language Generation) system \u2013 so that the emotional tone of \ngenerated language is consistent with the emotional tone of p rior context fed as input to model. We also \neffectively incorporate usefulness scores as external rewards in our model. Our main contribution is the \nuse of distantly labeled data in  architecture that generates coherent, affective content and we test the \narchitecture across two different genres of text. \nWhat are the problem statement and their intuition? \nOur aim is to take advantage of reinforcement learning (RL) and external rewards during the process of \nlanguage generation. Complementary to this goal, we also aim  to generate language that has  same \nemotional tone as the other input. Emotions are recog nized as functional in decision -making by \ninfluencing motivation and action selection.  However, the external fe edback and rewards are hard to \ncome by for language generation; these would need to be provided  through crowdsourcing judgment on \ngenerated responses during generation process, which makes process time-consuming and impractical. \nTo overcome th is problem, we look for distance labeling and use labels provided in  training set as a \nproxy for human ju dgment on generated responses. Particularly, we inc orporate usefulness scores in a \nrestaurant review corpus as the proxy for external feedback.P a g e  11 | 16 \n \n \nFig. 1: Overall Architecture of the system showing internal and external rewards using reinforcement \nlearning \nQ6. LaFIn: Generative Landmark Guided Face Inpainting  \nAnswer: \nImage inpainting ( a.k.a. image completion) refers to the process of reconstructing lost or deteriorated \nregions of images, which can be applied to, as a fundamental component, various tasks suc h as image \nrestoration and editing.  Undoubtedly, one expects the completed result to be realistic  so that the \nreconstructed regions can be hardly perceived.", "mimetype": "text/plain", "start_char_idx": 18510, "end_char_idx": 23231, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a23085ae-b0a8-44d0-8af9-0454c89cc701": {"__data__": {"id_": "a23085ae-b0a8-44d0-8af9-0454c89cc701", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e5f3c955-d456-4449-8a6f-a82304e9acd5", "node_type": "1", "metadata": {}, "hash": "69a1bd1e2f9673f6bb0262a067e54e971afed2b0d9f319878dfa248d01485979", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c549c20d-91eb-4b4e-a135-3c2ab732ac8f", "node_type": "1", "metadata": {}, "hash": "6ded0dc598d840dccf4ecc2d7dd2e275f4700c9d68857a3bd8cadfcc3c2734a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Compared with natural scenes like oceans and lawns, \nmanipulating faces, the focus of this work, is more challenging. Because the faces have much stronger \ntopological structure and attribute consistency to preser ve. Figure 1 shows three such examples. Very \noften, given the o bserved clues, human beings can easily infer what the lost parts possibly, although \ninexactly, look like. As a consequence, a slight violation o f the topological structure and  the attribute \nconsistency in the reconstructed face highly likely leads to a significant perceptual flaw. The following \ndefines the problem: \nDefinition: \nFace Inpainting. Given a face image , I with corrupted regions masked by  M. Let \u00af\u00af\u00af\u00af\u00af\u00afM designate the \ncomplement of  M and \u2218 the Hadamard  product. The goal is to fill the target part with semantically \nmeaningful and visually continuous information to the observed part. In other words, the completedP a g e  12 | 16 \n \nresult ^I:=M\u2218^I+\u00af\u00af \u00af \u00af \u00af\u00afM\u2218I should preserve the topological structure among face components suc h as \neyes, nose, and mouth, and the attribute consistency on like pose gender, ethnicity, and expression. \n           \nFigure 1:  Three face completion results by our method. From left to right: corrupted inputs, plus \nlandmarks predicted from the inputs, and our final results, respectively.  \n       \nQ7. Image2StyleGAN++: How to Edit the Embedded Images?  \nAnswer: \n \n \n(i)                             (ii)                              (iii)                                (iv)  \nFrom above fig: (i) and (ii): input images; (iii): the \u201ctwo-face\u201d generated by naively copying the left half \nfrom (i) and the right half from (ii); (iv): the \u201ctwo-face\u201d created by our Image2StyleGAN++ framework. \nRecent GANs demonstrated that synthetic images c ould be generated with very high q uality. This \nmotivates research into embedding algorithms that embed a given photograph into a GAN latent space. \nSuch embedding algorithms can be used to analyze the limitations of GANs , do image inpainting, local \nimage editing, global image transformations such as image m orphing and expression transfer, and few-\nshot video generation.P a g e  13 | 16 \n \nIn this paper, we propose to extend a very recent embedding algorithm, Image2StyleGAN. In particular, \nwe would like to improve this previous algorithm in three aspects. First, we noticed that the embedding \nquality could be further improved by including No ise space optimization into  embedding framework. \nThe key insight here is that stable Noise space optimizat ion can only be conducted if optimization is \ndone sequentially with W+ space and not jointly. Seco nd, we would like to improve  capabilities of the \nembedding algorithm to increase the local control over the embedding. One way to improve local \nauthority is to include mask in embedding algorithm with undefined content. The goal of the embedding \nalgorithm should be to find a plausible embedding for everything outside the mask, while filling in \nreasonable semantic content in the masked pixels. \nSimilarly, we would like to provide the option of approximate embeddings, where t he specified pixel \ncolors are only a guide for the embedding. In this way, we aim to achieve high -quality embeddings that \ncan be controlled by user scribbles. In the third technical part of the paper, we investigate the combination \nof embedding algorithm and direct manipulations of the activation maps (called activation tensors in our \narticle). \nQ8. oops! Predicting Unintentional Action in Video \nAnswer: \nFrom just a glance at the video, we can  often tell whether a person\u2019s action is intentional or not. For \nexample, the Below figure shows a person attempting to jump off a raft, but unintentionally tripping into \nthe sea. In a classic series of papers, developmental psychologist Amanda Woodward demonstrated that \nchildren learn this ability to recognize the intentionality of actio n during their first year. However, \npredicting the intention behind action has remained elusive for machine vision. Recent advances in action \nrecognition have primarily focused on predicting the physical motions and atomic operations in the video, \nwhich captures the means of action but not the intent of action.  \nWe believe a key limitation for perceiving visual intentionality has been the lack of realistic data with \nnatural variation of intention. Although there are now extensive video datasets for action recognition, \npeople are usually competent, which causes datasets to be biased towards successful outcomes.", "mimetype": "text/plain", "start_char_idx": 23232, "end_char_idx": 27783, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c549c20d-91eb-4b4e-a135-3c2ab732ac8f": {"__data__": {"id_": "c549c20d-91eb-4b4e-a135-3c2ab732ac8f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a23085ae-b0a8-44d0-8af9-0454c89cc701", "node_type": "1", "metadata": {}, "hash": "43a8bc9c45007eca644d5c927b77d248cd82fef8e7fffa2d569f834cde11ed43", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "34417008-d287-4ec6-8824-9c4a9933dadb", "node_type": "1", "metadata": {}, "hash": "f74fbb5d7c377f7e5c1a882944590d8af496f508e888bfe00fdc52c4f80f9e39", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "However, \nthis bias for success makes discriminating and localizing visual intentionality  challenging for both \nlearning and quantitative evaluation.P a g e  14 | 16 \n \n \nFig: The oops! Dataset: Each pair of frames shows an example of intentiona l and unintentional \naction in our dataset. By crawling publicly available \u2018\u2018fail\u2019\u2019 videos from the web, we can create a \ndiverse and in-the-wild dataset of accidental action. For example, at the bottom-left corner shows \na man failing to see  gate arm, and at the top-right shows two children playing  competitive games \nwhere it is inevitable; one person will fail to accomplish their goal. \nWe introduce a new annotated video dataset that is abundant with unintentional action, which we have \ncollected by crawling publicly available \u2018\u2018fail\u2019\u2019 videos from the web. From the above figure shows some \nexamples, which cover in -the-wild situations for both intentional and unintentional action. Our video \ndataset, which we will publicly release, is both large (over 50 hours of video) and diverse (covering \nhundreds of scenes and activities). We annotate d videos with the temporal location at which the video \ntransitions from intentional to unintentional action. We define three tasks on this dataset: classifying the \nintentionality of action, localizing the change from intentional to unintentional, and for ecasting onset of \nunintentional action shortly into the future. \nTo tackle these problems, we investigate several visual clues for learning with minimal labels to \nrecognize intentionality. First, we propose a novel self -supervised task to learn to predi ct the speed of \nthe video, which is incidental supervision available in all unlabeled video s for learning the action \nrepresentation. Second, we e xplore the predictability of  temporal context as a clue to learn features, as \nunintentional action often deviate s from expectation. Third, we study an order of events as a clue to \nrecognize intentionality, since intentional action usually precedes unintentional action.  \nExperiments and visualizations suggest that unlabeled video has intrinsic perceptual clues to rec ognize \nintentionality. Our results show that, while each self-supervised task is useful, and learning to predict the \nspeed of video helps the most. By ablating model and design choices, our analysis also suggests that \nmodels do not rely solely on low -level motion clues to solve unintentional action prediction. Moreover, \nalthough human's consistency in our dataset is high, there is still a large gap in performance between our \nmodels and human agreement, underscoring that analyzing h uman goals from videos remains t heP a g e  15 | 16 \n \nfundamental challenge in computer vision (OpenCV). We hope this dataset of unintentional and \nunconstrained action can provide the pragmatic benchmark of progress. \nQ9. FairyTED: A Fair Rating Predictor for TED Talk Data  \nAnswer: \nIn recent times, artificial intelligence is bei ng used for inconsequential decision making. Governments \nmake use of it in the criminal justice system to predict \nrecidivism [brennan2009evaluating, tollenaar2013method], which affects the decision about bail, \nsentencing, and parole. Various firms are also using machine learning algorithms to examine and filter \nresumes of job applicants  [nguyen2016hirability, chen2017automated, naim2016automated], which is \ncrucial for the growth of a company. Machine learning algorithms are also being used to evaluate \nhuman\u2019s social skills, such as presentation performance [Chen2017a, Tanveer2015], essay grading. \nTo solve such decision -making problems, machine learning algorithms are trained on massive datasets \nthat are usually collected in the wild. Due to difficulties in the manual  curation or adjustment over large \ndatasets, the data likely capture unwanted bias towards the underrepresented group based on race, gender, \nor ethnicity. Such bias results in unfair decision -making systems, leading to unwanted and often \ncatastrophic consequences to human life and society. For example, the recognition rates of pedestrians \nin autonomous vehicles are reported to be not equally accurate for all groups of \npeople [wilson2019predictive]. Matthew et al. [kay2015unequal]showed that societal bias gets reflected \nin the machine learning algorithms through a biased dataset and causes representational harm for \noccupations. Face recognition is not as useful for people with different skin tones. Dark-skinned females \nhave 43 times higher detection error than light-skinned males. \nIn this work, we propose a predictive framework that tackles the issue of designing a fair prediction \nsystem from biased data.", "mimetype": "text/plain", "start_char_idx": 27784, "end_char_idx": 32468, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "34417008-d287-4ec6-8824-9c4a9933dadb": {"__data__": {"id_": "34417008-d287-4ec6-8824-9c4a9933dadb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c549c20d-91eb-4b4e-a135-3c2ab732ac8f", "node_type": "1", "metadata": {}, "hash": "6ded0dc598d840dccf4ecc2d7dd2e275f4700c9d68857a3bd8cadfcc3c2734a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "41fbfc9f-e337-43b9-b0a7-37bb0df3e3a5", "node_type": "1", "metadata": {}, "hash": "ce816c41c4ed5f6a93e7bd6fd5df48d34552d1b2e114b9bd0a946aaf78975b20", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "As an application scenario, we choose the problem of fair rating predicti on in \nthe TED talks. TED talks cover a wide variety of topics and influence the audience by educating and \ninspiring them. Also, it consists of speakers from a diverse community with imbalances in age, gender, \nand ethnic attributes. The ratings are pr ovided by spontaneous visitors to the TED talk website. A \nmachine learning algorithm trained solely from the audience ratings will have a possibility of the \npredicted score being biased by sensitive attributes of the speakers.  \nIt is a challenging problem because numerous factors drive human behavior  and hence have huge \nvariability. It is challenging to know the way these factors interact with each other. Also, uncovering the \ntrue interaction model may not be feasible and often expensive. Even though the sharing platforms such \nas YouTube, Massive Open Online Courses (MOOC), or  ted.com make it possible to collect a large \namount of observational data, these platforms do not correct for bias and unfair ratings.P a g e  16 | 16 \n \nIn th is work, we utilize  causal models  [pearl2009causal] to define possible dependencies between \nattributes of the data. We then address the problem of not knowing true interaction model by averaging \noutputs of predictors across several possible causes. Furth er, using these causal models , we \ngenerate counterfactual samples  of sensitive attributes. These counterfactual samples are the key \ncomponents in our fair prediction framework (adapted \nfrom  kusner2017counterfactual russell2017worlds) and help reducing b ias in ratings wrt sensitive \nattributes. Finally, we introduce the  novel metric to quantify  degree of fairness employed by our \nFairyTED pipeline. To  best o f our knowledge, FairyTED is  first fair prediction pipeline for  public \nspeaking dataset s and can be applied to any dataset of  similar grounds. Apart from  theoretical \ncontribution, our work also has practical implications in helping both the viewers and  organizers make \ninformed and unbiased choices for the selection of talks and speakers.P a g e  1 | 16 \n \n  \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n   (30 Days of Interview Preparation) \n \n# Day22P a g e  2 | 16 \n \nQ1. Explain V-Net (Volumetric Convolution) Architecture with related \nto Biomedical Image Segmentation? \nAnswer: \nThere were several  medical data used in clinical practice consists of 3D volumes, such as MRI \nvolumes illustrate prostate, while most approaches are only able to process 2D images. A 3D image \nsegmentation based on a volumetric, fully convolutional neural network is proposed in this work. \n \n                              Slices from MRI volumes depicting prostate \nProstate segmentation nevertheless is the crucial task having clinical relevance both during diagnosis, \nwhere the volume of the prostate needs to be assessed and during treatment planning, where the \nestimate of the anatomical boundary needs to be accurate. \nArchitectureP a g e  3 | 16 \n \n\uf0b7 V-Net, justifies by its name, it is shown as V-shape. The left part of the network consists of \na compression path , while on the right part decompresses  signal until its original size is \nreached. \n\uf0b7 This is the same as U-Net, but with some difference. \n \nOn Left \n\uf0b7 The left side of the network is divided into different stages that operate at various resolutions. \nEach stage comprises one to 3 convolutional layers. \n\uf0b7 At each stage, a  residual function is learn ed. The inp ut of each stage is used in \nconvolutional layers and processed through non-linearities and added to the output of the last \nconvolutional layer of that stage to enable learning a residual function. This V-net \narchitecture ensures convergence compared with non-residual learning networks such as U-\nNet. \n\uf0b7 The convolutions performed in each stage use volumetric kernels having the size of 5\u00d75\u00d75 \nvoxels. (A voxel represents a value on a regula r grid in 3D -space. The term voxel is \ncommonly used in 3D much 3D space, just like voxelization in a point cloud.) \n\uf0b7 Along the compression path, the resolution is reduced by convolution with 2\u00d72\u00d72 voxels \nfull kernels applied with stride 2 . Thus, the size of the resulting feature maps is halved, \nwith a similar purpose as pooling layers . And number of feature channels doubles at \neach stage of the compression path of  V-Net.", "mimetype": "text/plain", "start_char_idx": 32469, "end_char_idx": 36850, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "41fbfc9f-e337-43b9-b0a7-37bb0df3e3a5": {"__data__": {"id_": "41fbfc9f-e337-43b9-b0a7-37bb0df3e3a5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34417008-d287-4ec6-8824-9c4a9933dadb", "node_type": "1", "metadata": {}, "hash": "f74fbb5d7c377f7e5c1a882944590d8af496f508e888bfe00fdc52c4f80f9e39", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3d640b84-a669-4a62-87c0-7b9bffae4355", "node_type": "1", "metadata": {}, "hash": "59eb18f438944c75f32df3493f5060cc9055b5647c02bb43fdcd8d296565fb63", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Replacing pooling operations with convolutional ones helps to have a smaller memory \nfootprint during training because no switches mapping the output of pooling layers back to \ntheir inputs are needed for back-propagation. \n\uf0b7 Downsampling helps to increase the receptive field. \n\uf0b7 PReLU is used as a non-linearity activation function. \n \nOn Right Part \n\uf0b7 The network e xtracts features and  expands spatial support of the lower resolution feature \nmaps to gather and assemble the necessary information to output a two -channel volumetric \nsegmentation.P a g e  4 | 16 \n \n \n\uf0b7 At each stage, a  deconvolution operation is employed to increase the size of the inputs \nfollowed by one to three convolutional layers,  involving half the number of 5\u00d75\u00d75 \nkernels applied in the previous layer. \n\uf0b7 The residual function is learned, similar to left part of the network. \n\uf0b7 The 2 features maps computed by  a very last convolutional layer , having 1\u00d71\u00d71 kernel \nsize and producing outputs of the same size as input volume. \n\uf0b7 These two output feature maps are the probabilistic segmentation of the foreground and \nbackground regions by applying soft-max voxelwise. \n \nQ2. Highway Networks- Gating Function to highway \n \nAnswer: \nIt is found that difficulties are optimizing a very deep neural network. However, it\u2019s still an open \nproblem with why it is difficult to optimize a deep network. (it is due to gradient vanishing problem.) \nInspired by LSTM (Long Short-Term Memory), authors thereby  make use of gating function to \nadaptively bypass or transform the signal so that the network can go deeper. The deep network \nwith more than 1000 layers can also be optimized.  \nPlain Network \nBefore going into Highway Networks, Let us  start with plain network which consists of  L layers \nwhere the l-th layer (with omitting the symbol for the layer): \n                           \nWhere x is input, WH is the weight, H is the transform function followed by an activation function , \nand y is the output. And for i-th unit: \n                                               \nWe compute the yi and pass it to the next layer. \nHighway NetworkP a g e  5 | 16 \n \n \nIn a highway network, 2 non-linear transforms T and C are introduced: \n \nwhere T is Transform Gate, and C is the Carry Gate. \nIn particular, C = 1 - T: \n \nWe can have below conditions for specific T values: \n \nWhen T=0, we pass input as output directly, which creates an information highway. That\u2019s why \nit is called the Highway Network. \nWhen T=1, we use non-linear activated transformed input as output. \nHere, in contrast to the  i-th unit in plain network, the authors introduce the block concept. For i-th \nblock, there is a block state Hi(x), and transform gate output Ti(x). And the corresponding block \noutput yi: \n \nwhich is connected to the next layer. \n\uf0b7 Formally, T(x) is the sigmoid function:P a g e  6 | 16 \n \n \nSigmoid function caps the output between 0 to 1. When the input has a too-small value, it becomes \n0. When the input has a too -large amount, it becomes 1.  Therefore, by learning  WT and bT, a \nnetwork can adaptively pass H(x) or pass x to the next layer. \nAnd the author claims that this helps to have the  simple initialization scheme for  WT which is \nindependent of nature of H. \nbT can be initialized with the negative value (e.g., -1, -3, etc.) such that the network is initially biased \ntowards carrying behaviour. \nLSTM inspires the above idea as the authors mentioned. \nAnd SGD(Stochastic Gradient Descent)  did not stall for networks with more than 1000 \nlayers. However, the exact results have not been provided. \nQ3. What is DetNAS: Neural Architecture Search(NAS) on Object \nDetection? \n \nAnswer: \nObject detection is one of the most fundamental computer vision(OpenCV) tasks and has been widely \nused in real -world applications. The performance of object detectors highly rel ies on features \nextracted by backbones. However, most works on object detection  directly use networks designed \nfor classification as a backbone the feature extractors, e.g., ResNet. The architectures optimized on \nimage classification can not guarantee performance on object detection. It is known that there is an \nessential gap between these two different tasks.", "mimetype": "text/plain", "start_char_idx": 36852, "end_char_idx": 41087, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3d640b84-a669-4a62-87c0-7b9bffae4355": {"__data__": {"id_": "3d640b84-a669-4a62-87c0-7b9bffae4355", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "41fbfc9f-e337-43b9-b0a7-37bb0df3e3a5", "node_type": "1", "metadata": {}, "hash": "ce816c41c4ed5f6a93e7bd6fd5df48d34552d1b2e114b9bd0a946aaf78975b20", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0011a0e6-717f-46ae-ac2c-969b0bbacc17", "node_type": "1", "metadata": {}, "hash": "2600f91ce6583365342e9bb898b9d8704262618c9fb36543c51053d0594d042f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is known that there is an \nessential gap between these two different tasks. Image classification  basically focuses on \u201dWhat\u201d \nmain object of the image is, while object detection aims at finding \u201dWhere\u201d and \u201dWhat\u201d each objectP a g e  7 | 16 \n \ninstance in an image. There have been little works focusing on backbone design for object detector, \nexcept the hand-craft network, DetNet. \nNeural architecture search (NAS) has achieved significant progress in image classification  and \nsemantic segmentation. The networks produced by search have reached or even surpa ssed the \nperformance of the hand-crafted ones on this task. But object detection has never been supported by \nNAS before. Some NAS(Neural architecture search) work directly applies architecture searched on \nCIFAR-10 classification on object detection. \n \nIn this work, we present  the first effort towards learning a backbone network for  object detection \ntasks. Unlike previous NAS works, our method does not involve any architecture-level transfer. We \npropose DetNAS to conduct neural architecture search directly on the target tasks. The quests are \neven performed with precisely the same settings to  the target task. Training a n objector detector \nusually needs several days and GPUs, no matter using a pre-train-finetune scheme or training from \nscratch. Thus, it is not affordable to directly use reinforcement learning (RL) or evolution algorithm \n(EA) to search the architectures independently. To overcome this obstacle, we formulate this problem \ninto searching the optimal path in the large graph or supernet. In simple terms , DetNAS consists of \nthree steps: (1) training a supernet that includes all sub -networks in search space; (2) searching for \nthe sub -network with the highest performance on the validation set with EA; (3) retraining the \nresulting network and evaluating it on the test set. \nQ4.You have any idea about ECE (Emotion cause extraction). \n \nAnswer: \nEmotion cause extraction (ECE) aims at extracting potential causes that lead to emotion expressions \nin the text. The ECE task was first proposed and defined as a word-level sequence labeling problem \nin Lee et al. To solve the shortcoming of extracting causes at the word level, Gui et al. 2016 released \na new corpus which has received much attention in the following study and become s a benchmark \ndataset for ECE research.P a g e  8 | 16 \n \nBelow Fig. Displays an example from this corpus, there are five clauses in a document. The emotion \n\u201chappy\u201d is contained in fourth clause. We denote this clause as an emotion clause, which refers to a \nterm that includes emotions. It has two corresponding causes: \u201ca policeman visited the old man with \nthe lost money\u201d in the second clause and, \u201ctold him that the thief was caught\u201d in the third clause. We \nname them as cause clause, which refers to a term that contains causes. \n \nIn this work, we propose a new task:  emotion-cause pair extraction (ECPE), which aims to extract \nall potential pairs of emotions and corresponding causes in the document. In Above Fig, we show the \ndifference between the traditional ECE task and our new ECPE task. The goal of ECE is to extrac t \nthe corresponding cause clause of the given emotion. In addition to a document as the input, ECE \nneeds to provide annotated feeling at first before cause extraction. \nIn contrast, the output of our ECPE task is a pair of emotion -cause, without the need of  providing \nemotion annotation in advance. From Above fig., e.g., given the annotation of feeling: \u201chappy,\u201d the \ngoal of ECE is to track the two corresponding cause clauses: \u201ca policeman visited the old man with \nthe lost money\u201d and \u201cand told him that the thief was caught.\u201d While in the ECPE task, the goal is to \ndirectly extract all pairs of emotion clause and cause clause, including (\u201cThe old man was delighted\u201d, \n\u201ca policeman visited the old man with the lost money\u201d) and (\u201cThe old man was pleased\u201d, \u201cand told \nhim that the thief was caught\u201d), without providing the emotion annotation \u201chappy\u201d. \nTo address this new ECPE task, we propose a two -step framework. Step 1 converts the emotion -\ncause pair extraction task to two individual sub -tasks (emotion extraction and cau se extraction \nrespectively) via two kinds of multi -task learning networks, intending to extract a set of emotion \nclauses and a set of cause clauses. Step 2 performs emotion-cause pairing and filtering. We combine \nall the elements of the two sets into pairs and finally train a filter to eliminate the couples that do not \ncontain a causal relationship.", "mimetype": "text/plain", "start_char_idx": 41009, "end_char_idx": 45588, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0011a0e6-717f-46ae-ac2c-969b0bbacc17": {"__data__": {"id_": "0011a0e6-717f-46ae-ac2c-969b0bbacc17", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3d640b84-a669-4a62-87c0-7b9bffae4355", "node_type": "1", "metadata": {}, "hash": "59eb18f438944c75f32df3493f5060cc9055b5647c02bb43fdcd8d296565fb63", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "547a846e-32a9-49f1-b232-d23b43ec936d", "node_type": "1", "metadata": {}, "hash": "427208e003f93c35e11ae9a319f194c17df567fe801dc1f06681412bdf435e2e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q5.What is DST (Dialogue state tracking)? \nAnswer:P a g e  9 | 16 \n \nDialogue state tracking (DST) is a core component in task -oriented dialogue systems, such as \nrestaurant reservations or ticket bookings. The goal of DST is to extract user goals expressed during \nconversation and to encode them as a compact set of the dialogue states, i.e., a set of slots and their \ncorresponding values. E.g., as shown in below fig. , (slot, va lue) pairs such as  (price, \ncheap) and (area, centre)  are extracted from  the conversation. Accurate DST performance is \nimportant for appropriate dialogue management, where user intention determines the next system \naction and the content to query from the databases. \n \n State tracking approaches are based on the assumption that ontology is defined in advance, where \nall slots and their values are known. Having a predefined ontology can simplify DST into a \nclassification problem and improve performance  (Henderson et  al., 2014b; Mrk\u0161i \u0107 et al., 2017; \nZhong et  al., 2018). However, there are two significant drawbacks to this approach: 1) A full \nontology is hard to obtain in advance  (Xu and Hu,  2018). In the industry, databases are usually \nexposed through an external API only, which is owned and maintained by others. It is not feasible to \ngain access to enumerate all the possible va lues for each slot. 2) Even if a full ontology exists, the \nnumber of possible slot values could be significant and variable. For example, a restaurant name or \na train departure time can contain a large number of possible values. Therefore, many of the previous \nworks that are based on neural classification models may not be applicable in real scenarios. \nQ6.What is NMT(Neural machine translation)? \nAnswer: \nNMT stands for Neural machine translation, which is the use of neural network models to learn the \nstatistical model for machine translation.P a g e  10 | 16 \n \nThe key be nefit to the approach is that the single system can be trained directly on the source and \ntarget text, no longer requiring the pipeline of specialized methods used in statistical (ML)machine \nlearning. \nUnlike the traditional phrase-based translation system which consists of many sub-components that \nare tuned separately, neural machine translation attempts to build and train a single, large neural \nnetwork that reads a sentence and outputs a correct translation. \nAs such, neural machine translation (NMT) systems are said to be end -to-end systems as only one \nmodel is required for the translation. \n \nIn Encoder \nThe task of the encoder is to provide the representation of a input sentence.The input sentence is a \nsequence of words, for which we first consult  embedding matrix. Then, as in the primary language \nmodel described previously, we process these words with a recurrent neural network (RNN). This \nresults in hidden states that encode each word with its left cont ext, i.e., all the preceding words. To \nalso get the right context, we also build a recurrent neural network (RNN) that runs right-to-left, or, \nfrom the end of the sentence to  beginning. Having two recurrent neural networks (RNN) running in \ntwo directions is known as the bidirectional recurrent neural network(RNN). \nIn Decoder \nThe decoder is the  recurrent neural network (RNN). It takes some representation of  input context \n(more on that in the next section on the attention mechanism) and previous hidden state and the output \nword prediction, and generates a new hidden decoder state and the new output word prediction. \nIf you use LSTMs for the encoder, then you also use LSTMs for the decoder. From hidden state. You \nnow predict the output word. This prediction takes the form of the probability distribution over entire \noutput vocabulary. If you  have a vocabulary of, say, 50,000 words, then the prediction is a 50,000 \ndimensional vector, each element corresponding to the probability predicted for one word in the \nvocabulary. \nQ7. What is Character-Level models (CLM)? \nAnswer: \nIn English, there is strong empirical evidence that the character sequence that create up proper nouns \ntend to be distinctive. Even divorced of context,human reader can predict that \u201choekstenberger\u201d is an \nentity, but \u201cabstractually\u201d  is not .", "mimetype": "text/plain", "start_char_idx": 45590, "end_char_idx": 49843, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "547a846e-32a9-49f1-b232-d23b43ec936d": {"__data__": {"id_": "547a846e-32a9-49f1-b232-d23b43ec936d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0011a0e6-717f-46ae-ac2c-969b0bbacc17", "node_type": "1", "metadata": {}, "hash": "2600f91ce6583365342e9bb898b9d8704262618c9fb36543c51053d0594d042f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff0550ba-a042-4733-a9bc-58c67f3ee653", "node_type": "1", "metadata": {}, "hash": "c8f1753224fee049b6ad43171f88f25312e4f9eef6b274724e9bf86409a4861a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Some NER research explores  use of character -level featuresP a g e  11 | 16 \n \nincluding capitalization, prefixes and suffixes Cucerzan and Yarowsky ; Ratinov and Roth ( 2009), \nand character-level models (CLMs) Klein et al. (2003) to improve the performance of NER, but to \ndate there has been no systematic study isolating utility of CLMs in capturing the distinctions between \nname and non-name tokens in English or across other languages. \n \nWe conduct the  experimental assessment of the discriminative power of CLMs for a rang e of \nlanguages: English, Arabic, Amharic, Bengali, Farsi, Hindi, Somali, an d Tagalog. These languages \nuse the variety of scripts and orthographic conventions (e.g, only three use capitalization), come from \ndifferent language families, and vary in their morpholo gical complexity. We represent the \neffectiveness of CLMs(character-level models) in distinguishing name tokens from non-name tokens, \nas illustrated by the above Figure, which shows confusion in histograms from a CLM trained on \nentity tokens. Our models use  individual tokens, but perform extremely well in spite of taking no \naccount of the word context. \nWe then assess the utility of directly adding simple features based on this CLM (character-level \nmodel) implementation to an existing NER system, and show that they have the significant positive \nimpact on performance across many of the languages we tried. By adding very simple CLM -based \nfeatures to the system, our scores approach those of a state -of-the-art(SOTA) NER system Lample \net al. (2016) across multiple languages, representing both the unique importance and broad utility of \nthis approach. \n \nQ8.What is LexNLP package? \nAnswer: \nOver the last 2 decades, many high -quality, open -source packages for natural language \nprocessing(NLP) and machine learning (ML) have been released. Developers and researchers  can \nquickly write applic ations in languages such as Python, Java, and R that stand on shoulders ofP a g e  12 | 16 \n \ncomprehensive, well -tested libraries such as  Stanford NLP (Manning et  al. ( 2014)), OpenNLP \n(ApacheOpenNLP (2018)), NLTK (Bird et al. (2009)), spaCy (Honnibal and Montani (2017), scikit-\nlearn library (Buitinck et  al. ( 2013), Pedregosa et  al. ( 2011)), and G ensim ( \u0158eh\u016f\u0159ek and Sojka \n(2010)). Con sequently, for most of the domains,  rate o f research has increased and  cost of the \napplication development has decreased. \nFor some specialized areas like  marketing and medicines , there are focused libr aries and \norganizations like  BioMedICUS (Consortium ( 2018)), RadLex (Langlotz ( 2006)), and the Open \nHealth Natural Language Processing (NLP) Consortium. Law, however, has received substantially \nless attention than others, despite its ubiquity, societal importance, and the specialized form. LexNLP \nis designed to fill this gap by providing bot h tools and data for developers and researcher s to work \nwith real legal and regulatory text, including statutes, regulations, the court opinions, briefs, contracts, \nand the other legal work products. \nLaw is the domain driven by language, logic, and the conceptual relationships, ripe for computation \nand analysis (Ruhl et al. (2017)). However, in our experience, natural language processing(NLP) and \nmachine learning(ML) have not been applied as fruitfully or widely in legal as one might hope. We \nbelieve that the key impediment to academic and commercial application has been lack of tools that \nallow users to turn the real, unstructured legal document  into structured data objects. The G oal of \nLexNLP is to make this task simple, whether for the analysis of statutes, regulations, court opinions, \nbriefs or the migration of legacy contracts to smart contract or distributed ledger systems. \n \nQ9.Explain The Architecture of LeNet-5.  \nAnswer: \nYann LeCun, Leon Bottou,  Yosuha Bengio and Patrick Haffner proposed the  neural network \narchitecture for the handwritten and machine-printed character recognition in the 1990\u2019s which they \ncalled them LeNet-5. The architecture is straightforward and too simple to understand that\u2019s why it \nis mostly used as a first step for teaching (CNN)Convolutional Neural Network.", "mimetype": "text/plain", "start_char_idx": 49844, "end_char_idx": 54046, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ff0550ba-a042-4733-a9bc-58c67f3ee653": {"__data__": {"id_": "ff0550ba-a042-4733-a9bc-58c67f3ee653", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "547a846e-32a9-49f1-b232-d23b43ec936d", "node_type": "1", "metadata": {}, "hash": "427208e003f93c35e11ae9a319f194c17df567fe801dc1f06681412bdf435e2e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7208c8a8-83ca-44e0-a1fa-e344602ee6ad", "node_type": "1", "metadata": {}, "hash": "6da23f79f8afe683021c58f381efab171425ce0599b97b4f54677d82b924a5a3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "ArchitectureP a g e  13 | 16 \n \nThis architecture consists of two sets of convolutional and average pooling layers, fo llowed by the \nflattening convolutional layer, then 2 fully-connected layers and finally the softmax classifier. \nIn the First Layer: \nThe input for LeNet-5 is the 32\u00d732 grayscale image which passes through  first convolutional layer \nwith 6 feature maps or filters having size 5\u00d75 and the stride of one. Image dimensions changes from \n32x32x1 to 28x28x6. \n \nIn Second Layer: \nThen it applies average pooling layer or sub-sampling layer with the filter size 2\u00d72 and  stride of two. \nThe resulting image dimension will be reduced to 14x14x6. \n \nThird Layer: \nNext, there is the second convolutional layer with 16 feature maps having size 5\u00d75 and the stride of \n1. In this layer, only ten out of sixteen feature maps are connected to 6 feature maps of  previous layer \nas shown below.P a g e  14 | 16 \n \n \nThe main reason is to break  symmetry in the network and keeps a  number of connections  within \nreasonable bounds. That is why the number of training parameters in this layers are 1516 in stead of \n2400 and similarly, number of connections are 151600 instead of 240000. \n \nFourth Layer: \nIn the fourth layer (S4) is an average pooling layer with  filter size 2\u00d72 and stride of 2. This layer is \nsame as second layer (S2) except it has 16 feature maps so output will be reduced to 5x5x16.P a g e  15 | 16 \n \n \nFifth Layer: \nThe fifth layer (C5) is the fully connected convolutional layer with 120 feature maps each of the size \n1\u00d71. Each of 120 units in C5 is connected to all the 400 nodes (5x5x16) in the fourth layer S4. \n \nSixth Layer: \nThe sixth layer is also fully connected layer (F6) with 84 units.P a g e  16 | 16 \n \n \nOutput Layer: \nFinally, there is fully connected softmax output layer \u0177 with 10 possi ble values corresponding to \ndigits from 0 to 9.P a g e  1 | 22 \n \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n \n \n#DAY 02P a g e  2 | 22 \n \nQ1. What is Logistic Regression? \n \nAnswer: \nThe logistic regression technique involves the dependent variable, which can be represented in the \nbinary (0 or 1, true or false, yes or no) values, which means that the outcome could only be in either \none form of two. For example, it can be utilized when we need to find the probability of a \nsuccessful or fail event. \n \n \nLogistic Regression is used when the dependent variable (target) is categorical. \n \n \nModel \nOutput = 0 or 1 \nZ = WX + B \nh\u0398(x) = sigmoid (Z) \nh\u0398(x) = log(P(X) / 1 - P(X) ) = WX +B \n \n  \nIf \u2018Z\u2019 goes to infinity, Y(predicted) will become 1, and if \u2018Z\u2019 goes to negative infinity, Y(predicted) \nwill become 0. \nThe output from the hypothesis is the estimated probability. This is used to infer how confident can \npredicted value be actual value when given an input X.P a g e  3 | 22 \n \nCost Function \n \nCost ( h\u0398(x) , Y(Actual)) =   -log (h\u0398(x)) if y=1 \n                                             -log (1 - h\u0398(x)) if y=0 \n \nThis implementation is for binary logistic regression. For data with more than 2 classes, softmax re\ngression has to be used. \n \n \n \nQ2. Difference between logistic and linear regression? \n \nAnswer: \nLinear and Logistic regression are the most basic form of regression which are commonly used. The \nessential difference between these two is that Logistic regression is used when the dependent variable \nis binary. In contrast, Linear regression is used when the dependent variable is continuous , and the \nnature of the regression line is linear. \n \nKey Differences between Linear and Logistic Regression \n \nLinear regression models data using continuous numeric value. As against, logistic regression models \nthe data in the binary values. \nLinear regression requires to establish the line ar relationship among dependent and independent \nvariables, whereas it is not necessary for logistic regression. \nIn linear regression, the independent variable can be correlated with each other.", "mimetype": "text/plain", "start_char_idx": 54048, "end_char_idx": 58047, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7208c8a8-83ca-44e0-a1fa-e344602ee6ad": {"__data__": {"id_": "7208c8a8-83ca-44e0-a1fa-e344602ee6ad", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ff0550ba-a042-4733-a9bc-58c67f3ee653", "node_type": "1", "metadata": {}, "hash": "c8f1753224fee049b6ad43171f88f25312e4f9eef6b274724e9bf86409a4861a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a204aba6-d397-475b-bcb9-cb577a450202", "node_type": "1", "metadata": {}, "hash": "9d905112c13248618e9cc0ac40820fa5274643994b2be1f572b1d2a3ff0c3b88", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In linear regression, the independent variable can be correlated with each other. On the contrary, in \nthe logistic regression, the variable must not be correlated with each other. \n \n \n \n \nQ3. Why we can\u2019t do a classification problem using Regression? \n \nAnswer:- \nWith linear regression you fit a polynomial through the data - say, like on the example below, we fit \na straight line through {tumor size, tumor type} sample set:P a g e  4 | 22 \n \n \n \nAbove, malignant tumors get 1 , and non-malignant ones get 0, and the green line is our hypothesis \nh(x). To make predictions, we may say that for any given tumor size x, if h(x) gets bigger than 0.5 , \nwe predict malignant tumors. Otherwise, we predict benignly. \nIt looks like this way, we could correctly predict every single training set sample, but now let's change \nthe task a bit. \n \nIntuitively it's clear that all tumors larger certain threshold are malignant. So let's add another sample \nwith huge tumor size, and run linear regression again: \n \n \n \nNow our h(x)>0.5\u2192malignant doesn't work anymore. To keep making correct predictions, we need \nto change it to h(x)>0.2 or something - but that not how the algorithm should work. \n \nWe cannot change the hypothesis each time a new sample arrives. Instead, we should learn it off the \ntraining set data, and then (using the hypothesis we've learned) make correct predictions for the data \nwe haven't seen before. \nLinear regression is unbounded. \n \nQ4. What is Decision Tree? \n \nA decision tree is a type of supervised learning algorithm that can be used in classification as well as \nregressor problems. The input to a decision tree can be both continuous as well as categorical. The \ndecision tree works on a n if-then statement. Decision tree tries to solve a problem by using tree \nrepresentation (Node and Leaf) \nAssumptions while creating a decision tree: 1) Initially all the training set is considered as a root 2) \nFeature values are preferred to be categorical, if continuous then they are discretized 3) Records areP a g e  5 | 22 \n \ndistributed recursively on the basis of attribute values 4) Which attributes are considered to be in root \nnode or internal node is done by using a statistical approach. \n \n \n \n \n \nQ5. Entropy, Information Gain, Gini Index, Reducing Impurity? \n \nAnswer: \nThere are different attributes which define the split of nodes in a decision tree. There are few \nalgorithms to find the optimal split. \n  \n1) ID3(Iterative Dichotomiser 3):  This solution uses Entropy and Information gain as metrics \nto form a better decision tree. The attribute with the highest information gain is used as a root \nnode, and a similar approach is followed after that. Entropy is the measure that characterizes \nthe impurity of an arbitrary collection of examples. \n \n \n \n \nEntropy varies from 0 to 1. 0 if all the data belong to a single class and 1 if the class distribution is \nequal. In this way, entropy will give a measure of impurity in the dataset. \nSteps to decide which attribute to split:P a g e  6 | 22 \n \n1. Compute the entropy for the dataset \n2. For every attribute: \n \n2.1 Calculate entropy for all categorical values. \n \n2.2 Take average information entropy for the attribute. \n \n2.3 Calculate gain for the current attribute. \n3. Pick the attribute with the highest information gain. \n4. Repeat until we get the desired tree. \n \nA leaf node is decided when entropy is zero \nInformation Gain = 1 - \u2211 (Sb/S)*Entropy (Sb) \nSb - Subset, S - entire data \n \n2) CART Algorithm (Classification and Regression trees): In CART, we use the GINI index as \na metric. Gini index is used as a cost function to evaluate split in a dataset \nSteps to calculate Gini for a split: \n1. Calculate Gini for subnodes, using formula sum of the square of probability for success \nand failure (p2+q2). \n2. Calculate Gini for split using weighted Gini score of each node of that split.", "mimetype": "text/plain", "start_char_idx": 57966, "end_char_idx": 61868, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a204aba6-d397-475b-bcb9-cb577a450202": {"__data__": {"id_": "a204aba6-d397-475b-bcb9-cb577a450202", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7208c8a8-83ca-44e0-a1fa-e344602ee6ad", "node_type": "1", "metadata": {}, "hash": "6da23f79f8afe683021c58f381efab171425ce0599b97b4f54677d82b924a5a3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b3843e16-8251-4032-b8c1-0ed0f9209e73", "node_type": "1", "metadata": {}, "hash": "990dd372bfe89385399339a700f187771309fa0d468e5d7e1f7a6d1a31e13fd3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Calculate Gini for split using weighted Gini score of each node of that split. \n \n \n \n \nChoose the split based on higher Gini value \n \n \n \nSplit on Gender: \nGini for sub-node Female = (0.2)*(0.2)+(0.8)*(0.8)=0.68 \n     Gini for sub-node Male = (0.65)*(0.65)+(0.35)*(0.35)=0.55P a g e  7 | 22 \n \n     Weighted Gini for Split Gender = (10/30)*0.68+(20/30)*0.55 = 0.59 \n \n \nSimilar for Split on Class: \nGini for sub-node Class IX = (0.43)*(0.43)+(0.57)*(0.57)=0.51 \n     Gini for sub-node Class X = (0.56)*(0.56)+(0.44)*(0.44)=0.51 \n     Weighted Gini for Split Class = (14/30)*0.51+(16/30)*0.51 = 0.51 \n     \n    Here Weighted Gini is high for gender, so we consider splitting based on gender \n \nQ6. How to control leaf height and Pruning? \n \nAnswer: \nTo control the leaf size, we can set the parameters:- \n \n1. Maximum depth : \nMaximum tree depth is a limit to stop the further splitting of nodes when the specified tree depth has \nbeen reached during the building of the initial decision tree. \nNEVER use maximum depth to limit the further splitting of nodes. In other words: use the \nlargest possible value. \n \n \n2. Minimum split size: \nMinimum split size is a limit to stop the further splitting of nodes when the number of observations \nin the node is lower than the minimum split size. \nThis is a good way to limit the growth of the tree. When a leaf contains too few observations, further \nsplitting will result in overfitting (modeling of noise in the data). \n \n3. Minimum leaf size \nMinimum leaf size is a limit to split a node when the number of observations in one of the child nodes \nis lower than the minimum leaf size. \nPruning is mostly done to reduce the chances of overfitting the tree to the training data and reduce \nthe overall complexity of the tree. \n \nThere are two types of pruning: Pre-pruning and Post-pruning. \n \n1. Pre-pruning is also known as the early stopping criteria. As the name suggests, the criteria \nare set as parameter values while building the model. The tree stops growing when it meets \nany of these pre-pruning criteria, or it discovers the pure classes.P a g e  8 | 22 \n \n2. In Post-pruning, the idea is to allow the decision tree to grow fully and observe the CP value. \nNext, we prune/cut the tree with the optimal  CP(Complexity Parameter) value as the \nparameter. \n \nThe CP (complexity parameter) is u sed to control tree growth. If the cost of adding a variable is \nhigher, then the value of CP, tree growth stops. \n \n \n \n \n \n \n \nQ7. How to handle a decision tree for numerical and categorical \ndata? \nAnswer: \nDecision trees can handle both categorical and numerical variables at the same time as features. There \nis not any problem in doing that. \nEvery split in a decision tree is based on a feature. \n \n1. If the feature is categorical, the split is done with the elements belonging to a particular \nclass. \n2. If the feature is continuous, the split is done with the elements higher than a threshold. \n \nAt every split, the decision tree will take the best variable at that moment. This will be done according \nto an impurity measure with the split  branches. And the fact that the variable used t o do split is \ncategorical or continuous is irrelevant (in fact, decision trees categorize contin uous variables by \ncreating binary regions with the threshold). \nAt last, the good approach is to always convert your categoricals to contin uous \nusing  LabelEncoder or OneHotEncoding.P a g e  9 | 22 \n \n \n \nQ8. What is the Random Forest Algorithm? \n \nAnswer: \nRandom Forest is an ensemble machine learning algorithm that follows the bagging technique. The \nbase estimators in the random forest are decision trees. Random forest randomly selects a set of \nfeatures that are used to decide the best split at each node of the decision tree. \nLooking at it step-by-step, this is what a random forest model does: \n1. Random subsets are created from the original dataset (bootstrapping). \n2.", "mimetype": "text/plain", "start_char_idx": 61790, "end_char_idx": 65724, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b3843e16-8251-4032-b8c1-0ed0f9209e73": {"__data__": {"id_": "b3843e16-8251-4032-b8c1-0ed0f9209e73", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a204aba6-d397-475b-bcb9-cb577a450202", "node_type": "1", "metadata": {}, "hash": "9d905112c13248618e9cc0ac40820fa5274643994b2be1f572b1d2a3ff0c3b88", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "86ff8e56-9330-43f8-8440-f649b9cd0bdb", "node_type": "1", "metadata": {}, "hash": "e3d754548d11ba4d62eb2c6d3ab8b191269addceb3bec814b62ba22fdda00a5d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Random subsets are created from the original dataset (bootstrapping). \n2. At each node in the decision tree, only a random set of features are considered to decide the \nbest split. \n3. A decision tree model is fitted on each of the subsets. \n4. The final prediction is calculated by averaging the predictions from all decision trees. \nTo sum up, the Random forest randomly selects data points and f eatures and builds multiple trees \n(Forest). \nRandom Forest is used for feature importance selection. The attribute  (.feature_importances_) is \nused to find feature importance. \n \n \n \n \n \nSome Important Parameters:- \n1. n_estimators:- It defines the number of decision trees to be created in a random forest. \n2.  criterion:- \"Gini\" or \"Entropy.\" \n3. min_samples_split:- Used to define the minimum number of samples required in a leaf \nnode before a split is attempted \n4. max_features: -It defines the maximum number of features allowed for the split in each \ndecision tree. \n5. n_jobs:- The number of jobs to run in parallel for both fit and predict. Always keep (-1) to \nuse all the cores for parallel processing. \n \n \nQ9. What is Variance and Bias tradeoff? \n \nAnswer: \nIn predicting models, the prediction error is composed of two different errors \n1. Bias \n2. VarianceP a g e  10 | 22 \n \n \nIt is important to understand the variance and bias trade -off which tells about to minimize the Bias \nand Variance in the prediction and avoids overfitting & under fitting of the model. \n \nBias: It is the difference between the  expected or average prediction of the model and the correct \nvalue which we are trying to predict. Imagine  if we are trying to build more than one model by \ncollecting different data sets , and later on , evaluating the prediction , we may end up by different \nprediction for all the models. So, bias is something which measures how far these model prediction \nfrom the correct prediction. It always leads to a high error in training and test data. \n \nVariance: Variability of a model prediction for a given data point. We can build the model multiple \ntimes, so the variance is how much the predictions for a given point vary between different \nrealizations of the model. \n \n \nFor example: Voting Republican - 13 Voting Democratic - 16 Non-Respondent - 21 Total - 50 \nThe probability of voting Republican is 13/(13+16), or 44.8%. We put out our press release that the \nDemocrats are going to win by over 10 points; but, when the election comes around, it turns out they \nlose by 10 points. That certainly reflects poorly on us. Where did we go wrong in our model? \nBias scenario's: using a phonebook to select participants in our survey is one of our sources of bias. \nBy only surveying certain classes of people, it skews the results in a way that will be consistent if we \nrepeated the entire model building exercise. Similarly, not following up with respondents is another \nsource of bias, as it consistently changes the mixture of responses we get. On our bulls-eye diagram, \nthese move us away from the center of the target, but they would not result in an increased scatter of \nestimates. \nVariance scenarios: the small sample size is a source of variance. If we increased our sample size, \nthe results would be more consistent each time we repeated the survey and prediction. The results \nstill might be highly inaccurate due to our large sources of bias, but the variance of predictions will \nbe reducedP a g e  11 | 22 \n \n \n \n \n \nQ10. What are Ensemble Methods? \n \nAnswer \n1. Bagging and Boosting \nDecision trees have been around for a long time and also known to suffer from bias and variance. \nYou will have a large bias with simple trees and a large variance with complex trees. \n \nEnsemble methods  - which combines several decision trees to produce better predictive \nperformance than utilizing a single decision tree. The main principle behind the ensemble model is \nthat a group of weak learners come together to form a strong learner. \n \nTwo techniques to perform ensemble decision trees: \n1. Bagging \n2. Boosting \n \nBagging (Bootstrap Aggregation) is used when our goal is to reduce the variance of a decision tree. \nHere the idea is to create sev eral subsets of data from the training sample chosen randomly with \nreplacement. Now, each collection of subset data is used to train their decision trees. As a result, we \nend up with an ensemble of different models.", "mimetype": "text/plain", "start_char_idx": 65651, "end_char_idx": 70062, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "86ff8e56-9330-43f8-8440-f649b9cd0bdb": {"__data__": {"id_": "86ff8e56-9330-43f8-8440-f649b9cd0bdb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b3843e16-8251-4032-b8c1-0ed0f9209e73", "node_type": "1", "metadata": {}, "hash": "990dd372bfe89385399339a700f187771309fa0d468e5d7e1f7a6d1a31e13fd3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bf070696-46bc-4850-af0b-206ec2fcc097", "node_type": "1", "metadata": {}, "hash": "5eb639bde7e697645524d070cd65a17ea474d1c8954aa308e8f7cef7773daae6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "As a result, we \nend up with an ensemble of different models. Average of all the predictions from differen t trees are \nused which is more robust than a single decision tree. \n \nBoosting is another ensemble technique to create a collection of predictors. In this technique, learners \nare learned sequentially with early learners fitting simple models to the data and then analyzing dataP a g e  12 | 22 \n \nfor errors. In other words, we fit consecutive trees (random sample), and at every step, the goal is to \nsolve for net error from the prior tree. \nWhen a hypothesis misclassifies an input, its weight is increased, so that the next hypothesis is more \nlikely to classify it correctly. By combining the whole set at the end converts weak learners into a \nbetter performing model. \n \nThe different types of boosting algorithms are: \n1. AdaBoost \n2. Gradient Boosting \n3. XGBoost \n \n \nQ11. What is SVM Classification? \n \nAnswer: \nSVM or Large margin classifier is a supervised learning algorithm that uses a powerful technique \ncalled SVM for classification. \nWe have two types of SVM classifiers:  \n1) Linear SVM: In Linear SVM, the data points are expected to be separated by some apparent \ngap. Therefore, the SVM algorithm predicts a straight hyperplane dividing the two classes. The \nhyperplane is also called as maximum margin hyperplaneP a g e  13 | 22 \n \n \n \n2) Non-Linear SVM: It is possible that our data points are not linearly separable in a p-\ndimensional space, but can be linearly separable in a higher dimension. Kernel tricks make it \npossible to draw nonlinear hyperplanes. Some standard kernels are a) Polynomial Kernel b) RBF \nkernel(mostly used). \n \n \nAdvantages of SVM classifier:    \n1) SVMs are effective when the number of features is quite large.  \n2) It works effectively even if the number of features is greater than the number of samples.  \n3) Non-Linear data can also be classified using customized hyperplanes built by using kernel trick.  \n4) It is a robust model to solve prediction problems since it maximizes margin. \n \nDisadvantages of SVM classifier:  \n1) The biggest limitation of the Support Vector Machine is the choice of the kernel. The wrong choice \nof the kernel can lead to an increase in error percentage.  \n2) With a greater number of samples, it starts giving poor performances.  \n3) SVMs have good generalization performance, but they can be extremely slow in the test phase.  \n4) SVMs have high algorithmic complexity and extensive memory requirements due to the use of \nquadratic programming. \n \nQ11. What is Naive Bayes Classification and Gaussian Naive BayesP a g e  14 | 22 \n \n \nAnswer: \nBayes\u2019 Theorem finds the probability of an event occurring given the probability of another event \nthat has already occurred. Bayes\u2019 theorem is stated mathematically as the following equation: \n \n  \nNow, with regards to our dataset, we can apply Bayes\u2019 theorem in following way: \nP(y|X) = {P(X|y) P(y)}/{P(X)} \nwhere, y is class variable and X is a dependent feature vector (of size n) where: \nX = (x_1,x_2,x_3,.....,x_n) \n  \n \nTo clear, an example of a feature vector and corresponding class variable can be: (refer 1st row of \nthe dataset)P a g e  15 | 22 \n \nX = (Rainy, Hot, High, False) y = No So basically, P(X|y) here means, the probability of \u201cNot \nplaying golf\u201d given that the weather conditions are \u201cRainy outlook\u201d, \u201cTemperature is hot\u201d, \u201chigh \nhumidity\u201d and \u201cno wind\u201d. \n \nNaive Bayes Classification: \n1. We assume that no pair of features are dependent. For example, the temperature being \u2018Hot\u2019 \nhas nothing to do with the humidity, or the outlook being \u2018Rainy\u2019 does not affect the winds. \nHence, the features are assumed to be independent. \n2. Secondly, each feature is given the same weight (or importance). For example, knowing the \nonly temperature and humidity alone can\u2019t predict the outcome accurate ly. None of the \nattributes is irrelevant and assumed to be contributing equally to the outcome \nGaussian Naive Bayes \nContinuous values associated with each feature are assumed to be distributed according to a \nGaussian distribution. A Gaussian distribution is also called Normal distribution.", "mimetype": "text/plain", "start_char_idx": 70001, "end_char_idx": 74157, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bf070696-46bc-4850-af0b-206ec2fcc097": {"__data__": {"id_": "bf070696-46bc-4850-af0b-206ec2fcc097", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "86ff8e56-9330-43f8-8440-f649b9cd0bdb", "node_type": "1", "metadata": {}, "hash": "e3d754548d11ba4d62eb2c6d3ab8b191269addceb3bec814b62ba22fdda00a5d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "34031934-93cc-4830-b3e3-ab9c1aec029c", "node_type": "1", "metadata": {}, "hash": "d10908b695714522af7988a39533aa3d24710e15bef6c14d2258526c17844aff", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A Gaussian distribution is also called Normal distribution. When plotted, it \ngives a bell-shaped curve which is symmetric about the mean of the feature values as shown below: \n \nThis is as simple as calculating the mean and standard deviation values of each input variable (x) for \neach class value. \nMean (x) = 1/n * sum(x) \nWhere n is the number of instances, and x is the values for an input variable in your training data. \nWe can calculate the standard deviation using the following equation: \nStandard deviation(x) = sqrt (1/n * sum(xi-mean(x)^2 )) \nWhen to use what? Standard Naive Bayes only supports categorical features, while Gaussian Naive \nBayes only supports continuously valued features. \n \n \nQ12. What is the Confusion Matrix? \n \nAnswer: \nA confusion matrix is a table that is often used to describe the performance of a classification model \n(or \u201cclassifier\u201d) on a set of test data for which the true values are known. It allows the visualization \nof the performance of an algorithm.P a g e  16 | 22 \n \nA confusion matrix is a  summary of prediction results  on a classification problem. The number of \ncorrect and incorrect predictions are summarized with count values and broken down by each class.  \n \nThis is the key to the confusion matrix. \nIt gives us insight not only into the errors being made by a classifier but, more importantly, the types \nof errors that are being made. \n \nHere, \n\uf0b7 Class 1: Positive \n\uf0b7 Class 2: Negative \nDefinition of the Terms: \n1. Positive (P): Observation is positive (for example: is an apple). \n2. Negative (N): Observation is not positive (for example: is not an apple). \n3. True Positive (TP): Observation is positive, and is predicted to be positive. \n4. False Negative (FN): Observation is positive, but is predicted negative. \n5. True Negative (TN): Observation is negative, and is predicted to be negative. \n6. False Positive (FP): Observation is negative, but is predicted positive. \n \n \n \nQ13. What is Accuracy and Misclassification Rate? \n \nAnswer: \n \nAccuracy \nAccuracy is defined as the ratio of the sum of True Positive and True \nNegative by Total(TP+TN+FP+FN)P a g e  17 | 22 \n \nHowever, there are problems with accuracy. It assumes equal costs for both kinds of \nerrors. A 99% accuracy can be excellent, good, mediocre, poor, or terrible depending upon \nthe problem. \n \n \n \n \nMisclassification Rate \n \nMisclassification Rate is defined as the ratio of the sum of False Positive and False \nNegative by Total(TP+TN+FP+FN) \nMisclassification Rate is also called Error Rate. \n \n \n \n \n \n \nQ14. True Positive Rate & True Negative Rate \n \nAnswer: \n \nTrue Positive Rate: \nSensitivity (SN) is calculated as the number of correct positive predictions divided by the \ntotal number of positives. It is also called Recall (REC) or true positive rate (TPR). The best \nsensitivity is 1.0, whereas the worst is 0.0.P a g e  18 | 22 \n \n \n \n \nTrue Negative Rate \n \nSpecificity (SP) is calculated as the number of correct negative predictions divided by the \ntotal number of negatives. It is also called a true negative rate (TNR). The best specificity is \n1.0, whereas the worst is 0.0. \n \n \nQ15. What is False Positive Rate & False negative Rate? \nFalse Positive Rate \nFalse positive rate (FPR) is calculated as the number of incorrect positive predictions divided by the \ntotal number of negatives. The best false positive rate is 0.0, whereas the worst is 1.0. It can also be \ncalculated as 1 \u2013 specificity. \n \nFalse Negative Rate \nFalse Negative rate (FPR) is calculated as the number of incorrect positive predictions divided by \nthe total number of positives. The best false negative rate is 0.0, whereas the worst is 1.0.P a g e  19 | 22 \n \nQ16. What are F1 Score, precision and recall? \n \nRecall:- \nRecall can be defined as the ratio of the total number of correctly classified positive examples \ndivide to the total number of positive examples. \n1. High Recall indicates the class is correctly recognized (small number of FN). \n2. Low Recall indicates the class is incorrectly recognized (large number of FN). \n \nRecall is given by the relation: \n \n \n \nPrecision: \nTo get the value of precision, we divide the total number of correctly classified positive examples \nby the total number of predicted positive examples.", "mimetype": "text/plain", "start_char_idx": 74098, "end_char_idx": 78375, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "34031934-93cc-4830-b3e3-ab9c1aec029c": {"__data__": {"id_": "34031934-93cc-4830-b3e3-ab9c1aec029c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bf070696-46bc-4850-af0b-206ec2fcc097", "node_type": "1", "metadata": {}, "hash": "5eb639bde7e697645524d070cd65a17ea474d1c8954aa308e8f7cef7773daae6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cf1825e8-4831-47fc-9ca6-c9dfb2b81855", "node_type": "1", "metadata": {}, "hash": "cf565da9d54ea723267dd277218b4e6efdb9b764a5ee4b2db7c1d809d0e1ffb6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1. High Precision indicates an example labeled as positive is indeed positive (a small number \nof FP). \n2. Low Precision indicates an example labeled as positive is indeed positive (large number of \nFP). \n \nThe relation gives precision: \n \n \n \nRemember:- \nHigh recall, low precision: This means that most of the positive examples are correctly recognized \n(low FN), but there are a lot of false positives. \nLow recall, high precision: This shows that we miss a lot of positive examples (high FN), but those \nwe predict as positive are indeed positive (low FP). \n \n \n \n \nF-measure/F1-Score:P a g e  20 | 22 \n \nSince we have two measures (Precision and Recall) , it helps to have a measurement that represents \nboth of them. We cal culate an F-measure, which uses Harmonic Mean in place of Arithmetic \nMean as it punishes the extreme values more. \n \n \nThe F-Measure will always be nearer to the smaller value of Precision or Recall. \n \n \n \n \nQ17. What is RandomizedSearchCV? \n \nAnswer: \nRandomized search CV is used to perform a random search on hyperparameters. Randomized \nsearch CV uses a fit and score method, predict proba, decision_func, transform, etc.., \nThe parameters of the estimator used to apply these methods are optimized by cross-validated \nsearch over parameter settings. \n \nIn contrast to GridSearchCV, not all parameter values are tried out, but rather a fixed number of \nparameter settings is sampled from the specified distributions. The number of parameter settings that \nare tried is given by n_iter. \n \nCode Example :  \n \nclass sklearn.model_selection.RandomizedSearchCV(estimator, param_distributions, \nn_iter=10, scoring=None, fit_params=None, n_jobs=None, iid=\u2019warn\u2019, refit=True, \ncv=\u2019warn\u2019, verbose=0, pre_dispatch=\u20182n_jobs\u2019, random_state=None, error_score=\u2019raise-\ndeprecating\u2019, return_train_score=\u2019warn\u2019) \n \n \n \n \n \nQ18. What is GridSearchCV? \n \nAnswer:P a g e  21 | 22 \n \nGrid search is the process of performing hyperparameter tuning to determine the optimal values for \na given model. \nCODE Example:- \n \nfrom sklearn.model_selection import GridSearchCV from sklearn.svm import SVR gsc = \nGridSearchCV( estimator=SVR(kernel='rbf'), param_grid={ 'C': [0.1, 1, 100, 1000], 'epsilon': \n[0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10], 'gamma': [0.0001, 0.001, 0.005, 0.1, 1, \n3, 5] }, cv=5, scoring='neg_mean_squared_error', verbose=0, n_jobs=-1) \n \nGrid search runs the model on all the possible range of hyperparameter values and outputs the best \nmodel \n \n \nQ19. What is BaysianSearchCV? \n \nAnswer: \nBayesian search, in contrast to the grid and random search, keep s track of past evaluation results , \nwhich they use to form a probabilistic model mapping hyperparameters to a probability of a score on \nthe objective function. \n \n \n \n \n \nCode: \nfrom skopt import BayesSearchCV \nopt = BayesSearchCV( \n    SVC(),P a g e  22 | 22 \n \n    { \n        'C': (1e-6, 1e+6, 'log-uniform'),   \n        'gamma': (1e-6, 1e+1, 'log-uniform'), \n        'degree': (1, 8),  # integer valued parameter \n        'kernel': ['linear', 'poly', 'rbf'] \n    }, \n    n_iter=32, \n    cv=3) \n \n \n \nQ20. What is ZCA Whitening? \n \nAnswer: \nZero Component Analysis: \nMaking the co-variance matrix as the Identity matrix is called whitening. T his will remove the first \nand second-order statistical structure \nZCA transforms the data to zero means and makes the features linearly independent of each other \nIn some image analysis applications, especially when working with images of the color and tiny typ\ne, it is frequently interesting to apply some whitening to the data before, e.g. training a classifier.DATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 04Q1. What is upsampling and downsampling with examples?", "mimetype": "text/plain", "start_char_idx": 78377, "end_char_idx": 82138, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cf1825e8-4831-47fc-9ca6-c9dfb2b81855": {"__data__": {"id_": "cf1825e8-4831-47fc-9ca6-c9dfb2b81855", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34031934-93cc-4830-b3e3-ab9c1aec029c", "node_type": "1", "metadata": {}, "hash": "d10908b695714522af7988a39533aa3d24710e15bef6c14d2258526c17844aff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6943e2a-102e-4f56-848a-1c3b2ff88f9a", "node_type": "1", "metadata": {}, "hash": "f1b76203c0db3a883930bda9a8f9e1bc61d1507af96a95019e933bd084cddf87", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "What is upsampling and downsampling with examples? \nThe classification data set with skewed class proportions is called an \nimbalanced data set. Classes which make up a large proportion of the data \nsets are called majority classes. Those make up smaller proportions are \nminority classes. \nDegree of imbalance Proportion of Minority Class \n1>> Mild 20-40% of the data set \n2>> Moderate 1-20% of the data set \n3>> Extreme <1% of the data set \nIf we have an imbalanced data set, first try training on the true distribution. \nIf the model works well and generalises, you are done! If not, try the \nfollowing up sampling and down sampling technique. \n1. Up-sampling \nUpsampling is the process of randomly duplicating observations from the \nminority class to reinforce its signal. \nFirst, we will import the resampling module from Scikit-Learn: \nModule for resampling Python \n1- From sklearn.utils import resample \nNext, we will create a new Data Frame with an up-sampled minority class. \nHere are the steps: \n1- First, we will separate observations from each class into different Data \nFrames. \n2- Next, we will resample the minority class with replacement, setting the \nnumber of samples to match that of the majority class.  \n3- Finally, we'll combine the up-sampled minority class Data Frame with the \noriginal majority class Data Frame. \n2-Down-sampling \nDownsampling involves randomly removing observations from the majority \nclass to prevent its signal from dominating the learning algorithm.  \nThe process is similar to that of sampling. Here are the steps: \n1-First, we will separate observations from each class into different Data \nFrames.2-Next, we will resample the majority class without replacement, setting the \nnumber of samples to match that of the minority class.  \n3-Finally, we will combine the down-sampled majority class Data Frame \nwith the original minority class Data Frame. \nQ2. What is the statistical test for data validation with an example,  \n        Chi-square, ANOVA test, Z statics, T statics, F statics,  \n Hypothesis Testing? \nBefore discussing the different statistical test, we need to get a clear \nunderstanding of what a null hypothesis is. A null hypothesis proposes that \nhas no significant difference exists in the set of a given observation . \nNull:  Two samples mean are equal. Alternate: Two samples mean are not \nequal. \nFor rejecting the null hypothesis, a test is calculated. Then the test statistic \nis compared with a critical value, and if found to be greater than the critical \nvalue, the hypothesis will be rejected. \nCritical Value:- \nCritical values are the point beyond which we reject the null hypothesis. \nCritical value tells us, what is the probability of N number of samples, \nbelonging to the same distribution. Higher, the critical value which means \nlower the probability of N number of samples belonging to the same \ndistribution. \nCritical values can be used to do hypothesis testing in the following way. \n1. Calculate test statistic \n2. Calculate critical values based on the significance level alpha \n3. Compare test statistics with critical values. \nIMP-If the test statistic is lower than the critical value, accept the hypothesis \nor else reject the hypothesis. \nChi-Square Test:- \nA chi-square test is used if there is a relationship between two categorical \nvariables.Chi-Square test is used to determine whether there is a significant \ndifference between the expected frequency and the observed frequency in \none or more categories. Chi-square is also called the non-parametric test \nas it will not use any parameter \n \n \n \n2-Anova test:- \nANOVA, also called an analysis of variance, is used to compare multiples \n(three or more) samples with a single test. \nUseful when there are more than three populations. Anova compares the \nvariance within and between the groups of the population . If the variation is \nmuch larger than the within variation, the means of different samples will \nnot be equal. If the between and within variations are approximately the \nsame size, then there will be no significant difference between sample \nmeans. Assumptions of ANOVA: 1-All populations involved follow a normal \ndistribution. 2-All populations have the same variance (or standard \ndeviation). 3-The samples are randomly selected and independent of one \nanother. \nANOVA uses the mean of the samples or the population to reject or \nsupport the null hypothesis. Hence it is called parametric testing.  \n3-Z Statics:- \nIn a z-test, the samples are assumed to be normal distributed.", "mimetype": "text/plain", "start_char_idx": 82088, "end_char_idx": 86630, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d6943e2a-102e-4f56-848a-1c3b2ff88f9a": {"__data__": {"id_": "d6943e2a-102e-4f56-848a-1c3b2ff88f9a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf1825e8-4831-47fc-9ca6-c9dfb2b81855", "node_type": "1", "metadata": {}, "hash": "cf565da9d54ea723267dd277218b4e6efdb9b764a5ee4b2db7c1d809d0e1ffb6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "33447fc7-8cb5-4459-aa82-11f6680ea241", "node_type": "1", "metadata": {}, "hash": "9e4757247c1f0e4c1f873d2a34a024c2c3eddb0ba0e14cda2267b925533a1803", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A z score is \ncalculated with population parameters as \u201cpopulation mean\u201d and \n\u201cpopulation standard deviation\u201d and it is used to validate a hypothesis that \nthe sample drawn belongs to the same population. \nThe statistics used for this hypothesis testing is called z-statistic, the score \nfor which is calculated as z = (x \u2014 \u03bc) / (\u03c3 / \u221an), where x= sample mean \u03bc = \npopulation mean \u03c3 / \u221an = population standard deviation If the test statistic is \nlower than the critical value, accept the hypothesis or else reject the \nhypothesis \n4- T Statics:- \nA t-test used to compare the mean of the given samples. Like  z-test,  t-test \nalso assumed a normal distribution of the samples. A t-test is used when \nthe population parameters (mean and standard deviation) are unknown.There are three versions of t-test \n1. Independent samples t-test which compare means for two groups \n2. Paired sample t-test which compares mean from the same group at \ndifferent times \n3. Sample t-test, which tests the mean of the single group against the \nknown mean. The statistic for  hypothesis testing is called t-statistic, \nthe score for which is calculated as t = (x1 \u2014 x2) / (\u03c3 / \u221an1 + \u03c3 / \u221an2), \nwhere \n              x1 =  It is mean of sample A, x2 = mean of sample B,  \n              n1 = size of sample 1 n2 = size of    sample 2 \n \n \n \n5- F Statics:- \nThe F-test is designed to test if the two population variances are equal. It \ncompares the ratio of the two variances. Therefore, if the variances are \nequal, then the ratio of the variances will be 1. \nThe F-distribution is the ratio of two independent chi-square variables \ndivided by their respective degrees of freedom. \nF = s1^2 / s2^2 and where s1^2 > s2^2. \nIf the null hypothesis is true, then the F test-statistic given above can be \nsimplified. This ratio of sample variances will be tested statistic used. If the \nnull hypothesis is false, then we will reject the null hypothesis that the ratio \nwas equal to 1 and our assumption that they were equal. \n \nQ3. What is the Central limit theorem? \nCentral Limit Theorem \nDefinition: The theorem states that as the size of the sample increases, the \ndistribution of the mean across multiple samples will approximate a \nGaussian distribution (Normal). Generally, sample sizes equal to or greater \nthan 30 are consider sufficient for the CLT to hold. It means that the \ndistribution of the sample means is normally distributed. The average of thesample means will be equal to the population mean. This is the key aspect \nof the theorem. \nAssumptions: \n1. The data must follow the randomization condition. It must be sampled \nrandomly \n2. Samples should be independent of each other. One sample should \nnot influence the other samples \n3. Sample size should be no more than 10% of the population when \nsampling is done without replacement \n4. The sample size should be sufficiently large. The mean of the sample \nmeans is denoted as: \n\u00b5 X\u0304 = \u00b5 \nWhere, \n\u00b5 X\u0304 = Mean of the sample means \u00b5= Population mean and, the standard \ndeviation of the sample mean is denoted as: \n\u03c3 X\u0304 = \u03c3/sqrt(n) \nWhere, \n\u03c3 X\u0304 = Standard deviation of the sample mean \u03c3 = Population standard \ndeviation n = sample size \nA sufficiently large sample size can predict the characteristics of a \npopulation accurately. For Example, we shall take a uniformly distributed \ndata: \nRandomly distributed data: Even for a randomly (Exponential) distributed \ndata the plot of the means is normally distributed. \nThe advantage of CLT is that we need not worry about the actual data \nsince the means of it will always be normally distributed. With this, we can \ncreate component intervals, perform T-tests and ANOVA tests from the \ngiven samples. \n \nQ4. What is the correlation and coefficient? \nWhat is the Correlation Coefficient? \nThe correlation coefficient is a statistical measure that calculates the \nstrength of the relationship between the relative movements of twovariables. We use it to measure both the strength and direction of a linear \nrelationship between two variables the values range between -1.0 and 1.0. \nA calculated number greater than 1.0 or less than -1.0 means that there \nwas an error in the correlation measurement.", "mimetype": "text/plain", "start_char_idx": 86631, "end_char_idx": 90821, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "33447fc7-8cb5-4459-aa82-11f6680ea241": {"__data__": {"id_": "33447fc7-8cb5-4459-aa82-11f6680ea241", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6943e2a-102e-4f56-848a-1c3b2ff88f9a", "node_type": "1", "metadata": {}, "hash": "f1b76203c0db3a883930bda9a8f9e1bc61d1507af96a95019e933bd084cddf87", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "88885557-bd8c-403d-984c-cf5894235e12", "node_type": "1", "metadata": {}, "hash": "cec1999fb8943a61e46f88e7c06bf14b1346899647356bccf56c8c09e26878c6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A correlation of -1.0 shows a \nperfect negative correlation, while a correlation of 1.0 shows a perfect \npositive correlation. \n \n \n \nCorrelation coefficient formulas are used to find how strong a relationship is \nbetween data. The formulas return a value between -1 and 1, where: \n1 indicates a strong positive relationship. -1 indicates a strong negative \nrelationship. A result of zero indicates no relationship at all.  \n \nMeaning \n1. A correlation coefficient of 1 means that for every positive increase in \none variable, there is a positive increase in a fixed proportion in the \nother. For example, shoe sizes go up in (almost) perfect correlation \nwith foot length. \n2. A correlation coefficient of -1 means that for every positive increase in \none variable, there is a negative decrease of a fixed proportion in the \nother. For example, the amount of gas in a tank decreases in  (almost) \nperfect correlation with speed. \n3. Zero means that for every increase, there isn\u2019t a positive or negative \nincrease. The two just aren\u2019t related.What is a Negative Correlation? \nNegative correlation is a relationship between two variables in which one \nvariable increases as the other decreases, and vice versa. In statistics, a \nperfect negative correlation is represented by the value -1. Negative \ncorrelation or inverse correlation is a relationship between two variables \nwhereby they move in opposite directions. If variables X and Y have a \nnegative correlation (or are negatively correlated), as X increases in value, \nY will decrease; similarly, if X decreases in value, Y will increase.  \nWhat Is Positive Correlation? \nPositive correlation is a relationship between two variables in which both \nvariables move in tandem\u2014that is, in the same direction. A positive \ncorrelation exists when one variable decreases as the other variable \ndecreases or one variable increases while the other increases.  \n \n \n \nWe use the correlation coefficient to measure the strength and direction of \nthe linear relationship between two numerical variables X and Y. The \ncorrelation coefficient for a sample of data is denoted by r.  \nPearson Correlation Coefficient \nPearson is the most widely used correlation coefficient. Pearson correlation \nmeasures the linear association between continuous variables. In other \nwords, this coefficient quantifies the degree to which a relationship between \ntwo variables can be described by a line. Formula developed by Karl \nPearson over 120 years ago is still the most widely used today. The \nformula for the correlation (r) isWhere n is the number of pairs of data; \nAre the sample means of all the x-values and all the y-values, respectively; \nand sx and sy are the sample standard deviations of all the x- and y-values, \nrespectively. \n1. Find the mean of all the x-values and mean of all y-values. \n2. Find the standard deviation of all the x-values (call it sx) and the \nstandard deviation of all the y-values (call it sy). For example, to find \nsx, you would use the following equation: \n3. For each of the n pairs (x, y) in the data set, take \n4. Add up the n results from Step 3. \n5. Divide the sum by sx \u2217 sy. \n6. Divide the result by n \u2013 1, where n is the number of (x, y) pairs. (It\u2019s \nthe same as multiplying by 1 over n \u2013 1.) This gives you the \ncorrelation, r. \n \nQ5: What is the difference between machine learning and deep  \n       learning? \nMachine Learning | deep learning \nMachine Learning is a technique to learn from that data and then apply wha\nt has been learnt to make an informed decision | The main difference betwe\nen deep and machine learning is, machine learning models become better \nprogressively but the model still needs some guidance. If a machine-\nlearning model returns an inaccurate prediction then the programmer need\ns to fix that problem explicitly but in the case of deep learning, the model do\nes it by himself.>Machine Learning can perform well with small size data also | Deep Learn\ning does not perform as good with smaller datasets. \n>Machine learning can work on some low-\nend machines also  | Deep Learning involves many matrix multiplication op\nerations which are better suited for GPUs \n>Features need to be identified and extracted as per the domain before pu\nshing them to the algorithm | Deep learning algorithms try to learn high-\nlevel features from data.", "mimetype": "text/plain", "start_char_idx": 90822, "end_char_idx": 95166, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "88885557-bd8c-403d-984c-cf5894235e12": {"__data__": {"id_": "88885557-bd8c-403d-984c-cf5894235e12", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "33447fc7-8cb5-4459-aa82-11f6680ea241", "node_type": "1", "metadata": {}, "hash": "9e4757247c1f0e4c1f873d2a34a024c2c3eddb0ba0e14cda2267b925533a1803", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0edf1415-de36-4270-9cef-7ec443a8c197", "node_type": "1", "metadata": {}, "hash": "2ec8ace2708eed0d39941003381a30cb294430cc455a6dd4d33fc5e7d6f762aa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": ">It is generally recommended to break the problem into smaller chunks, sol\nve them and then combine the results | It generally focusses on solving the \nproblem end to end \n>Training time is comparatively less | Training time is comparatively more \n>Results are more interpretable | Results Maybe more accurate but less int\nerpretable \n> No use of Neural networks | uses neural networks \n> Solves comparatively less complex problems | Solves more complex prob\nlems. \nQ6: What is perceptron and how it is related to human neurons? \nIf we focus on the structure of a biological neuron, it has dendrites, which \nare used to receive inputs. These inputs are summed in the cell body and \nusing the Axon it is passed on to the next biological neuron as shown \nbelow.Dendrite: Receives signals from other neurons \nCell Body: Sums all the inputs \nAxon: It is used to transmit signals to the other cells \nSimilarly, a perceptron receives multiple inputs, applies various \ntransformations and functions and provides an output. A Perceptron is a \nlinear model used for binary classification. It models a neuron, which has a \nset of inputs, each of which is given a specific weight. The neuron \ncomputes some function on these weighted inputs and gives the output.  \n \n \nQ7: Why deep learning is better than machine learning? \nThough traditional ML algorithms solve a lot of our cases, they are not \nuseful while working with high dimensional data that is where we have a \nlarge number of inputs and outputs. For example, in the case of \nhandwriting recognition, we have a large amount of input where we will \nhave different types of inputs associated with different types of handwriting.The second major challenge is to tell the computer what are the features it \nshould look for that will play an important role in predicting the outcome a s \nwell as to achieve better accuracy while doing so. \nQ8: What kind of problem can be solved by using deep learning?  \nDeep Learning is a branch of Machine Learning, which is used to solve \nproblems in a way that mimics the human way of solving problems. \nExamples: \n\uf0b7 Image recognition \n\uf0b7 Object Detection \n\uf0b7 Natural Language processing- Translation, Sentence formations, text \nto speech, speech to text \n\uf0b7 understand the semantics of actions \nQ9: List down all the activation function using mathematical    \n       Expression and example. What is the activation function? \nActivation functions are very important for an Artificial Neural Network to \nlearn and make sense of something complicated and the Non-linear \ncomplex functional mappings between the inputs and response variable. \nThey introduce non-linear properties to our Network. Their main purposes \nare to convert an input signal of a node in an A-NN to an output signal. \nSo why do we need Non-Linearities?Non-linear functions are those, which have a degree more than one, and \nthey have a curvature when we plot a Non-Linear function. Now we need a \nNeural Network Model to learn and represent almost anything and any \narbitrary complex function, which maps inputs to outputs. Neural-Networks \nare considered Universal Function Approximations. It means that they can \ncompute and learn any function at all. \nMost popular types of Activation functions - \n\uf0b7 Sigmoid or Logistic \n\uf0b7 Tanh \u2014 Hyperbolic tangent \n\uf0b7 ReLu -Rectified linear units \nSigmoid Activation function: It is a activation function of form f(x) = 1 / 1 \n+ exp(-x) . Its Range is between 0 and 1. It is an S-shaped curve. It is easy \nto understand. \n \nHyperbolic Tangent function- Tanh : It\u2019s mathematical formula is f(x) = 1 \n\u2014 exp(-2x) / 1 + exp(-2x). Now it\u2019s the output is zero centred because its \nrange in between -1 to 1 i.e. -1 < output < 1 . Hence optimisation is easier \nin this method; Hence in practice, it is always preferred over Sigmoid \nfunction.ReLu- Rectified Linear units: It has become more popular in the past \ncouple of years. It was recently proved that it has six times improvement in \nconvergence from Tanh function. It\u2019s R(x) = max (0,x) i.e. if x < 0 , R(x) = 0 \nand if x >= 0 , R(x) = x. Hence as seen that mathematical form of this \nfunction, we can see that it is very simple and efficient. Many times in \nMachine learning and computer science we notice that most simple and \nconsistent techniques and methods are only preferred and  are the best. \nHence, it avoids and rectifies the vanishing gradient problem.", "mimetype": "text/plain", "start_char_idx": 95168, "end_char_idx": 99567, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0edf1415-de36-4270-9cef-7ec443a8c197": {"__data__": {"id_": "0edf1415-de36-4270-9cef-7ec443a8c197", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88885557-bd8c-403d-984c-cf5894235e12", "node_type": "1", "metadata": {}, "hash": "cec1999fb8943a61e46f88e7c06bf14b1346899647356bccf56c8c09e26878c6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a9a3b6b9-ac9b-47b4-bb63-8933783ea95d", "node_type": "1", "metadata": {}, "hash": "5d09e004fdbdc32fad036a0a35eb7b5b46d7bbc4b0f18a76d1ec4b85e85c3e6d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Hence, it avoids and rectifies the vanishing gradient problem. Almost all the \ndeep learning Models use ReLu nowadays. \n \n \nQ10: Detail explanation about gradient decent using example and  \n       Mathematical expression?Gradient descent is an optimisation algorithm used to minimize some \nfunction by iteratively moving in the direction of steepest descent as \ndefined by negative of the gradient. In machine learning, we used gradient \ndescent to update the parameters of our model. Parameters refer t o \ncoefficients in the Linear Regression and weights in neural networks.  \n \nThe size of these steps called the learning rate. With the high learning rate, \nwe can cover more ground each step, but we risk overshooting the lower \npoint since the slope of the hill is constantly changing. With a very lower \nlearning rate, we can confidently move in the direction of the negativ e \ngradient because we are recalculating it so frequently. The Lower learning \nrate is more precise, but calculating the gradient is time -consuming, so it \nwill take a very large time to get to the bottom. \nMath \nNow let\u2019s run gradient descent using new cost function. There are two \nparameters in cost function we can control: m (weight) and b (bias). Since \nwe need to consider that the impact each one has on the final prediction, \nwe need to use partial derivatives. We calculate the partial derivative of the \ncost function concerning each parameter and store the results in a \ngradient. \nMath \nGiven the cost function:To solve for the gradient, we iterate by our data points using our new m \nand b values and compute the partial derivatives. This new gradient te lls us \nabout the slope of the cost function at our current position (current \nparameter values) and the directions we should move to update our \nparameters. The learning rate controls the size of our update. \nQ11: What is backward propagation?  \nBack-propagation is the essence of the neural net training and this \nmethod of fine-tuning the weights of a neural net based on the errors rate \nobtained in the previous epoch. Proper tuning of the weights allows us to \nreduce error rates and to make the model reliable by increasing its \ngeneralisation. \nBackpropagation is a short form of \"backward propagation of errors.\" This \nis the standard method of training artificial neural networks. This helps to \ncalculate the gradient of a loss function with respects to all the weights in \nthe network.Most prominent advantages of Backpropagation are: \n\uf0b7 Backpropagation is the fast, simple and easy to program. \n\uf0b7 It has no parameters to tune apart from the numbers of input . \n\uf0b7 It is the flexible method as it does not require prior knowledge about \nthe network \n\uf0b7 It is the standard method that generally works well. \n\uf0b7 It does not need any special mentions of the features of the function \nto be learned. \n \n \n \nQ12: How we assign weights in deep learning? \nWe already know that in a neural network, weights are usually initialised \nrandomly and that kind of initialisation takes a fair/significant amount of \nrepetitions to converge to the least loss and reach the ideal wei ght matrix. \nThe problem is, that kind of initialisation is prone to vanishing or exploding \ngradient problems.General ways to make it initialise better weights: \nReLu activation function in the deep nets. \n1. Generate a random sample of weights from a Gaussian \ndistribution having mean 0 and a standard deviation of 1.  \n2. Multiply the sample with the square root of (2/ni). Where ni is the \nnumber of input units for that layer. \nb) Likewise, if you\u2019re using Tanh activation function : \n1. Generate a random sample of weights from a Gaussian distribution \nhaving mean 0 and a standard deviation of 1. \n2. Multiply the sample with the square root of (1/ni) where ni is several \ninput units for that layer. \n \nQ13: What is optimiser is deep learning, and which one is the best? \nDeep learning is an iterative process. With so many hyperparameters to \ntune or methods to try, it is important to be able to train models fast, to \nquickly complete the iterative cycle. This is the key to increase the speed \nand efficiency of a machine learning team. \nHence the importance of optimisation algorithms such as stochastic \ngradient descent, min-batch gradient descent, gradient descent with \nmomentum and the Adam optimiser. \nAdam optimiser is the best one. \nGiven an algorithm f(x), it helps in either minimisation or maximisation of \nthe value of f(x).", "mimetype": "text/plain", "start_char_idx": 99505, "end_char_idx": 103982, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a9a3b6b9-ac9b-47b4-bb63-8933783ea95d": {"__data__": {"id_": "a9a3b6b9-ac9b-47b4-bb63-8933783ea95d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0edf1415-de36-4270-9cef-7ec443a8c197", "node_type": "1", "metadata": {}, "hash": "2ec8ace2708eed0d39941003381a30cb294430cc455a6dd4d33fc5e7d6f762aa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4908e5d1-f2e8-4fdc-8a2d-729037dec439", "node_type": "1", "metadata": {}, "hash": "c46b596c39af548d5d96f8809c994b3c217bf54455ec98be2d3745be8fa4d35a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In this context of deep learning, we use optimisation \nalgorithms to train the neural network by optimising the cost function J.  \nThe cost function is defined as:The value of the cost function J is the mean of the loss L between the \npredicted value y\u2019 and actual value y. The value y\u201d is obtained during the \nforward propagation step and makes use of the Weights W and biases b of \nthe network. With the help of optimisation algorithms, we minimise the \nvalue of Cost Function J  by updating the values of trainable \nparameters W and b. \nQ14: What is gradient descent, mini-batch gradient descent, batch  \n         gradient decent, stochastic gradient decent and adam?  \nGradient Descent \nit is an iterative machine learning optimisation algorithm to reduce the cost \nfunction, and help models to make accurate predictions. \nGradient indicates the direction of increase. As we want to find the \nminimum points in the valley, we need to go in the opposite direction of the \ngradient. We update the parameters in the negative gradient direction to \nminimise the loss. \n \nWhere \u03b8 is the weight parameter, \u03b7 is the learning rate, and \u2207J(\u03b8;x,y) is the \ngradient of weight parameter \u03b8 \nTypes of Gradient Descent \nDifferent types of Gradient descents are \n\uf0b7 Batch Gradient Descent or Vanilla Gradient Descent \n\uf0b7 Stochastic Gradient Descent\uf0b7 Mini batch Gradient Descent \nBatch Gradient Descent \nIn the batch gradient, we use the entire dataset to compute the gradient of \nthe cost function for each iteration for gradient descent and then update the \nweights. \nStochastic Gradient descent \nStochastic gradient descent, we use a single data point or example to \ncalculate the gradient and update the weights with every iteration.  \nWe first need to shuffle the datasets so that we get a completely \nrandomised dataset. As the datasets are random and weights, are updated \nfor every single example, an update of the weights and the cost functions \nwill be noisy jumping all over the place  \nMini Batch Gradient descent \nMini-batch gradients is a variation of stochastic gradient descent where \ninstead of a single training example, a mini-batch of samples are used. \nMini -batch gradient descent is widely used and converges faster and is \nmore stable. \nThe batch size can vary depending upon the dataset. \nAs we take batches with different samples, it reduces the noise which is a \nvariance of the weights updates, and that helps to have a more stable \nconverge faster. \nQ15: What are autoencoders? \nAn autoencoder, neural networks that have three layers: \nAn input layer, a hidden layer which is also known as encoding layer, and a \ndecoding layer. This network is trained to reconstruct its inputs, which \nforces the hidden layer to try to learn good representations of the inputs.An autoencoder neural network is an unsupervised Machine-learning \nalgorithm that applies backpropagation, setting the target values to be \nequal to the inputs. An autoencoder is trained to attempts to copy its input \nto its output. Internally, it has a hidden layer which describes a code used \nto represent the input. \n \nAutoencoder Components: \nAutoencoders consists of 4 main parts: \n1- Encoder: In this, the model learns how to reduce the input dimensions \nand compress the input data into an encoded representation.  \n2- Bottleneck: In this, the layer that contains the compressed \nrepresentation of the input data. This is the lowest possible dimension of \nthe input data. \n3- Decoder: In this, the model learns how to reconstruct the data from the \nencod represented to be as close to the original inputs as possible. \n4- Reconstruction Loss: In this method that measures measure how well \nthe decoder is performing and how closed the output is related to  the \noriginal input. \nTypes of Autoencoders : \n1. Denoising auto encoder \n2. Sparse auto encoder \n3. Variational auto encoder (VAE) \n4. Contractive auto encoder (CAE)Q16: What  is CNN? \nThis is the simple application of a filter to an input that results  in \ninactivation. Repeated application of the same filter to input results in a \nmap of activations called a feature map, indicating the locations and \nstrength of a detected feature in input, such as an image.  \nConvolutional layers are the major building blocks which are used in \nconvolutional neural networks. \nA covnets is the sequence of layers, and every layer transforms one \nvolume to another through differentiable functions. \nDifferent types of layers in CNN: \nLet\u2019s take an example by running a covnets on of image of dimension s 32 x \n32 x 3. \n1.", "mimetype": "text/plain", "start_char_idx": 103983, "end_char_idx": 108538, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4908e5d1-f2e8-4fdc-8a2d-729037dec439": {"__data__": {"id_": "4908e5d1-f2e8-4fdc-8a2d-729037dec439", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a9a3b6b9-ac9b-47b4-bb63-8933783ea95d", "node_type": "1", "metadata": {}, "hash": "5d09e004fdbdc32fad036a0a35eb7b5b46d7bbc4b0f18a76d1ec4b85e85c3e6d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cbcfe87f-7a52-4219-b9c2-30df358238a4", "node_type": "1", "metadata": {}, "hash": "e96ff047d9cca71427410fdccd5670fcbe199c79d6477fe6a2bf1a6975847775", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1. Input Layer: It holds the raw input of image with width 32, height 32 \nand depth 3. \n2. Convolution Layer: It computes the output volume by computing dot \nproducts between all filters and image patches. Suppose we use a \ntotal of 12 filters for this layer we\u2019ll get output volume of dimension 32 \nx 32 x 12. \n3. Activation Function Layer: This layer will apply the element-wise \nactivation function to the output of the convolution layer. Some  \nactivation functions are RELU: max(0, x), Sigmoid: 1/(1+e ^-x), Tanh, \nLeaky RELU, etc. So the volume remains unchanged. Hence output \nvolume will have dimensions 32 x 32 x 12. \n4. Pool Layer: This layer is periodically inserted within the covnets, and \nits main function is to reduce the size of volume which makes thecomputation fast reduces memory and also prevents overfitting. Two \ncommon types of pooling layers are max pooling and average \npooling. If we use a max pool with 2 x 2 filters and stride 2, the \nresultant volume will be of dimension 16x16x12. \n \n5. Fully-Connected Layer: This layer is a regular neural network layer \nthat takes input from the previous layer and computes the class \nscores and outputs the 1-D array of size equal to the number of \nclasses. \n \n \nQ17: What is pooling, padding, filtering operations on CNN? \nPooling Layer \nIt is commonly used to periodically insert a Pooling layer in-between \nsuccessive Conv layers in a ConvNet architecture. Its function is to \nprogressively reduce the spatial size of the representation to reduce the \nnumber of parameters and computation in the network, and hence to alsocontrol overfitting. The Pooling Layer operates independently on every \ndepth slice of the input and resizes it spatially, using the MAX operation.  \n \nThe most common form is a pooling layer with filters of size 2x2 applied \nwith a stride of 2 downsamples every depth slice in the input by two along \nboth width and height, discarding 75% of the activations. Every MAX \noperation would, in this case, be taking a max over four numbers (little 2x2 \nregion in some depth slice). The depth dimension remains unchanged.  \n \n \n \nQ18: What is the Evolution technique of CNN?It all started with LeNet in 1998 and eventually, after nearly 15 years, lead \nto groundbreaking models winning the ImageNet Large Scale Visual \nRecognition Challenge which includes AlexNet in 2012 to Google Net in \n2014 to ResNet in 2015 to an ensemble of previous models in 2016. In the \nlast two years, no significant progress has been made, and the new models \nare an ensemble of previous groundbreaking models. \n \nLeNet in 1998 \nLeNet is a 7-level convolutional network by LeCun in 1998 that classifies \ndigits and used by several banks to recognise the hand-written numbers on \ncheques digitised in 32x32 pixel greyscale input images.  \nAlexNet in 2012 \nAlexNet: It is considered to be the first paper/ model, which rose the \ninterest in CNNs when it won the ImageNet challenge in the year 2012. It is \na deep CNN trained on ImageNet and outperformed all the entries that \nyear. \nVGG in 2014 \nVGG was submitted in the year 2013, and it became a runner up in the \nImageNet contest in 2014. It is widely used as a simple architecture \ncompared to AlexNet.GoogleNet in 2014 \nIn 2014, several great models were developed like VGG, but the winner of \nthe ImageNet contest was GoogleNet. \nGoogLeNet proposed a module called the inception modules that includes \nskipping connections in the network, forming a mini-module, and this \nmodule is repeated throughout the network. \nResNet in 2015 \nThere are 152 layers in the Microsoft ResNet. The authors showed \nempirically that if you keep on adding layers, the error rate should keep on \ndecreasing in contrast to \u201cplain nets\u201d we're adding a few layers resulted in \nhigher training and test errors. \nQ19: How to initialise biases in deep learning? \nIt is possible and common to initialise the biases to be zero since the \nrandom numbers in the weights provide the asymmetry braking .", "mimetype": "text/plain", "start_char_idx": 108536, "end_char_idx": 112528, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cbcfe87f-7a52-4219-b9c2-30df358238a4": {"__data__": {"id_": "cbcfe87f-7a52-4219-b9c2-30df358238a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4908e5d1-f2e8-4fdc-8a2d-729037dec439", "node_type": "1", "metadata": {}, "hash": "c46b596c39af548d5d96f8809c994b3c217bf54455ec98be2d3745be8fa4d35a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "52938472-3f0e-46be-b9b9-9aff5e70391d", "node_type": "1", "metadata": {}, "hash": "3c2af3767a52ef43dc0875c147fe5670bf50a23e9263dc09977b88ad73d259f9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "For ReLU \nnon-linearities, some people like to use small constant value such as 0.01 \nfor all biases because this ensures that all ReLU units fire in the beginning, \ntherefore obtain, and propagate some gradient. However, it is unclear if this \nprovides a consistent improvement (in fact some results seem to indicate s \nthat this performs worst) and it is more commonly used to use 0 bias \ninitialisation. \nQ20: What is learning Rate? \nLearning Rate \nThe learning rate controls how much we should adjust the weights \nconcerning the loss gradient. Learning rates are randomly initialised. \nLower the values of the learning rate slower will be the convergence to \nglobal minima. \nHigher values for the learning rate will not allow the gradient descent to \nconvergeSince our goal is to minimise the  function cost to find the optimised value \nfor weights, we run multiples iteration with different weights and calculate \nthe cost to arrive at a minimum cost  \n \n----------------------------------------------------------------------------------------------------\n------------------------Data Science Interview Questions Page 1 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n# Day-5Data Science Interview Questions Page 2 \n \n \n \nQ1: What are Epochs? \nOne Epoch is an ENTIRE dataset is passed forwards and backwards through the neural network. \nSince one epoch is too large to feed to the computer at once, we divide it into several smaller batches. \nWe always use more than one Epoch because one epoch leads to underfitting.  \nAs the number of epochs increases, several times the weight are changed in the neural network and the \ncurve goes from underfitting up to optimal to overfitting curve. \nQ2. What is the batch size? \nBatch Size \nThe total number of training and examples present in a single batch. \nUnlike the learning rate hyper parameter where its value doesn\u2019t affect computational time, the batch \nsizes must be examined in conjunctions with the execution time of training. The batch size is limited by \nhardware\u2019s memory, while the learning rate is not. Leslie recommends usin g a bat ch size that fits in  \nhardware\u2019s memory and enables using larger learning rate. \nIf our server has multiple GPUs, the total batch size is the batch size on a GPU multiplied by the numbers \nof GPU. If the architectures are small or your hardware permits very large batch sizes, then you might \ncompare the performance of different batch sizes. Also, recall that small batch sizes add regularization \nwhile large batch sizes add less, so utilize this while balancing the proper amount of regularization. It is \noften better to use large batch sizes so a larger learning rate can be used. \nQ3: What is dropout in Neural network? \nDropout refers to ignoring units during the training phase of a certain set of neurons which is chosen \nrandomly. These units are not considered during the particular forward or backward pass. \nMore technically, at each training stage, individual nodes are either dropped out of the net with \nprobability 1-p or kept with probability p, so that a reduced network is left; incoming and outgoing edges \nto a dropped-out node are also removed.Data Science Interview Questions Page 3 \n \nWe need Dropout to prevent over-fitting \nA d ropout is an approach to regularization in neural networks which helps to reduce  interdependent \nlearning amongst the neurons. \nWhere to use \nDropout is implemented per-layer in a neural network. \nIt can be used with most types of layers, such as dense fully connected layers, convolutional layers, and \nrecurrent layers such as the long short-term memory network layer. \nDropout may be implemented on any or all hidden layers in the network as well as the visible or input \nlayer. It is not used on the output layer. \n \nBenefits:- \n1. Dropout forces a neural network to learn more robust features that are very useful in conjunction \nwith different random subsets of the other neurons. \n2. Dropout generally doubles the number of iterations required to converge. However, the training \ntime for each epoch is less. \nQ4: List down hyperparameter tuning in deep learning. \nThe process of setting the hyper-parameters requires expertise and extensive trial and error. There are no \nsimple and easy ways to set hyper-parameters \u2014 specifically, learning rate, batch size, momentum, and \nweight decay. \nApproaches to searching for the best configuration:  \n\u2022 Grid Search  \n\u2022 Random SearchData Science Interview Questions Page 4 \n \nApproach \n1. Observe and understand the clues available during training by  monitoring validation/test \nloss early in training, tune your architecture and hyper-parameters with short runs of a few \nepochs. \n2. Signs of underfitting or overfitting of the test or validation loss early in the training process are \nuseful for tuning the hyper-parameters.", "mimetype": "text/plain", "start_char_idx": 112529, "end_char_idx": 117397, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "52938472-3f0e-46be-b9b9-9aff5e70391d": {"__data__": {"id_": "52938472-3f0e-46be-b9b9-9aff5e70391d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cbcfe87f-7a52-4219-b9c2-30df358238a4", "node_type": "1", "metadata": {}, "hash": "e96ff047d9cca71427410fdccd5670fcbe199c79d6477fe6a2bf1a6975847775", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ccfc7cac-7479-4e04-97c5-a17ffd3610bf", "node_type": "1", "metadata": {}, "hash": "84f99f06102e9c59004f501faf8fcbddbd6c61a9129acdee67e3d688daaf8c04", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Tools for Optimizing Hyperparameters \n\u2022 Sage Maker \n\u2022 Comet.ml \n\u2022 Weights &Biases \n\u2022 Deep Cognition \n\u2022 Azure ML \n \nQ5: What do you understand by activation func tion and error \nfunctions? \nError functions \nIn most learning networks, an error is calculated as the difference between the predicted output and the \nactual output. \n \nThe function that is used to compute this error is known as Loss Function J(.). Different loss functions \nwill give different errors for the same prediction, and thus have a considerable effect on the performance \nof the model. One of the most widely used loss function is mean square error, which calculates the square \nof the difference between the actual values and predicted value. Different loss functions are used to deals \nwith a different type of tasks, i.e. regression and classification.Data Science Interview Questions Page 5 \n \nRegressive loss functions: \nMean Square Error \nAbsolute error \nSmooth Absolute Error \nClassification loss functions: \n1. Binary Cross-Entropy \n2. Negative Log-Likelihood \n3. Margin Classifier \n4. Soft Margin Classifier \nActivation functions decide whether a neuron should be activated or not by calculating a weighted sum \nand adding bias with it. The purpose of the activation function is to introduce non-linearity into the output \nof a neuron. \nIn a neural network, we would update the weights and biase s of the neurons based on the error at the \noutputs. This process is known as  back-propagation. Activation function  makes the back -propagation \npossible since the gradients are supplied along with the errors to update the weights and biases. \nQ6: Why do we need Non-linear activation functions? \n \nA neural network without activation function s is essentially  a linear regression model. The activation \nfunctions do the non -linear transformation to the input , making it capable of learning and performing  \nmore complex tasks. \n1. Identity \n2. Binary Step \n3. Sigmoid \n4. Tanh \n5. ReLU \n6. Leaky ReLUData Science Interview Questions Page 6 \n \n7. Softmax \nThe activation functions do the non-linear transformation to the input, making it capable of learning and \nperforming more complex tasks. \nQ7: What do you under by vanishing gradient problem and how can  \n       Do we solve that? \nThe problem: \nAs more layers using certain activation function are added to neural networks, the gradients of the loss \nfunction approach zero, making the networks tougher to train. \nWhy: \nCertain activation functions, like the sigmoid function, squishes a large input space into a small input \nspace between 0 and 1. Therefore, a large change in the input of the sigmoid function will cause a small \nchange in the output. Hence, the derivative becomes small. \n \nFor shallow networks with only a few layers that use these activations, this isn\u2019t a big problem. However, \nwhen more layers are used, it can cause the gradient to be too small for training to work effectively. \nHowever, when  n hidden layers use an activation like the sigmoid function,  n small derivatives are \nmultiplied together. Thus, the gradient decreases exponentially as we propagate down to the initial layers.Data Science Interview Questions Page 7 \n \nSolutions: \nThe simplest solution is to use other activation functions, such as ReLU, which doesn\u2019t cause a small \nderivative. \nResidual networks are another solution, as they provide residual connections straight to earlier layers. \nFinally, batch normalization layers can also resolve the issue. \nQ8: What is Transfer learning in deep learning ? \nTransfer learning: It is a machine learning method where a model is developed for the task is again used \nas the starting point for a model on a second task. \nIt is a popular approach in deep learning where pre -trained models are  used as the starting point on \ncomputer vision and natural language processing tasks given the vast compute and time resources \nrequired to develop neural network models on these problems \nTransfer learning is a machine learning technique where a model trained on one task is re-purposed on a \nsecond related task. \nTransfer learning is an optimization that allows rapid progress or improved performance when modelling \nthe second task. \nTransfer learning only works in deep learning if the model features learned from the first task are general.Data Science Interview Questions Page 8 \n \n \nQ9: What is VGG16 and explain the architecture of VGG16? \nVGG-16 is a simpler architecture model since it\u2019s not using many hyperparameters. It always uses 3 x 3 \nfilters with the stride of 1 in convolution layer and uses SAME padding in pooling layers 2 x 2 with a \nstride of 2. \n \n \nThis architecture is from the VGG group, Oxford.", "mimetype": "text/plain", "start_char_idx": 117401, "end_char_idx": 122101, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ccfc7cac-7479-4e04-97c5-a17ffd3610bf": {"__data__": {"id_": "ccfc7cac-7479-4e04-97c5-a17ffd3610bf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "52938472-3f0e-46be-b9b9-9aff5e70391d", "node_type": "1", "metadata": {}, "hash": "3c2af3767a52ef43dc0875c147fe5670bf50a23e9263dc09977b88ad73d259f9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e476761c-7a95-4b3b-b61c-fa2eab14e5af", "node_type": "1", "metadata": {}, "hash": "eb8cdb4b03d74b8cdcc93ff070dc480865c3a8defcec1c0c1e943089caae2a8d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This architecture is from the VGG group, Oxford. It improves AlexNet by replacin g the large kernel -\nsized filter  with multiple 3X3 kernel -sized filters one after another. With a given receptive field(the \neffective area size of input image on which output depends), multiple stacked smaller size kernel is better \nthan the one with a larger size kernel because multiple non-linear layers increases the depth of the \nnetwork which enables it to learn more complex features, and that too at a lower cost.  \nThree fully connected layers follow the VGG convolutional  layers. The width of the network s starts at \nthe small value of 64  and increases by a factor of 2 after every sub -sampling/pooling layer. It achieves \nthe top-5 accuracy of 92.3 % on ImageNet. \n \nQ10: What is RESNET? \nThe winner of ILSRVC 2015, it also called as Residual Neural Network (ResNet) by Kaiming. This \narchitecture introduced a concept called \u201cskip connections\u201d. Typically, the input matrix calculates in two \nlinear transformations with ReLU activation function. In Residual network, it directly cop ies the input \nmatrix to the second transformation output and sums the output in final ReLU function.Data Science Interview Questions Page 9 \n \n \nSkip Connection \n \nExperiments in paper four can judge the power of the residual network . The plain 34 layer network had \nhigh validation error than the 18 layers plain network. This is where we realize the degradation problems. \nAnd the same 34 layers network when converted to  the residual network has much less training error \nthan the 18 layers residual network.  \nQ11: What is ImageNet? \nImageNet is a project aimed at (manually) labelling and categorizing images into almost 22,000 separate \nobject categories for computer vision researches. \nWhen we hear the about\u201cImageNet\u201d in the context of deep learning and Convolutional Neural Network, \nwe are referring to ImageNet Large Scale Visual Recognition Challenge. \nThe main aim  of this image classi fication challenge is to train the model that can correctly classify an \ninput image into the 1,000 separate objects category.Data Science Interview Questions Page 10 \n \nModels are trained on  the ~1.2 million training images with another 50,000 images for validation and \n100,000 images for testing. \nThese 1,000 image categories represent object classes that we encounter in our day-to-day lives, such as \nspecies of dogs, cats, various household objects, vehicle types, and much more.  \nWhen it comes to  the image classification, the ImageNet challenge is the  \u201cde facto  \u201c benchmark for \ncomputer vision classification algorithms \u2014 and the leaderboard for this challenge has \nbeen dominated by Convolutional Neural Networks and Deep learning techniques since 2012. \n \nQ12:  What is DarkNet? \nDarkNet is a framework  used to train neural networks ; it is open source and written in C/CUDA and \nserves as the basis for YOLO. Darknet is also used as the framework for training YOLO, meaning it sets \nthe architecture of the network. \nClone the repo locally, and you have it. To compile it, run a make. But first, if you intend to use the GPU \ncapability, you need to edit the Makefile in the first two lines, where you tell it to compile for GPU usage \nwith CUDA drivers. \nQ13: What is YOLO and explain the architecture of YOLO (you only  \n Look Once). One use case? \nYOLO v1 \nThe first YOLO You only look once (YOLO ) version came about May 2016 and sets the core of the \nalgorithm, the following versions are improvements that fix some drawbacks.Data Science Interview Questions Page 11 \n \nIn short, YOLO is a network \u201cinspired by\u201d  Google Net. It has 24 convolutional layers working as the \nfeature extractors and two dense layers for making the predictions. The architecture works upon is called \nDarknet, a neural network framework created by the first author of the YOLO paper. \nCore Concept:- \nThe algorithm works off by dividing the  image into the grid of the cells,  for each cell bounding boxes \nand their scores are predicted, alongside class probab ilities. The c onfidence is given in terms of  IOU \n(intersection over union ), metric, which is measuring how much the  detected object overlaps with the \nground truth as a fraction of the total area spanned by the two together (the union).", "mimetype": "text/plain", "start_char_idx": 122053, "end_char_idx": 126346, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e476761c-7a95-4b3b-b61c-fa2eab14e5af": {"__data__": {"id_": "e476761c-7a95-4b3b-b61c-fa2eab14e5af", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ccfc7cac-7479-4e04-97c5-a17ffd3610bf", "node_type": "1", "metadata": {}, "hash": "84f99f06102e9c59004f501faf8fcbddbd6c61a9129acdee67e3d688daaf8c04", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d19c585e-1e41-4651-9d48-40e3972eb08a", "node_type": "1", "metadata": {}, "hash": "d3f260cbc291a7f27407f04521097a3305f1f2e27536b883f0be74102e628eb2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "YOLO v2- \nThis improves on some of the shortcomings  of the first version, namely the fact that it is not very good \nat detecting objects that are very near and tends to make some of the mistakes on localization. \nIt introduces a few new er things: Which are anchor boxes (pre-determined sets of boxes such that the \nnetwork moves from predicting the bounding boxes to predicting the offsets from these) and the use of \nfeatures that are more fine-grained so smaller objects can be predicted better. \n \nYOLO v3- \nYOLOv3 came about April 2018, and it adds small improvements, including the fact that bounding boxes \nget predicted at the different scales. The underlying meaty part of the  YOLO network, Darknet, is \nexpanded in this version to have 53 convolutional layersData Science Interview Questions Page 12 \n \n \n \n----------------------------------------------------------------------------------------------------------------------------P a g e  1 | 7 \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 08P a g e  2 | 7 \n \nQ1. What is Tensorflow? \nAns: \nTensorFlow: TensorFlow is an open-source software library released in 2015 by Google to make it \neasier for the developers to design, build, and train deep learning models. TensorFlow  is originated \nas an internal library that the Google developers used to build the models in house, and we e xpect \nadditional functionality to be added in the open-source version as they are tested and vetted in internal \nflavour. Although TensorFlow is the only one of several options available to the developers and we \nchoose to use it here because of thoughtful design and ease of use. \nAt a high level, TensorFlow is a Python library that allows users to express arbitrary computation as \na graph of  data flows . Nodes in this graph represent mathematical operations, whereas edges \nrepresent data that is com municated from one node to another. Data in TensorFlow are represented \nas tensors, which are multidimensional arrays. Although this framework for thinking about \ncomputation is valuable in many different fields, TensorFlow is primarily used for deep learnin g in \npractice and research. \n \n  \n \n \nQ2. What are Tensors? \nAns: \nTensor: In mathematics, it is an algebraic object that describes the linear mapping from one set of \nalgebraic objects to the another. Objects that the tensors may map between include, but are not limited \nto the vectors, scalars and recursively, even other tensors (for example, a matrix is the map between \nvectors and thus a tensor. Therefore the linear map between matrices is also the tensor). Tensors are \ninherently related to the vector spaces and their dual spaces and can take several different forms. ForP a g e  3 | 7 \n \nexample, a scalar, a  vector, a  dual vector at a point, or a  multi-linear map between vector \nspaces. Euclidean vectors and scalars are simple tensors. While tensors are defined as independent of \nany basis. The literature on physics , often referred by their components on a basis related to a \nparticular coordinate system. \n \n \nQ3. What is TensorBoard? \nAns: \nTensorBoard, a suit of visuali sing tools, is an easy solution to Tensorflow offered by the creators \nthat lets you visualise the graphs, plot quantitative metrics about the graph with additional data like \nimages to pass through it. \n \nThis one is some example of how the TensorBoard is working.P a g e  4 | 7 \n \nQ4. What are the features of TensorFlow? \nAns: \n\u2022 One of the main features of TensorFlow is its ability to build neural networks. \n\u2022 By using these neural networks, machines can perform logical thinking and learn similar to \nhumans. \n\u2022 There are the other tensors for processing, such as data loading, preprocessing, calculation, \nstate and outputs. \n\u2022 It considered not only as deep learning but also as the library for performing the tensor \ncalculations, and it is the most excellent library when considered as the deep learning \nframework that can also describe basic calculation processing. \n\u2022 TensorFlow describes all calculation processes by calculation graph, no matter how simple \nthe calculation is. \n \nQ5. What are the advantages of TensorFlow? \nAns: \n\u2022 It allows Deep Learning. \n\u2022 It is open-source and free. \n\u2022 It is reliable (and without major bugs) \n\u2022 It is backed by Google and a good community. \n\u2022 It is a skill recognised by many employers. \n\u2022 It is easy to implement. \n \nQ6. List a few limitations of Tensorflow. \nAns: \n\u2022 Has the GPU memory conflicts with Theano if imported in the same scope.", "mimetype": "text/plain", "start_char_idx": 126348, "end_char_idx": 130902, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d19c585e-1e41-4651-9d48-40e3972eb08a": {"__data__": {"id_": "d19c585e-1e41-4651-9d48-40e3972eb08a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e476761c-7a95-4b3b-b61c-fa2eab14e5af", "node_type": "1", "metadata": {}, "hash": "eb8cdb4b03d74b8cdcc93ff070dc480865c3a8defcec1c0c1e943089caae2a8d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3c8fc582-44e8-4266-bf4e-2074786d0c60", "node_type": "1", "metadata": {}, "hash": "f0c51f7baa95649e90a35a537bd5d9c23519c2321109ca2f66b0d1c4cc941b18", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Ans: \n\u2022 Has the GPU memory conflicts with Theano if imported in the same scope. \n\u2022 It has dependencies with other libraries. \n\u2022 Requires prior knowledge of the advanced calculus and linear algebra along with the pretty \ngood understanding of machine learning.P a g e  5 | 7 \n \nQ7. What are the use cases of Tensor flow? \nAns: \nTensorflow is an important tool of deep learning, it has mainly five use cases, and they are: \n\u2022 Time Series \n\u2022 Image recognition \n\u2022 Sound Recognition \n\u2022 Video detection \n\u2022 Text-based  Applications \n \nQ8. What are the very important steps of Tensorflow architecture? \nAns: \nThere are three main steps in the Tensorflow architecture are: \n\u2022 Pre-process the Data \n\u2022 Build a Model \n\u2022 Train and estimate the modelP a g e  6 | 7 \n \nQ9. What is Keras? \nAns: \nKeras:  It is an Open Source Neural Network library written in Python that runs on the top of Theano \nor Tensorflow. It is designed to be  the modular, fast and easy to use. It was developed by Fran\u00e7ois \nChollet, a Google engineer. \n \nQ10. What is a pooling layer? \nAns: \n Pooling layer: It is generally used in reducing the spatial dimensions and not depth, on a \nconvolutional neural network model. \n \n \nQ11. What is the difference between CNN and RNN? \nAns: \nCNN (Convolutional Neural Network) \n\u2022 Best suited for spatial data like images \n\u2022 CNN is powerful compared to RNN \n\u2022 This network takes a fixed type of inputs and outputs \n\u2022 These are the  ideal for video and image processingP a g e  7 | 7 \n \nRNN (Recurrent Neural Network)  \n\u2022 Best suited for sequential data \n\u2022 RNN supports less feature set than CNN. \n\u2022 This network can manage the arbitrary input and output lengths. \n\u2022 It is ideal for text and speech analysis. \nQ12. What are the benefits of Tensorflow over other libraries? \nAns: \n       The following benefits are:  \n\u2022 Scalability \n\u2022 Visualisation of Data \n\u2022 Debugging facility \n\u2022 Pipelining \n \n-------------------------------------------------------------------------------------------------------------P a g e  1 | 11 \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 10P a g e  2 | 11 \n \n \nQ1. What is a Recommender System? \n \nAnswer: \nA recommender system is today widely deployed in multiple fields like movie recommendations, music \npreferences, social tags, research articles, search queries and so on. The recommender systems work as \nper collaborative and content-based filtering or by deploying a personality-based approach. This type of \nsystem works based on a person\u2019s past behavior in order to build a model for the future. This will predict \nthe future product buying, movie viewing or book reading by people. It also creates a filtering approach \nusing the discrete characteristics of items while recommending additional items. \n \n \n \nQ2. Compare SAS, R and Python programming? \n \nAnswer: \nSAS: it is one of the most widely used analytics tools used by some of the biggest companies on earth. \nIt has some of the best  statistical functions, graphical user interface, but can come with a price tag and \nhence it cannot be readily adopted by smaller enterprisesP a g e  3 | 11 \n \nR: The best part about R is that it is an Open Source tool and hence used generously by academia and \nthe research community. It is a robust tool for statistical computation, graphical representation and \nreporting. Due to its open source nature it is always being updated with the latest features and then readily \navailable to everybody. \nPython: Python is a powerful open source programming language that is easy to learn, works well with \nmost other tools and technologies. The best part about Python is that it has innumerable libraries and \ncommunity created modules making it very robust. It has functions for statistical ope ration, model \nbuilding and more. \n \n \n \nQ3. Why is important in data analysis? \n \nAnswer: \nWith data coming in from multiple sources it is important to ensure that data is good enough for analysis. \nThis is where data cleansing becomes extremely vital. Data cleansing extensively deals with the process \nof detecting and correcting of data records, ensuring that data is complete and accurate and the \ncomponents of data that are irrelevant are deleted or modified as per the needs. This process can be \ndeployed in concurrence with data wrangling or batch processing.P a g e  4 | 11 \n \nOnce the data is cleaned it confirms with the rules of the data sets in the system.", "mimetype": "text/plain", "start_char_idx": 130823, "end_char_idx": 135259, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3c8fc582-44e8-4266-bf4e-2074786d0c60": {"__data__": {"id_": "3c8fc582-44e8-4266-bf4e-2074786d0c60", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d19c585e-1e41-4651-9d48-40e3972eb08a", "node_type": "1", "metadata": {}, "hash": "d3f260cbc291a7f27407f04521097a3305f1f2e27536b883f0be74102e628eb2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2f530467-8fbb-4808-83ec-099ae4805751", "node_type": "1", "metadata": {}, "hash": "d8fcea89241d1f63d96a615d30d05f3d995e1f628c9b80ab8bfdb117f08f8464", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Data cleansing is an \nessential part of the data science because the data can be prone to error due to human negligence, \ncorruption during transmission or storage among other things. Data cleansing takes a huge chunk of time \nand effort of a Data Scientist because of the multiple sources from which data emanates and the speed at \nwhich it comes. \n \n \n \nQ4. What are the various aspects of a Machine Learning process? \n \nAnswer: \nHere we will discuss the components involved in solving a problem using machine learning. \nDomain knowledge \nThis is the first step wherein we need to understand how to extract the various features from the data and \nlearn more about the data that we are dealing with. It has got more to do with the type of domain that we \nare dealing with and familiarizing the system to learn more about it.P a g e  5 | 11 \n \n \nFeature Selection \nThis step has got more to do with the feature that we are selecting from the set of features that we have. \nSometimes it happens that there are a lot of features and we have to make an intelligent decision regarding \nthe type of feature that we want to select to go ahead with our machine learning endeavor. \nAlgorithm \nThis is a vital step since the algorithms that we choose will have a very major impact on the entire process \nof machine learning. You can choose between the linear and nonlinear algorithm. Some of the algorithms \nused are Support Vector Machines, Decision Trees, Na\u00efve Bayes, K-Means Clustering, etc. \nTraining \nThis is the most important part of the machine learning technique and this is where it differs from the \ntraditional programming. The training is done based on the data that we have and providing more real \nworld experiences. With each consequent training step the machine gets better and smarter and able to \ntake improved decisions. \nEvaluation \nIn this step we actually evaluate the decisions taken by the machine in order to decide whether it is up to \nthe mark or not. There are various metrics that are involved in this process and we have to closed deploy \neach of these to decide on the efficacy of the whole machine learning endeavor. \nOptimization \nThis process involves improving the performance of the machine learning p rocess using various \noptimization techniques. Optimization of machine learning is one of the most vital components wherein \nthe performance of the algorithm is vastly improved. The best part of optimization techniques is that \nmachine learning is not just a consumer of optimization techniques but it also provides new ideas for \noptimization too. \nTesting \nHere various tests are carried out and some these are unseen set of test cases. The data is partitioned into \ntest and training set. There are various testing t echniques like cross -validation in order to deal with \nmultiple situations.P a g e  6 | 11 \n \n \n \nQ4. What is Interpolation and Extrapolation? \nAnswer: \nThe terms of interpolation and extrapolation are extremely important in any statistical analysis. \nExtrapolation is the determination or estimation using a known set of values or facts by extending it and \ntaking it to an area or region that is unknown. It i s the technique of inferring something using data that \nis available. \nInterpolation on the other hand is the method of determining a certain value which falls between a certain \nset of values or the sequence of values. This is especially useful when you have data at the two extremities \nof a certain region but you don\u2019t have enough data points at the specific point. This is when you deploy \ninterpolation to determine the value that you need.P a g e  7 | 11 \n \n \nQ5. What does P-value signify about the statistical data? \nAnswer: \nP-value is used to determine the significance of results after a hypothesis test in statistics. P-value helps \nthe readers to draw conclusions and is always between 0 and 1. \n\u2022 P- Value > 0.05 denotes weak evidence against the null hypothesis which means the null hypothesis \ncannot be rejected. \n\u2022 P-value <= 0.05 denotes strong evidence against the null hypothesis which means the null hypothesis \ncan be rejected. \n\u2022 P-value=0.05is the marginal value indicating it is possible to go either way. \n \n \n \nQ6. During analysis, how do you treat missing values? \nAnswer: \nThe extent of the missing values is identified after identifying the variables with missing values. If any \npatterns are identified the analyst has to concentrate on them as it could lead to interesting and meaningful \nbusiness insights.", "mimetype": "text/plain", "start_char_idx": 135260, "end_char_idx": 139765, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2f530467-8fbb-4808-83ec-099ae4805751": {"__data__": {"id_": "2f530467-8fbb-4808-83ec-099ae4805751", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3c8fc582-44e8-4266-bf4e-2074786d0c60", "node_type": "1", "metadata": {}, "hash": "f0c51f7baa95649e90a35a537bd5d9c23519c2321109ca2f66b0d1c4cc941b18", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8693e9b3-d9f2-4952-8a90-8891b0455b31", "node_type": "1", "metadata": {}, "hash": "c8a1c51f221605fb0090d71ef7f1d5928a68e5ffd24541563c863141c4de692a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "If there are no patterns identified, then the missing values can be substituted with mean \nor median values (imputation) or they can simply be ignored.P a g e  8 | 11 \n \nThere are various factors to be considered when answering this question- \nUnderstand the problem statement, understand the dat a and then give the answer.Assigning a default \nvalue which can be mean, minimum or maximum value. Getting into the data is important. \nIf it is a categorical variable, the default value is assigned. The missing value is assigned a default value. \nIf you have a distribution of data coming, for normal distribution give the mean value. \nShould we even treat missing values is another important point to consider? If 80% of the values for a \nvariable are missing then you can answer that you would be dropping the variable instead of treating the \nmissing values. \n \n \nQ7. Explain the difference between a Test Set and a Validation Set? \n \nAnswer: \nValidation set can be considered as a part of the training set as it is used for parameter selection and to \navoid Overfitting of the model being built. On the other hand, test set is used for testing or evaluating \nthe performance of a trained machine leaning model. \nIn simple terms ,the differences can be summarized as- \nTraining Set is to fit the parameters i.e. weights. \nTest Set is to assess the performance of the model i.e. evaluating the predictive power and \ngeneralization. \nValidation set is to tune the parameters.P a g e  9 | 11 \n \nQ8. What is the curse of dimensionality? Can you list some ways to \ndeal with it? \nAnswer: \nThe curse of dimensionality is when the training data has a high feature count, but the dataset does not \nhave enough samples for a model to learn correctly from so many features. For example, a training dataset \nof 100 samples with 100 features will be very hard to learn from because the model will find random \nrelations between the features and the target. However , if we had a dataset of 100k samples with 100 \nfeatures, the model could probably learn the correct relationships between the features and the target. \nThere are different options to fight the curse of dimensionality: \n\uf0b7 Feature selection. Instead of using all the features, we can train on a smaller subset of features. \n\uf0b7 Dimensionality reduction. There are many techniques that allow to reduce the dimensionality \nof the features. Principal component analysis (PCA) and using autoencoders are examples of \ndimensionality reduction techniques. \n\uf0b7 L1 regularization. Because it produces sparse parameters, L1 helps to deal with high-\ndimensionality input. \n\uf0b7 Feature engineering. It\u2019s possible to create new features that sum up multiple existing \nfeatures. For example, we can get statistics such as the mean or median.P a g e  10 | 11 \n \nQ9. What is data augmentation? Can you give some examples? \nAnswer: \nData augmentation is a technique for synthesizing new data by modifying existing data in such a way \nthat the target is not changed, or it is changed in a known way. \nComputer vision is one of fields where data augmentation is very useful. There are many modifications \nthat we can do to images: \n\uf0b7 Resize \n\uf0b7 Horizontal or vertical flip \n\uf0b7 Rotate \n\uf0b7 Add noise \n\uf0b7 Deform \n\uf0b7 Modify colors \nEach problem needs a customized data augmentation pipeline. For example, on OCR, doing flips will \nchange the text and won\u2019t be beneficial; however, resizes and small rotations may help. \n \n \nQ10. What is stratified cross-validation and when should we use it? \nAnswer: \nCross-validation is a technique for dividing data between training and validation sets. On typical cross -\nvalidation this split is done randomly. But in  stratified cross-validation, the split preserves the ratio of \nthe categories on both the training and validation datasets.P a g e  11 | 11 \n \nFor example, if we have a dataset with 10% of category A and 90% of category B, and we use stratified \ncross-validation, we will have the same proportions in training and validation. In contrast, if we use \nsimple cross-validation, in the worst case we may find that there are no samples of category A in the \nvalidation set. \nStratified cross-validation may be applied in the following scenarios: \n\uf0b7 On a dataset with multiple categories. The smaller the dataset and the more imbalanced the \ncategories, the more important it will be to use stratified cross-validation. \n\uf0b7 On a dataset with data of different distributions. For example, in a dataset for autonomous \ndriving, we may have images taken during the day and at night.", "mimetype": "text/plain", "start_char_idx": 139766, "end_char_idx": 144316, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8693e9b3-d9f2-4952-8a90-8891b0455b31": {"__data__": {"id_": "8693e9b3-d9f2-4952-8a90-8891b0455b31", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2f530467-8fbb-4808-83ec-099ae4805751", "node_type": "1", "metadata": {}, "hash": "d8fcea89241d1f63d96a615d30d05f3d995e1f628c9b80ab8bfdb117f08f8464", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9189b8e0-7f66-479a-afec-6b653f695be5", "node_type": "1", "metadata": {}, "hash": "1df9c891655090d3eb53842c0d2b86f4740ad8812ca971a30ccdb290cbe08b66", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "If we do not ensure that both \ntypes are present in training and validation, we will have generalization problems.P a g e  1 | 12 \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 11P a g e  2 | 12 \n \nQ1. What are tensors? \nAnswer: \nThe tensors are no more than a method of presenting the data in deep learning. If put in the simple term, \ntensors are just multidimensional arrays that allow developers to represent the data in a layer , which \nmeans deep learning you are using contains high -level data sets where each dimension represents a \ndifferent feature. \n \nThe foremost benefit of using tensors is it provides the much -needed platform-flexibility and is easy to \ntrainable on CPU. Apart from this, tensors have the auto differentiation capabili ties, advanced support \nsystem for queues, threads, and asynchronous computation. All these features also make it customizable. \n                        \n \nQ2. Define the concept of RNN? \n \nAnswer: \nRNN is the artificial neutral which were created to analyze and recognize the patterns in the sequences \nof the data. Due to their internal memory, RNN can certainly remember the things about the inputs they \nreceive.P a g e  3 | 12 \n \n \n \n \n Most common issues faced with RNN \n \nAlthough RNN is around for a while and uses backpropagation, there are some common issues faced \nby developers who work it. Out of all, some of the most common issues are: \n\uf0b7 Exploding gradients \n\uf0b7 Vanishing gradientsP a g e  4 | 12 \n \nQ3. What is a ResNet, and where would you use it? Is it efficient? \nAnswer: \nAmong the various neural networks that are used for computer vision, ResNet (Residual Neural \nNetworks), is one of the most popular ones. It allows us to train extremely deep neural networks, which \nis the prime reason for its huge usage and popularity. Before the invention of this network, training \nextremely deep neural networks was almost impossible. \nTo understand why we must look at the vanishing gradient problem which is an issue that arises when \nthe gradient is backpropagated to all the layers. As a large number of multiplications are performed, the \nsize of  the network keeps decreasing till it becomes extremely small , and thus, the network starts \nperforming badly. ResNet helps to counter the vanishing gradient problem.  \nThe efficiency of this network is highly dependent on the concept of skip connections. Skip connections \nare a method of allowing a shortcut path through which the gradient can flow, which in effect helps \ncounter the vanishing gradient problem.  \nAn example of a skip connection is shown below: \n \nIn general, a skip connection allows us to sk ip the training of a few layers. Skip connections are also \ncalled identity shortcut connections as they allow us to directly compute an identity function by just \nrelying on these connections and not having to look at the whole network. \nThe skipping of these layers makes ResNet an extremely efficient network.P a g e  5 | 12 \n \nQ4. Transfer learning is one of the most useful concepts today. Where \ncan it be used? \n \nAnswer: \nPre-trained models are probably one of the most common use cases for transfer learning. \nFor anyone who does not have access to huge computational power, training complex models is always \na challenge. Transfer learning aims to help by both improving the performance and speeding up your \nnetwork. \nIn layman terms, transfer learning is a technique in which a model that has alre ady been trained to do \none task is used for another without much change. This type of learning is also called multi-task learning. \nMany models that are pre -trained are available online. Any of these models can be used as a starting \npoint in the creation of the new model required. After just using the weights, the model must be refined \nand adapted on the required data by tuning the parameters of the model.P a g e  6 | 12 \n \nThe general idea behind transfer learning is to transfer knowledge not data. For humans, this task is easy \n\u2013 we can generalize models that we have mentally created a long time ago for a different purpose. One \nor two samples is almost always enough. However, in the case of neural networks, a huge amount of data \nand computational power are required. \nTransfer learning should generally be used when we don\u2019t have a lot of labeled training data, or if there \nalready exists a network for the task you are trying to achieve, probably trained on a much more massive \ndataset. Note, however, that the input of the model mus t have the same size during training.", "mimetype": "text/plain", "start_char_idx": 144317, "end_char_idx": 148894, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9189b8e0-7f66-479a-afec-6b653f695be5": {"__data__": {"id_": "9189b8e0-7f66-479a-afec-6b653f695be5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8693e9b3-d9f2-4952-8a90-8891b0455b31", "node_type": "1", "metadata": {}, "hash": "c8a1c51f221605fb0090d71ef7f1d5928a68e5ffd24541563c863141c4de692a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ac8cafeb-3622-4928-991d-bd5ce6a15521", "node_type": "1", "metadata": {}, "hash": "58b4ff857d33f9f69e700cd1b48163a8a94c1ca20ffb09f80704d8a803d6c9e8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Note, however, that the input of the model mus t have the same size during training. Also, this \nworks only if the tasks are fairly similar to each other , and the features learned can be generali zed. For \nexample, something like learning how to recognize vehicles can probably be extended to learn how to \nrecognize airplanes and helicopters. \n \nQ5. What does tuning of hyperparameters signify? Explain with \nexamples. \n \nAnswer: \nA hyperparameter is just a variable that defines the structure of the network. Let\u2019s go through some \nhyperparameters and see the effect of tuning them. \n1. A number of hidden layers \u2013 Most times, the presence or absence of a large number of hidden \nlayers may de termine the output, accuracy and training time of the neural network. Having a \nlarge number of these layers may sometimes cause an increase in accuracy. \n2. Learning rate \u2013 This is simply a measure of how fast the neural network will change its \nparameters. A large learning rate may lead to the network not being able to converge, but might \nalso speed up learning. On the other hand, a smaller value for the learning rate will probably slow \ndown the network but might lead to the network being able to converge. \n3. Number o f epochs \u2013 This is the number of times the entire training data is run through the \nnetwork. Increasing the number of epochs leads to better accuracy. \n4. Momentum \u2013 Momentum is a measure of how and where the network will go while taking into \naccount all of its past actions. A proper measure of momentum can lead to a better network. \n5. Batch Size \u2013 Batch size determines the number of subsamples that are inputs to the network \nbefore every parameter update.P a g e  7 | 12 \n \n \nQ6. Why are deep learning models referred as black boxes? \nAnswer: \nLately, the concept of deep learning being a black box has been floating around. A black box is a system \nwhose functioning cannot be properly grasped, but the output produced can be understood and utilized. \nNow, since most models are mathematically sound and are created based on legit equations, how is it \npossible that we do not know how the system works? \n \nFirst, it is almost impossible to visualize the  functions that are generated by a system. Most machine \nlearning models end up with such complex output that a human can't make sense of it. \nSecond, there are networks with millions of hyperparameters. As a human, we can grasp around 10 to 15 \nparameters. But analysing a million of them seems out of the question. \nThird and most important, it becomes very hard, if not impossible, to trace back why the system made \nthe decisions it did. This may not sound like a huge problem to worry about b ut consider the case of a \nself driving car. If the car hits someone on the road, we need to understand why that happened and prevent \nit. But this isn\u2019t possible if we do not understand how the system works.P a g e  8 | 12 \n \nTo make a deep learning model not be a black box, a new field called Explainable Artificial Intelligence \nor simply, Explainable AI is emerging. This field aims to be able to create intermediate results and trace \nback the decision-making process of a system. \nQ7. Why do we have gates in neural networks? \n \nAnswer: \nTo understand gates, we must first understand recurrent neural networks. \nRecurrent neural networks allow information to be stored as a memory using loops. Thus, the output of \na recurrent neural network is not only based on the current input but also the past inputs which are stored \nin the memory of the network. Back propagation is done through time , but in general, the truncated \nversion of this is used for longer sequences. \nGates are generally used in networks that are dependent on time. In effect, any network wh ich would \nrequire memory, so to speak, would benefit from the use of gates. These gates are generally used to keep \ntrack of any information that is required by the network without leading to a state of either vanishing or \nexploding gradients. Such a network can also preserve the error through time. Since a sense of constant \nerror is maintained, the network can learn better. \n \nThese gated units can be considered as units with recurrent connections. They also contain additional \nneurons, which are gates. If you  relate this process to a signal processing system, the gate is used toP a g e  9 | 12 \n \nregulate which part of the signal passes through. A sigmoid activation function is used which means that \nthe values taken are from 0 to 1.", "mimetype": "text/plain", "start_char_idx": 148810, "end_char_idx": 153316, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ac8cafeb-3622-4928-991d-bd5ce6a15521": {"__data__": {"id_": "ac8cafeb-3622-4928-991d-bd5ce6a15521", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9189b8e0-7f66-479a-afec-6b653f695be5", "node_type": "1", "metadata": {}, "hash": "1df9c891655090d3eb53842c0d2b86f4740ad8812ca971a30ccdb290cbe08b66", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "70c3a405-717b-499e-b5b3-2abb9dd4b19c", "node_type": "1", "metadata": {}, "hash": "a6f1cbeb6510228525a828ecbcec094ffca5c6b1d2fb7d02c53dba6b6420cb25", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "An advantage of using gates is that it enables the network to either forget information that it has already \nlearned or to selectively ignore information either based on the state of the network or the input the gate \nreceives. \nGates are extensively used in recurrent neural networks, especially in Long Short-Term Memory (LSTM) \nnetworks. A general LSTM network will have 3 to 5 gates , typically an input gate, output gate, hidden \ngate, and activation gate. \n \n \nQ8. What is a Sobel filter? \nAnswer: \nThe Sobel filter performs a two-dimensional spatial gradient measurement on a given image, which then \nemphasizes regions that have a high spatial frequency. In effect, this means finding edges. \nIn most cases, Sobel filters are used to find the approximate absolute gradient magnitude for every point \nin a grayscale image. The operator consists of a pair of 3\u00d73 convolution kernels. One of these kernels is \nrotated by 90 degrees.P a g e  10 | 12 \n \n \nThese kernels respond to edges that run horizontal or vertical with respect to the pi xel grid, one kernel \nfor each orientation. A point to note is that these kernels can be applied either separately or can be \ncombined to find the absolute magnitude of the gradient at every point. \nThe Sobel operator has a large convolution kernel , which ends up smoothing the image to a greater \nextent, and thus, the operator becomes less sensitive to noise. It also produces higher output values for \nsimilar edges compared to other methods. \nTo overcome the problem of output values from the operator overfl owing the maximum allowed pixel \nvalue per image type, avoid using image types that support pixel values. \n \nQ9. What is the purpose of a Boltzmann Machine? \n \nAnswer: \nBoltzmann machines are algorithms that are based on physics, specifically thermal equilibrium. A special \nand more well-known case of Boltzmann machines is the Restricted Boltzmann machine, which is a type \nof Boltzmann machine where there are no connections between hidden layers of the network.P a g e  11 | 12 \n \nThe concept was coined by Geoff Hinton , who most recently wo n the Turing award. In general, the \nalgorithm uses the laws of thermodynamics and tries to optimi ze a global distribution of energy in the \nsystem. \n \nIn discrete mathematical terms, a restricted Boltzmann machine can be called a symmetric bipartite \ngraph, i.e. two symmetric layers. These machines are a form of unsupervised learning, which means that \nthere are no labels provided with data. It uses stochastic binary units to reach this state. \nBoltzmann machines are derived from Markov state machines. A Markov State Machine is a model that \ncan be used to represent almost any computable function. The restricted Boltzmann machine can be \nregarded as an undirected graphical model. It is used in dimensionality reduction, collaborative filtering, \nlearning features as well  as modeling. It can also be used for classification and regression. In general, \nrestricted Boltzmann machines are composed of a two-layer network, which can then be extended further. \nNote that these models are probabilistic since each of the nod es present in the system learns low -level \nfeatures from items in the dataset. For example, if we take a grayscale image, each node that is \nresponsible for the visible layer will take just one-pixel value from the image. \nA part of the process of creating such a  machine is a feature hierarchy where sequences of activations \nare grouped in terms of features. In thermodynamics principles, simulated annealing is a process that the \nmachine follows to separate signal and noise.P a g e  12 | 12 \n \nQ10. What are the types of weight initialization? \n \nAnswer: \nThere are two major types of weight initialization:- zero initialization and random initialization.  \nZero initialization: In this process, biases and weights are initialised to 0.  If the weights are set to \n0, all derivatives with respect to the loss functions in the weight matrix become equal. Hence, none of \nthe weights change during subsequent iterations. Setting the bias to 0 cancels out any effect it may \nhave. \nAll hidden units become symmetric due to zero initialization. In general, zero initialization is not very \nuseful or accurate for classification and thus must be avoided when any classification task is required. \n \nRandom initialization: As compared to 0 initialization, this involves setting random values for the \nweights. The only disadvantage is that set very high values will increase the learning time as the \nsigmoid activation function maps close to 1. Likewise, if low values are set, the learning time increases \nas the activation function is mapped close to 0.", "mimetype": "text/plain", "start_char_idx": 153318, "end_char_idx": 158013, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "70c3a405-717b-499e-b5b3-2abb9dd4b19c": {"__data__": {"id_": "70c3a405-717b-499e-b5b3-2abb9dd4b19c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ac8cafeb-3622-4928-991d-bd5ce6a15521", "node_type": "1", "metadata": {}, "hash": "58b4ff857d33f9f69e700cd1b48163a8a94c1ca20ffb09f80704d8a803d6c9e8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c0efc1cf-f839-45d2-99a2-f73458812cef", "node_type": "1", "metadata": {}, "hash": "281db622bdac95d4b72f6890f3f242c91fb5ff0ceeb6b45e820a5dbbeb165582", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Setting too high or too low values thus generally leads to the exploding or vanishing gradient problem. \nNew types of weight initialization like \u201cHe initialization\u201d and \u201cXavier initialization\u201d have also \nemerged. These are based on specific equations and are not mentioned here due to their sheer \ncomplexity.P a g e  1 | 11 \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 14P a g e  2 | 11 \n \nQ1. What is Alexnet? \nAnswer:  \nThe Alex Krizhevsky, Geoffrey Hin ton and Ilya Sutskever created the  neural network architecture \ncalled \u2018AlexNet\u2019 and won Image Classification Challenge (ILSVRC) in 2012. They trained their \nnetwork on 1.2 million high-resolution images into 1000 different classes with 60 million parameters \nand 650,000 neurons. The training was done on two GPUs with split layer concept because GPUs \nwere a little bit slow at that time. \nAlexNet is the name of  convolutional neural network which has had a large impact on the field \nof machine learning, specifically in the application of deep learning to machine vision. The network \nhad very similar architecture as the LeNet by Yann LeCun et al. but was deeper with more filters per \nlayer, and with the stacked convolutional layers. It consist of  ( 11\u00d711, 5\u00d75,3\u00d73, convolutions), max \npooling, dropout, data augmentation, ReLU activ ations and SGD with the momentum. It attached  \nwith ReLU activations after every convolutional and fully connected layer. AlexNet was trained for \nsix days simultaneously on two Nvidia Geforce GTX 580 GPUs , which is the reason for why their \nnetwork is split into the two pipelines. \nArchitecture \n \n \nAlexNet contains eight layers with weights, first five are convolutional, and the remaining three are \nfully connected. The output of  last fully -connected layer is fed to a 1000 -way softmax which \nproduces a distribution over the 1000 class labels. The network maximi ses the multinomial logistic \nregression objective, which is equivalent to maximising the average across training cases of the log-\nprobability of the correct label under the predictio n distribution. The kernels of second, fourth, and \nthe fifth convolutional layers are connected only with those kernel maps in the previous layer which \nreside on the same GPU. The kernels of third convolutional layer are connected to all the kernel maps \nin second layer. The neurons in fully connected layers are connected to all the neurons in the previous \nlayers.P a g e  3 | 11 \n \nIn short, AlexNet contains five convolutional layers and three fully connected layers. Relu is applied \nafter the very convolutional and  the fully connected layer. Dropout is applied before the  first and \nsecond fully connected year.  The network has the 62.3 million parameters and needs 1.1 billion \ncomputation units in a forward pass. We can also see convolution layers, which accounts for 6% of \nall the parameters, consumes 95% of the computation. \n \nQ2. What is VGGNet? \nAnswer:  \nVGGNet consists of 16 convolutional layers and is very appealing because of its very uniform \narchitecture. Similar to AlexNet, only 3x3 convolutions, but lots of filters. Trained on 4 GPUs for 2\u2013\n3 weeks. It is currently the most preferred choice in the community for extracting features from \nimages. The weight configuration of the VGGNet is publicl y available and has been used in many \nother applications and challenges as a baseline feature extractor. However, VGGNet consists of 138 \nmillion parameters, which can be a bit challenging to handle. \nThere are multiple variants of the VGGNet (VGG16, VGG19 etc.) which differ only in total number \nof layers in the networks. The structural details of the VGG16 network has been shown: \n \n \n \nThe idea behind having the fixed size kernels is that all the variable size convolutional kernels used \nin the Alexnet (11x11, 5x5, 3x3) can be replicated by making use of multiple 3x3 kernels as the \nbuilding blocks. The replication is in term of the receptive field covered by kernels .P a g e  4 | 11 \n \nLet\u2019s consider the example. Say we have an input layer of  the size 5x5x1. Implementing the  conv \nlayer with kernel size of 5x5 and stride one will the results and output feature map of (1x1).", "mimetype": "text/plain", "start_char_idx": 158015, "end_char_idx": 162247, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c0efc1cf-f839-45d2-99a2-f73458812cef": {"__data__": {"id_": "c0efc1cf-f839-45d2-99a2-f73458812cef", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "70c3a405-717b-499e-b5b3-2abb9dd4b19c", "node_type": "1", "metadata": {}, "hash": "a6f1cbeb6510228525a828ecbcec094ffca5c6b1d2fb7d02c53dba6b6420cb25", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "118c9f4c-ed95-423c-ab24-c12cc0664fa8", "node_type": "1", "metadata": {}, "hash": "543fd1b18e182702461154a1a97d599cb32d3f0bcb3134c1eb29d1b53515d168", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The same \noutput feature map can  obtained by implementing  the two (3x3) Conv layers with stride of 1 as  \nbelow: \n \n \nNow, let\u2019s look at the number of the variables needed to be trained. For a 5x5 Conv layer filter, the \nnumber of variables is 25. On the other hand, two conv layers of kernel size 3x3 have a total of \n3x3x2=18 variables (a reduction of 28%).P a g e  5 | 11 \n \nQ3. What is VGG16? \nAnswer:  \nVGG16: It is a convolutional neural network model proposed by the K. Simonyan and A. Zisserman \nfrom the University of Oxford in the paper \u201cVery Deep Convolutional Networks for the Large-Scale \nImage Recognition\u201d. The model achieves 92.7% top 5 test accuracy in ImageNet, which is the dataset \nof over 14 million images belongin g to the 1000 classes. It was one of  famous model submitted \nto ILSVRC-2014. It improves AlexNet by replacing the large kernel-sized filters (11 and 5 in the first \nand second convolutional layer, respectively) with multiple 3\u00d73 kernel-sized filters one after another. \nVGG16 was trained for weeks and was using NVIDIA Titan Black GPU\u2019s. \n \nThe Architecture \nThe architecture depicted below is VGG16. \n \nThe input to the Cov1 layer is of fixed size of 224 x 224 RGB image. The image is passed through \nthe stack of convolutional (conv.) layers, where the filters were used with a very small receptive field: \n3\u00d73 (which is the smallest size to capture the notion of left/right, up/down, c entre). In one of the \nconfigurations, it also utili ses the 1\u00d71 convolution  filters, which can be seen as the  linear \ntransformation of the input channels . The convolution stride is fixed to the 1 pixel, the spatial padding \nof the Conv. layer input is such that, the spatial resolution is preserved after the convolution, i.e. theP a g e  6 | 11 \n \npadding is 1-pixel for 3\u00d73 Conv. layers. Spatial pooling is carried out by the five max-pooling layers, \nwhich follows some of the Conv. Layers. Max-pooling is performed over the 2\u00d72 pixel window, with \nstride 2. \nThree Fully-Connected (FC) layers follow the stack of convolutional layers (which has the different \ndepth in different architectures): the first two have 4096 channels each, the third performs 1000-way \nILSVRC classification and thus contains 1000 channels . The final layer is  softmax layer. The \nconfigurations of the fully connected layers is same in all the networks. \nAll hidden layers are equipped with rectification (ReLU) non-linearity. It is also noted that none of \nthe networks (except for one) contain the Local Response Normalisation (LRN), such normalisation \ndoes not improve the performance on the ILSVRC dataset, but leads to increased memory \nconsumption and computation time. \nQ4. What is ResNet? \nAnswer:  \nAt the ILSVRC 2015,  so-called Residual Neural Network (ResNet) by the Kaiming He et al \nintroduced the anovel architecture with \u201cskip connections\u201d and features heavy batch normali sation. \nSuch skip connections are also known as the gated units or gated recurrent units and have the strong \nsimilarity to recent successful elements applied in RNNs. Thanks to this technique as they were able \nto train the NN with 152 layers while still having lower complexity than the VGGNet. It achieves the \ntop-5 error rate of 3.57%, which beats human-level performance on this dataset. \n \nQ5. What is HAAR CASCADE? \nAnswer:  \nHaar Cascade: It is the machine learning object detections algorithm used to identify the objects in \nan image or  the video and based on the concept of   features proposed by Paul Viola and Michael \nJones in their paper \"Rapid Object Detection using a Boosted Cascade of Simple Features\" in 2001. \nIt is a machine learning-based approach where the cascade function is trained from the lot of positive \nand negative images. It is then used to detect the objects in other images.", "mimetype": "text/plain", "start_char_idx": 162248, "end_char_idx": 166068, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "118c9f4c-ed95-423c-ab24-c12cc0664fa8": {"__data__": {"id_": "118c9f4c-ed95-423c-ab24-c12cc0664fa8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c0efc1cf-f839-45d2-99a2-f73458812cef", "node_type": "1", "metadata": {}, "hash": "281db622bdac95d4b72f6890f3f242c91fb5ff0ceeb6b45e820a5dbbeb165582", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c6fdb29b-089e-4e68-a1fe-29bd215b9666", "node_type": "1", "metadata": {}, "hash": "5bc7cc29ae3194e7bbd2b7bd7c6389d0779864ccf0fd20a62d6f31e58a56043d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is then used to detect the objects in other images. \nThe algorithm has four stages:P a g e  7 | 11 \n \n\uf0b7 Haar Feature Selection \n\uf0b7 Creating  Integral Images \n\uf0b7 Adaboost Training \n\uf0b7 Cascading Classifiers \nIt is well known for being able to detect faces and body parts in an image  but can be trained to \nidentify almost any object. \n \n \nQ6. What is Transfer Learning? \nAnswer:  \nTransfer learning: It is the  machine learning method where the  model developed for a task is \nreused as the starting point for the model on the second task . \nTransfer Learning differs from the traditional Machine Learning in that it is the use of pre-trained \nmodels that have been used for another task to jump-start the development process on a new task \nor problem.P a g e  8 | 11 \n \nThe benefits of the Transfer Learning are that it can speed up the time as it takes to develop and \ntrain the model by reusing these pieces or modules of already developed models. This helps to \nspeed up the model training process and accelerate results. \n \nQ7. What is Faster, R-CNN? \nAnswer:  \nFaster R -CNN: It  has two networks: region proposal network (RPN) for generating region \nproposals and a network using these proposals to detect objects. The main differen ce here with \nthe Fast R-CNN is that the later uses selective search to generate the region proposals. The time \ncost of generating the region proposals is much smaller in the RPN than selective search, when \nRPN shares the most computation with  object detection network.  In brief, RPN ranks region \nboxes (called anchors) and proposes the ones most likely containing objects. \nAnchors \nAnchors play an  very important role in Faster R -CNN. An anchor is the  box. In  default \nconfiguration of Faster R -CNN, there are nine anchors at the position of an image. The graphs \nshown 9 anchors at the position (320, 320) of an image with size (600, 800).P a g e  9 | 11 \n \nRegion Proposal Network: \nThe output of the region proposal network is the bunch of boxes/proposals that will be examined \nby a classifier and regressor to check the occurrence of objects eventually . To be more \nprecise, RPN predicts the possibility of an anchor being background or foregrou nd, and refine \nthe anchor. \n \n \nQ8. What is RCNN? \nAnswer:  \nTo bypass the problem of selecting the huge number of regions, Ross Girshick et al. proposed a \nmethod where we use  the selective search to extract just 2000 regions from the image , and he \ncalled them  as region proposals. Therefore, instead of trying to classify the  huge number of \nregions, you can work with 2000 regions.P a g e  10 | 11 \n \n \nProblems with R-CNN: \n\uf0b7 It still takes the huge amount of time to train the network as we would have to classify \n2000 region proposals per image. \n\uf0b7 It cannot be implemented real-time as it takes around 47 seconds for each test image. \n\uf0b7 The selective search algorithm is the fixed algorithm. Therefore, no learning is happening \nat that stage. This leads to the generation of the bad candidate region proposals. \n \nQ9.What is GoogLeNet/Inception? \nAnswer:  \nThe winner of the ILSVRC 2014 competition was GoogLeNet from Google. It achieved a top-5 error \nrate of 6.67%! This was very close to human-level performance which the organisers of the challenge \nwere now forced to evaluate. As it turns out, this was rather hard to do and required some human \ntraining to beat GoogLeNets accuracy. After the few days of training, the human expert (Andre j \nKarpathy) was able to achieve the top-5 error rate of 5.1%(single model) and 3. 6%(ensemble). The \nnetwork used the  CNN inspired by LeNet but implemented a novel element which is dubbed an \ninception module. It used batch normalisation, image distortions and RMSprop. This module is based \non the several very small convolutions to reduce the number of parameters drastically . T heir \narchitecture consisted of the  22 layer deep CNN but reduced the number of parameters from 60 \nmillion (AlexNet) to 4 million. \n It contains 1\u00d71 Convolution at the middle of network, and global average pooling is used at the end \nof the network instead of using the fully connected layers.", "mimetype": "text/plain", "start_char_idx": 166014, "end_char_idx": 170157, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c6fdb29b-089e-4e68-a1fe-29bd215b9666": {"__data__": {"id_": "c6fdb29b-089e-4e68-a1fe-29bd215b9666", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "118c9f4c-ed95-423c-ab24-c12cc0664fa8", "node_type": "1", "metadata": {}, "hash": "543fd1b18e182702461154a1a97d599cb32d3f0bcb3134c1eb29d1b53515d168", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ac439d6a-4376-4bba-83b3-786ab995cdfb", "node_type": "1", "metadata": {}, "hash": "dea3cf2ba0301c447a6566bb06860192c1a921d034f9a71812db31f409fc81e4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These two techniques are from another \npaper \u201cNetwork In-Network\u201d (NIN). Another technique, called inception module, is to have different \nsizes/types of convolutions for the same input and to stack all the outputs.P a g e  11 | 11 \n \n               \nQ10. What is LeNet-5? \nAnswer:  \nLeNet-5, a pioneering 7-level convolutional network by the LeCun et al in 1998, that classifies digits, \nwas applied by sever al banks to recognise hand -written numbers on checks (cheques) digiti sed in \n32x32 pixel greyscale input images. The ability to process higher -resolution images requires larger \nand more convolutional layers, so the availability of computing resources constrains this technique. \n \n LeNet-5 is very simple network. It only has seven layers, among which there are three convolutional \nlayers (C1, C3 and C5), two sub-sampling (pooling) layers (S2 and S4), and one fully connected layer \n(F6), that are followed by output layers. Convolutional layers use 5 by 5 convolutions with stride 1. \nSub-sampling layers are 2 by 2 average pooling layers. Tanh sigmoid activations are used to \nthroughout the network. Several interesting architectural choices were made in LeNet-5 that are not \nvery common in the modern era of deep learning. \n \n------------------------------------------------------------------------------------------------------------------------DATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n# Day-16Q1.What is Statistics Learning?  \nAnswer: \nStatistical learning: It is the framework for understanding data based on the statistics, which can be \nclassified as  the supervised or unsupervised. S upervised statistical learning  involves building the \nstatistical model for predicting, or estimating, an output based on one or more inputs, while \nin unsupervised statistical learning , there are inputs but no supervising output , but we can learn \nrelationships and structure from such data. \nY = f(X) + \u025b ,X = (X1,X2, . . .,Xp), \nf : It is an unknown function & \u025b is random error (reducible & irreducible). \nPrediction & Inference: \nIn the situations , where the set of inputs X are readily available, but the output Y is not known, we \noften treat f as the black box (not concerned with the exact form of  \u201cf\u201d), as long as it yields  the \naccurate predictions for Y. This is the prediction. \nThere are the situations where we are interested in understanding the way that Y is affected as X \nchange. In this type of situation, we wish to estimate f, but our goal is not necessarily to make the \npredictions for Y. Here we are more interested in understanding the relationship between the X and \nY. Now f cannot be treated as the  black box, because we need to know it \u2019s exact form. This \nis inference. \n \nParametric & Non-parametric methodsParametric statistics: This  statistical tests based on underlying the assumptions about data\u2019s \ndistribution. In other words, It is based on the parameters of the normal curve. Because parametric \nstatistics are based on the normal curve, data must meet certain assumptions, or parametric statistics \ncannot be calculated. Before running any parametric statistics, you should always be sure to test the \nassumptions for the tests that you are planning to run. \nf(X) = \u03b20 + \u03b21X1 + \u03b22X2 + . . . + \u03b2pXp \nAs by the name, nonparametric statistics are not based on parameters of the normal curve. Therefore, \nif our data violate the assumptions of a usual  parametric and nonparametric statistics might better \ndefine the data, try running the nonparametric equiva lent of the parametric test. We  should also \nconsider using nonpara metric equivalent tests when we  have limited sample sizes (e.g., n < 30). \nThough the nonparametric statistical tests have more flexibility than do parametric statistical tests, \nnonparametric tests are not as robust; therefore, most statisticians recommend that when appropriate, \nparametric statistics are preferred. \n. \nPrediction Accuracy and Model Interpretability: \nOut o f many methods that we use for  the statistical learning, some are less flexible and more \nrestrictive . When inference is the goa l, then there are clear advantages of  using the simple and \nrelatively inflexible statistical learning methods. When we are only interested in the prediction, we \nuse flexible models available.Q2. What is ANOVA?", "mimetype": "text/plain", "start_char_idx": 170158, "end_char_idx": 174501, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ac439d6a-4376-4bba-83b3-786ab995cdfb": {"__data__": {"id_": "ac439d6a-4376-4bba-83b3-786ab995cdfb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c6fdb29b-089e-4e68-a1fe-29bd215b9666", "node_type": "1", "metadata": {}, "hash": "5bc7cc29ae3194e7bbd2b7bd7c6389d0779864ccf0fd20a62d6f31e58a56043d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d7c0aece-b729-4a43-901e-4c64c0876c83", "node_type": "1", "metadata": {}, "hash": "671d15d9a2451c3ec9f2f203c9da738e11799576e4dc66774556ad353f8f81c0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "What is ANOVA?  \nAnswer: \nANOVA: it stands for \u201c Analysis of Variance \u201d is an extremely important tool for analysis of data \n(both One Way and Two Way ANOVA is used). It is a statistical method to compare the population \nmeans of two or more groups by analyzing variance. The variance would differ only when the means \nare significantly different. \nANOVA test is the way to find out if survey or experiment results are significant. In other words, It \nhelps us to figure out if we  need to reject the null hypothesis or accept the alternate hypothesis. We \nare testing groups to see if there\u2019s a difference between  them. Examples of when we might want to \ntest different groups: \n\uf0b7 The group of psychiatric patients are trying three different therapies: counseling, medication, \nand biofeedback. We want to see if one therapy is better than the others. \n\uf0b7 The manufacturer has two different processes to make light bulbs if they want to know which \none is better. \n\uf0b7 Students from  the different colleges take the same exam. We  want to see if one college \noutperforms the other. \n \n \nTypes of ANOVA: \n\uf0b7 One-way ANOVA \n\uf0b7 Two-way ANOVA \n \nOne-way ANOVA is the hypothesis test in which only one categorical variable or the single \nfactor is taken into consideration. With the help of  F-distribution, it e nables us to compare \nmeans of three or more samples. The Null hypothesis (H0) is the equity in all population \nmeans while an Alternative hypothesis is the difference in at least one mean.There are two-ways ANOVA examines the effect of two independent factors on a dependent \nvariable. It also studies the inter-relationship between independent variables influencing the \nvalues of the dependent variable, if any. \n \n \n \nQ3. What is ANCOVA? \nAnswer: \nAnalysis of Covariance (ANCOVA): It is the inclusion of the continuous variable in addition to the \nvariables of interest ( the dependent and independent variable) as means for the control. Because the \nANCOVA is the  extension of the ANO VA, the researcher can still  assess main effects and the \ninteractions to answer their research hypotheses.  The difference between  ANCOVA and an ANOVA \nis that an ANCOVA model includes the  \u201ccovariate\u201d that is correlated with  dependent variable and \nmeans on dependent variable are adjusted due to effects the covariate has on it. Covariates can alsobe use d in many ANOVA based designs: such as between -subjects, within -subjects (repeated \nmeasures), mixed (between \u2013 and within \u2013 designs), etc.  Thus, this technique answers the question \nIn simple terms, The difference between ANOVA and the ANCOVA is the letter \"C\", which stands \nfor 'covariance'. Like ANOVA, \"Analysis of Covar iance\" (ANCOVA) has the  single continuous \nresponse variable. Unlike ANOVA, ANCOVA compares the response variable by both the factor and \na continuous independent variable (example comparing test score by both 'level of education' and the \n'number of hours spent in studying'). The terms for the continuous independent variable (IV) used in \nthe  ANCOVA is \"covariate\". \nExample of ANCOVAQ4. What is MANOVA? \nAnswer: \nMANOVA (multivariate analysis of variance) : It is a type of multivariate analysis used to analyze \ndata that involves more than one dependent variable at a time. MANOVA allows us to test hypotheses \nregarding the effect of one or more independent variables on two or more dependent variables. \nThe obvious difference between ANOVA and the \"Multivariate Analysis of Variance\" (MANOVA) \nis the \u201cM\u201d, which stands for multivariate. In basic terms, MANOVA is an ANOVA with two or more \ncontinuous response variable s. Like ANOVA, MANOVA has both the  one-way flavor and a two-\nway flavor. The number of factor variables involved distinguish the one-way MANOVA from a two-\nway MANOVA.  \n \n \nWhen comparing the two or more co ntinuous response variables by the  single factor, a one -way \nMANOVA is appropriate (e.g. comparing \u2018test score\u2019 and \u2018annual income\u2019 toge ther by \u2018level ofeducation\u2019). The two-way MANOVA also entails two or more continuous response variables, but \ncompares them by at least two factors (e.g. c omparing \u2018test score\u2019 and \u2018annual income\u2019 together by \nboth \u2018level of education\u2019 and \u2018zodiac sign\u2019).  \n \nQ5.", "mimetype": "text/plain", "start_char_idx": 174487, "end_char_idx": 178715, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d7c0aece-b729-4a43-901e-4c64c0876c83": {"__data__": {"id_": "d7c0aece-b729-4a43-901e-4c64c0876c83", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ac439d6a-4376-4bba-83b3-786ab995cdfb", "node_type": "1", "metadata": {}, "hash": "dea3cf2ba0301c447a6566bb06860192c1a921d034f9a71812db31f409fc81e4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7346b2bf-b20f-4a61-87b0-14401e8fed02", "node_type": "1", "metadata": {}, "hash": "0def772d659ddb7a83f814be9c1dab090beaa37c0134d9b3587f1e4e6a142d27", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q5. What is MANCOVA? \nAnswer: \nMultivariate analysis of covariance (MANCOVA): It is a statistical technique that is the extension of \nanalysis of covariance (ANCOVA). It is the  multivariate analysis of variance (MANOVA) with a \ncovariate(s).).  In MANCOVA, we assess for statistical differences on multiple continuous dependent \nvariables by an independent grouping variable, while controlling for a third variable called the \ncovariate; multiple covariates can be used, depending on the sample size.   Covariates are added so \nthat it can reduce error terms and so that the analysis eliminates the covariates\u2019 effect on the \nrelationship between the independent grouping variable and the continuous dependent variables. \nANOVA and ANCOVA, the main difference between the MANOVA and MANCOVA, is the \u201cC,\u201d \nwhich again stands for the \u201ccovariance.\u201d Both the MANOVA and MANCOVA feature two or more \nresponse variables, but the key differe nce between the two i s the nature of the IVs. While the  \nMANOVA can include only factors, an analysis evolves from MANOVA to MANCOVA when one \nor more covariates are added to the mix.Q6. Explain the differences between KNN classifier  \n and KNN regression methods. \nAnswer: \nThey are quite similar. Given a value for  KK and a prediction point  x0x0, KNN regression first \nidentifies the  KK training observa tions that are closes to  x0x0, represented by  N0. It then \nestimates f(x0) using the average of all the training responses in N0. In other words, \n                                                   \nSo the main difference is the fact that for the classifier approach, the algorithm assumes the outcome \nas the class of more presence, and on the regression approach, the response is the average value of \nthe nearest neighbors. \n \nQ7. What is t-test? \nAnswer: \nTo understand T-Test Distribution, Consider the situation, you want to compare the performance of \ntwo workers of your company by checking the average sales done by each of them, or to compare \nthe performance of a worker by comparing the average sales done by him with the standard value. In \nsuch situations of daily life, t distribution is applicable. \nA t-test is the type of inferential statistic used to determine if there is a significant difference between \nthe means of two groups, which may be related in certain features. It is mostly used when the data \nsets, like the data set recorded as the outcome from flipping a coin 100 times, would follow a normal \ndistribution and may have unknown variances. A t -test is used as a hypothesis testing tool, which \nallows testing of an assumption applicable to a population.Understand t-test with Example: Let\u2019s say you have a cold, and you try a naturopathic remedy. Your \ncold lasts a couple of days. The next time when you ha ve a cold, you buy an over -the-counter \npharmaceutical, and the cold lasts a week. You survey your friends , and they all tell you that their \ncolds were of a shorter duration (an average of 3 days) when they took the homeopathic remedy. \nWhat you want to know is, are these results repeatable? A t-test can tell you by comparing the means \nof the two groups and letting you know the probability of those results happening by chance. \n \n \n \nQ8. What is Z-test? \nAnswer: \nz-test: It is a statistical test used to determine whether the two population means are different when \nthe variances are known, and the sample size is large. The test statistic is assumed to have the normal \ndistribution, and nuisance parameters such as standard deviation should be known for an accurate z-\ntest to be performed.Another definition of Z-test: A Z-test is a type of hypothesis test. Hypothesis testing is just the way \nfor you to figure out if results from a test are valid or repeatable. Example, if someone said they had \nfound the new drug that cures cancer, you would want to  be sure it was probably true. H ypothesis \ntest will tell you if it\u2019s probably true or probably not true. A Z test is used when your data is \napproximately normally distributed. \n Z-Tests Working : \nTests that can b e conducted as  the z-tests include one-sample location test, a two -sample location \ntest, a paired difference test, and a maximum likelihood estimate. Z-tests are related to t-tests, but t-\ntests are best pe rformed when an experiment has the  small sample size.", "mimetype": "text/plain", "start_char_idx": 178712, "end_char_idx": 183053, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7346b2bf-b20f-4a61-87b0-14401e8fed02": {"__data__": {"id_": "7346b2bf-b20f-4a61-87b0-14401e8fed02", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d7c0aece-b729-4a43-901e-4c64c0876c83", "node_type": "1", "metadata": {}, "hash": "671d15d9a2451c3ec9f2f203c9da738e11799576e4dc66774556ad353f8f81c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a2807378-86ca-4366-984c-deeb7f761b80", "node_type": "1", "metadata": {}, "hash": "f7f6446bfab3bea7f82c40b8185d4def35494648ed7820452c95a92420dfa602", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Also,  T-tests assumes the \nstandard deviation is unknown, while z -tests assumes that it is known. If the standard deviation of \nthe population is unknown, then the assumption of the sample  variance equaling the population \nvariance is made. \nWhen we can run the Z-test : \nDifferent types of tests are used in the statistics (i.e., f test, chi-square test, t-test). You would use a \nZ test if: \n\uf0b7 Your sample size is greater than 30. Otherwise, use a t-test. \n\uf0b7 Data points should be independent from each other. Some other words, one data point is not \nrelated or doesn\u2019t affect another data point. \n\uf0b7 Your data should be normally distributed. However, for large sample sizes (over 30) , this \ndoesn\u2019t always matter. \n\uf0b7 Your data should be randomly selected from a population, where each item has an equal \nchance of being selected. \n\uf0b7 Sample sizes should be equal, if at all possible.Q9. What is Chi-Square test? \nAnswer: \nChi-square (\u03c72) statistic: It is a test that measures how expectations compare to actual observed data \n(or model results). The data used in calculating a chi-square statistic must be random, raw, mutually \nexclusive, drawn from independent variables, and drawn from a large enough sample. For example, \nthe results of tossing a coin 100 times meet these criteria. \nChi-square test is intended to test how it is that an observed distribution is du e to chance. It is also \ncalled the \"goodness of fit\"  statistic because it measures how well the observed distribution of  the \ndata fits with the distribution that is expected if the variables are independent. \nChi-square test is designed to analyze the categorical data. That means that the data has been counted \nand divided into categories. It will not work with parametric or continuous data (such as height in \ninches). For example, if you want to test whether attending class influences how students perform on \nan exam, using test scores (from 0 -100) as data would not be appropriate for a Chi -square test. \nHowever, arranging students into the categories \"Pass\" and \"Fail\" would. Additionally, the data in a \nChi-square grid should not be in the form of percentages, or anything other than frequency (count) \ndata.Q10. What is correlation and the covariance in the statistics? \nAnswer: \nThe Covariance and Correlation are two mathematical concepts; these two approaches are widely \nused in the statistics. Both Correlation and  the Covariance establish the relationship and also \nmeasures the dependency between the two random variables, the work is similar between these two, \nin the mathematical terms, they are different from each other. \nCorrelation: It is the statistical technique that can show whether and how strongly pairs of variables \nare related. For example, height and weight are related; taller people tend to be heavier than s horter \npeople. The relationship isn't perfect. People of the same height vary in weight, and you can easily \nthink of two people you know where the shorter one is heavier than the taller one. Nonetheless, the \naverage weight of people 5'5'' is less than the average weight of people 5'6'', and their average weight \nis less than that of people 5'7'', etc. Correlation can tell you just how much of the variation in peoples' \nweights is related to their heights. \n \nCovariance: It measures the directional relationship between the returns on two assets. The positive \ncovariance means that asset returns move together  while a negative covariance means they move \ninversely. Covariance is calculated by analyzing a t-return surprises (standard  deviations from the \nexpected return)  or by multiplying the correlation between the two variables by the  standard \ndeviation of each variable. \n \n \n------------------------------------------------------------------------------------------------------------------------DATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n# Day-18Q1. What is  Levenshtein Algorithm? \nAnswer: \nLevenshtein distance is a string metric for measuring  the difference between two sequences.  The \nLevenshtein distance between two words is the minimum number of single -character edits (i.e. \ninsertions, deletions or substitutions) required to change one word into the other.", "mimetype": "text/plain", "start_char_idx": 183054, "end_char_idx": 187305, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a2807378-86ca-4366-984c-deeb7f761b80": {"__data__": {"id_": "a2807378-86ca-4366-984c-deeb7f761b80", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7346b2bf-b20f-4a61-87b0-14401e8fed02", "node_type": "1", "metadata": {}, "hash": "0def772d659ddb7a83f814be9c1dab090beaa37c0134d9b3587f1e4e6a142d27", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55bddff7-0185-4eec-843f-2b7b85d8a430", "node_type": "1", "metadata": {}, "hash": "e79b9a47d932a4b7ae357d9dc41977f84dae1339b7ff8d1344fa7c612968f56f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "insertions, deletions or substitutions) required to change one word into the other.  \nBy Mathematically, the Levenshtein distance between  the two strings a, b (of length |a| and |b| \nrespectively) is given by the leva, b( |a| , |b| ) where :  \n \n \nWhere, 1 (ai\u2260bi): This is the indicator function equal to zero  when ai\u2260bi and equal to 1 otherwise, \nand leva, b(i,j) is the distance between the first i characters of a and the first j characters of b. \nExample: \nThe Levenshtein distance between \"HONDA\" and \"HYUNDAI\" is 3, since the following three edits \nchange one into the other, and there is no way to do it with fewer than three edits:Q2. What is Soundex? \nAnswer: \nSoundex attempts to find similar names or homophones using phonetic notation. The program retains \nletters according to detailed equations, to match individual titles for purposes of ample volume \nresearch. \nSoundex phonetic algorithm : It s indexes strings depend  on their English pronunciation . The \nalgorithm is used to describe homophones, words that are pronounced the same, but spelt differently. \nSuppose we have the following sourceDF. \n \nLet\u2019s run below code and see how the soundex algorithm encodes the above words.Let\u2019s summarize the above results: \n\uf0b7 \"two\" and \"to\" both are encoded as T000 \n\uf0b7 \"break\" and \"brake\" both are encoded as B620 \n\uf0b7 \"hear\" and \"here\" both are encoded as H600 \n\uf0b7 \"free\" is encoded as F600 and \"tree\" is encoded as T600:  Encodings are similar, but word is \ndifferent \nThe Soundex algorithm was often used to compare first names that were spelt differently. \nQ3. What is Constituency parse? \nAnswer: \nA constituency parse tree breaks a text into sub-phrases. Non-terminals in the tree are types of \nphrases, the terminals are the words in the sentence, and the edges are unlabeled. For a simple \nsentence, \"John sees Bill\", a constituency parse would be: \n \nAbove approaches convert the parse tree into a sequence following a depth-first traversal to be able \nto apply sequence-to-sequence models to it. The linearized version of the above parse tree looks as \nfollows: (S (N) (VP V N)). \nQ4. What is LDA(Latent Dirichlet Allocation)? \nAnswer: \nLDA: It is used to classify text in the document to a specific topic. LDA builds a topic per document \nmodel and words per topic model, modelled as Dirichlet distributions. \n\uf0b7 Each docume nt is modeled as a  distribution of topics , and each topic is mode lled as \nmultinomial distribution of words. \n\uf0b7 LDA assumes that every chunk of text we feed into it will contain words that are somehow \nrelated. Therefore choosing the right corpus of data is crucial.\uf0b7 It also assumes documents are produced from a mixture of topics. Those topics then generate \nwords based on their probability distribution. \n The Bayesian version of P LSA is LDA. It uses Dirichlet priors for the word -topic and document-\ntopic distributions, lending itself to better generalization. \nWhat LDA give us? \nIt is a probabilistic method. For every document, the results give us a mixture of topics that make up \nthe document. To be precise, we can get probability distribution over the k topics for every document. \nEvery word in the document is attributed to the particular topic with probability given by distribution. \nThese topics themselves were defined as pr obability distributions over  vocabulary. Our results are \ntwo sets of probability distributions: \n\uf0b7 The collection of distributions of topics for each document \n\uf0b7 The collection of distributions of words for each topic.Q5.What is LSA? \nAnswer: \nLatent Semantic Analysis  (LSA): It is a theory and  the method for extract and represent s the \ncontextual usage meaning of words by statistical computation applied to large corpus of texts.  \nIt is an information retrieval technique which analyzes and identifies the pattern in an unstructured \ncollection of text and relationship between them. \nLatent Semantic Analysis itself is an unsupervised way of uncovering synonyms in a collection of \ndocuments. \nWhy LSA(Latent Semantic Analysis)? \nLSA is a technique for creating vector representation of the document. Having a vector representation \nof the document gives us a way to compare documents for their similarity by calculating the distance \nbetween vectors.", "mimetype": "text/plain", "start_char_idx": 187222, "end_char_idx": 191477, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "55bddff7-0185-4eec-843f-2b7b85d8a430": {"__data__": {"id_": "55bddff7-0185-4eec-843f-2b7b85d8a430", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a2807378-86ca-4366-984c-deeb7f761b80", "node_type": "1", "metadata": {}, "hash": "f7f6446bfab3bea7f82c40b8185d4def35494648ed7820452c95a92420dfa602", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "32d2c2b1-cca3-4db5-8526-9a479f487626", "node_type": "1", "metadata": {}, "hash": "64a7fe2053935f4bd55fe95d92cc11732eea6b4931148c8f37c3d888e66ecd5f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In turn, means we can do handy things such as classify documents to find out which \nof a set knows topics they most likely reside to. \nClassification implies we have some known topics that we  want to group documents into, and that \nyou have some labelled training data. If you're going to identify natural groupings of the documents \nwithout any labelled data, you can use clusteringQ6. What is PLSA? \nAnswer: \nPLSA stands for Probabilistic Latent Semantic Analysis, uses a probabilistic method instead of SVD \nto tackle  problem. The main idea is to find the  probabilistic model with latent topics that we \ncan generate data we observe in our document term matrix. Specifically, we want a model P(D, W) \nsuch that for any document d and word w, P(d,w) corresponds to that entry in document-term matrix. \nEach document is found in the mixture of topics, and each topic consists of the collection of words. \nPLSA adds the probabilistic spin to these assumptions: \n\uf0b7 Given document d, topic z is available in that document with the probability P(z|d) \n\uf0b7 Given the topic z, word w is drawn from z with probability P(w|z) \n \n \nThe joint probability of seeing the given document and word together is: \n \n \n \nIn the above case, P(D), P(Z|D), and P(W|Z) are the parameters of our models. P(D) can be \ndetermined directly from  corpus. P(Z|D) and the P(W|Z) are mode lled as multinomial \ndistributions and can be trained using the expectation-maximisation algorithm (EM). \n \nQ7. What is LDA2Vec? \nAnswer: \nIt is inspired by LDA, word2vec model is expanded to simulta neously learn word, document, topic \nand paragraph topic vectors. \nLda2vec is obtained by modifying the skip-gram word2vec variant. In the original skip-gram method, \nthe model is trained to predict context words based on a pivot word. In lda2vec, the pivot word vector \nand a document vector are added to obtain a context vector. This context vector is then used to predict \ncontext words.At the document level, we know how to represent the text as mixtures of topics. At the word -level, \nwe typically use d something like word2vec to obtain vector representations.  It is an extension of \nword2vec and LDA that jointly learns word, document, and topic vectors. \nHow does it work? \nIt correctly builds on top of the skip -gram model of word2vec to generate word vectors.  Neural net \nthat learns word embedding by trying to use input word to predict enclosing context words. \nWith L da2vec, other than  using the w ord vector direc tly to predict context words,  you leverage \na context vector to make the predictions. Context vector is created as the sum  of two other vectors: \nthe word vector and the document vector. \nThe same skip -gram word2vec model generates the word vector . The document vector is most  \nimpressive. It is a really weighted combination of two other components: \n\uf0b7 the document weight vector, representing the \u201cweights\u201d of each topic in a document \n\uf0b7 Topic matrix represents each topic and its corresponding vector embedding. \nTogether, a document vector and  word vector generate \u201cconte xt\u201d ve ctors for each word in  a \ndocument. lda2vec power  lies i n the fact that it  not only learns  word embeddings for words ; it \nsimultaneously learns topic representations and document representations as well.Q8. What is Expectation-Maximization Algorithm(EM)? \nAnswer: \nThe Expectation-Maximization Algorithm, in  short, EM algorithm , is an approach for maximum \nlikelihood estimation in the presence of latent variables. \nThis algorithm is an iterative approach that cycles between two modes. The first mode attempts to \npredict the missing or latent variables called the estimation-step or E-step. The second mode attempts \nto optimise the parameters of the model to explain the data best called the maximization-step or M-\nstep. \n\uf0b7 E-Step. Estimate the missing variables in the dataset. \n\uf0b7 M-Step. Maximize the parameters of the model in the presence of the data. \nThe EM algorithm can be applied quite widely, although it is perhaps most well known in machine \nlearning for use in unsupervised learning problems, such as density estimation and clustering. \nFor detail explanation of EM is, let us first consider this examp le. Say that we are in a school , and \ninterested to learn the height distribution of female and male students in the school.", "mimetype": "text/plain", "start_char_idx": 191478, "end_char_idx": 195816, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "32d2c2b1-cca3-4db5-8526-9a479f487626": {"__data__": {"id_": "32d2c2b1-cca3-4db5-8526-9a479f487626", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55bddff7-0185-4eec-843f-2b7b85d8a430", "node_type": "1", "metadata": {}, "hash": "e79b9a47d932a4b7ae357d9dc41977f84dae1339b7ff8d1344fa7c612968f56f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1c41f3b6-c094-4aea-8875-79e68c9311c2", "node_type": "1", "metadata": {}, "hash": "c263a4378f2a65c6fd470315126486ca39f935d59f46ef36f971476a45a13e28", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The most sensible \nthing to do, as we probably would agree with me, is to randomly take a sample of N students of both \ngenders, collect their height information and estimate the mean and standard deviation for male and \nfemale separately by way of maximum likelihood method. \nNow say that you are not able to know the gender of student while we collect their height information, \nand so there are two things you  have to guess/estimate: (1) whether the individual sample of hei ght \ninformation belongs to a male or a female  and (2) the parameters ( \u03bc, \u03b8) for each gender which is \nnow unobservable. This is tricky because only with the knowledge of who belongs to which group, \ncan we make reasonable estimates of the group parameters separately. Similarly, only if we know the \nparameters that define the groups, can we assign a subject p roperly. How do you  break out of this \ninfinite loop? Well,  EM algorithm just says to start with initial random guesses.Q9.What is Text classification in NLP? \nAnswer: \nText classification is also known as  text tagging or text categorization is a process of categorizing \ntext into organized groups. By using NLP, text classification can automatically analyze text and then \nassign a set of pre-defined tags or categories based on content. \nUnstructured text is everywhere on the internet, such as emails, chat conversations, websites, and the \nsocial media but it\u2019 s hard to extract value from given  data unless it\u2019s organized in a certain way. \nDoing so used to be a difficult and expensive process since it required spending time and resources \nto manually sort the data or creating handcrafted rules that are difficult to maintain. Text classifiers \nwith NLP have proven to be a great alternative to structure textual data in a fast, cost -effective, and \nscalable way. \nText classification is becoming an increasingl y important part of businesses as it allows us to get \ninsights from data and automate business processes quickly . Some of the most  common \nexamples and the use cases for automatic text classification include the following: \n\uf0b7 Sentiment Analysis: It is the process of understanding if a given text is talking positively or \nnegatively about a given subject (e.g. for brand monitoring purposes). \n\uf0b7 Topic Detection: In this, the task of identifying the theme or to pic of a piece of text (e.g. \nknow if a product review is about Ease of Use, Customer Support, or Pricing when analysing \ncustomer feedback). \n\uf0b7 Language Detection: the procedure of detecting the language of a given text (e.g. know if an \nincoming support ticket is written in English or Spanish for automatically routing tickets to \nthe appropriate team).Q10. What is Word Sense Disambiguation (WSD)? \nAnswer: \nWSD (Word Sense Disambiguation ) is a solution to the ambiguity which arises due to different \nmeaning of words in a different context. \nIn natural language processing , word sense disambiguation  (WSD) is the problem of determining \nwhich \"sense\" (meaning) of a word is activated by the use of the word in a particular context, a \nprocess which appears to be mostly unconscious in people. WSD is the natural classification problem: \nGiven a word and its possible senses, as defined by the dictionary, classify an occurrence of the word \nin the context into one or more of its sense classes. The features of the context (such as the \nneighbouring words) provide the evidence for classification. \nFor example, consider these two below sentences. \n\u201c The bank will not be accepting the cash on  Saturdays.  \u201d \n\u201c The river overflowed the bank .\u201d \nThe word \u201c bank \u201c in the given sentence refers to commercial (finance) banks, while in the second \nsentence, it refers to a riverbank. The uncertainty that arises, due to this is tough for the machine to \ndetect and resolve. Detection of change is the first issue and fixing it and displaying the correct output \nis the second issue. \n \n \n------------------------------------------------------------------------------------------------------------------Page 1 of 18 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 23Page 2 of 18 \n \nQ1.Explain Overfeat in Object detection. \nAnswer: \nOverfeat: It is a typical model of integrating object detection, localization, and classification tasks whole \ninto one convolutional neural network (CNN). The main idea is to do image classification at different \nlocations on regions of multiple scales of the image in a sliding window fashion, and second, predict \nbounding box locations with the regressor trained on top of the same convolution layers. \nThis model architecture is too similar to AlexNet. This model is trained as follows: \n \n1.", "mimetype": "text/plain", "start_char_idx": 195817, "end_char_idx": 200532, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1c41f3b6-c094-4aea-8875-79e68c9311c2": {"__data__": {"id_": "1c41f3b6-c094-4aea-8875-79e68c9311c2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "32d2c2b1-cca3-4db5-8526-9a479f487626", "node_type": "1", "metadata": {}, "hash": "64a7fe2053935f4bd55fe95d92cc11732eea6b4931148c8f37c3d888e66ecd5f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4f76dce8-3ccc-4bb1-add1-175abf8d9995", "node_type": "1", "metadata": {}, "hash": "adf17850d07c2539d1636749c476a4cf58ac17c4d051fa37cc375cbc754e0ff6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This model is trained as follows: \n \n1. Train a CNN model (identical to AlexNet) on image classification tasks. \n2. Then, we replace  top classifier layers by the  regression network and train ed it to predict object \nbounding boxes at each  spatial location and scale. R egressor is class -specific, each generated for \none class image. \n\u2022 Input: Images with classification and bounding box. \n\u2022 Output: (xleft,xright,ytop,ybottom)(xleft,xright,ytop,ybottom), 4  values in total, \nrepresenting the coordinates of the bounding box edges. \n\u2022 Loss: The regressor is trained to minimize  l2 norm between the generated bounding box \nand truth for each training example. \nAt the detection time, \n1. It Performs classification at each location using the pretrained CNN model. \n2. It Predicts object bounding boxes on all classified regions generated by the classifier. \n3. Merge bounding boxes with sufficient overlap from localization and sufficient confidence of being \nthe same object from the classifier.Page 3 of 18 \n \nQ2. What is Multipath: Multiple Probabilistic Anchor Trajectory \nHypotheses for Behavior Prediction? \nAnswer: \nIn this paper, we focus on  problem of predicting future agent states, which is the  crucial task for robot \nplanning in real-world environments. We are specifically interested in addressing this problem for self-\ndriving vehicles, application with a potentially enormous societal impact. Mainly, predicting the future \nof other agents in this domain is vital for safe, comfortable, and efficient operation. E.g., it is important \nto know whether to yield to the  vehicle if they are going to cut in front of our robot or when would be \nthe best time to add into traffic. Such future prediction requires an understanding of a static and dynamic \nworld context: road semantics ( like lane connectivity, stop lines), traffic light information s, and past \nobservations of other agents, as in below Fig. \nA fundamental aspect of the future state prediction is that it is inherently stochastic, as agents can\u2019t know \neach other\u2019s motivations. When we are driving, we can never really be sure what other drivers will do \nnext, and it is essential to consider multiple outcomes and their likelihood. \nWe seek the model of the future that can provide both (i ) a weighted, parsimonious set of discr ete \ntrajectories that covers space of likely outcomes and (ii ) a closed-form evaluation of  the likelihood of \nany trajectory. These two  attributes enable efficient reasoning in relevant planning use -cases, e.g., \nhuman-like reactions to discrete trajectory hypotheses ( e.g., yielding, following), and probabilistic \nqueries such as the expected risk of collision in a space-time region. \nThis model addresses these issues with critical insight: it employs a fixed set of trajectory anchors as the \nbasis of our modeling. This lets us factor stochastic uncertainty hierarchically: First,  intent \nuncertainty captures the uncertainty of what an agent intends to do and is encoded as a distribution over \nthe set of anchor trajectories. Second, given an intent,  control uncertainty represents our uncertainty \nover how they might achieve it. We assume control uncertainty is normally distributed at each future \ntime step [Thrun05], parameterized such that the mean corresponds to a context-specific offset from the \nanchor state, with the associated covariance capturing the unimodal aleatoric uncertainty [Kendall17]. In \nFig. Illustrates a typical scenario where there are three likely intents given the scene context, with control \nmean offset refinements respecting road geometry, and control uncertainty intuitively growing over time. \nOur trajectory anchors are modes found in our training data in state -sequence space via unsupervised \nlearning. These anchors provide templates for coarse -granularity futures for an agent and might \ncorrespond to semantic concepts like \u201cchange lanes,\u201d or \u201cslow down\u201d (although to be clear, we don\u2019t use \nany semantic concepts in our modeling).Page 4 of 18 \n \nOur complete model predicts a Gaussian m ixture model (GMM) at each time step, with the mixture \nweights (intent distribution) fixed over time. Given such a parametric distribution model, we can directly \nevaluate the likelihood of any future trajectory and have a simple way to obtain a compact, di verse \nweighted set of trajectory samples: the MAP sample from each anchor-intent. \n \nQ3. An Object detection approach using MR-CNN \nAnswer: \nMulti-Region CNN (MR-CNN): Object representation using multiple regions to capture several different \naspects of one object.Page 5 of 18 \n \nNetwork Architecture of MR-CNN \n\u2022 First, the input image goes through  Activation Maps Module, as shown above, and outputs the \nactivation map.", "mimetype": "text/plain", "start_char_idx": 200493, "end_char_idx": 205246, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4f76dce8-3ccc-4bb1-add1-175abf8d9995": {"__data__": {"id_": "4f76dce8-3ccc-4bb1-add1-175abf8d9995", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1c41f3b6-c094-4aea-8875-79e68c9311c2", "node_type": "1", "metadata": {}, "hash": "c263a4378f2a65c6fd470315126486ca39f935d59f46ef36f971476a45a13e28", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25d66321-35b9-4363-be72-76e33629616a", "node_type": "1", "metadata": {}, "hash": "7f0eaf0bb9ee21e73a307108ff16f82fe5182b63eeb404b8e76dc48e18f4cb2b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Bounding box or Region proposals candidates are generated using Selective Search. \n\u2022 For each bounding box candidate B, a set of regions {Ri}, with i=1 to k, are generated, that is why \nit is known as multi-region. More details about the choices of multiple areas are described in next \nsub-section. \n\u2022 ROI pooling is performed for each region Ri,cropped or pooled area goes through fully connected \n(FC) layers, at each Region Adaptation Module. \n\u2022 Finally, the output from all FC layers are added together to form a 1D feature vector, which is an \nobject representation of the bounding box B. \n\u2022 Here, VGG-16 ImageNet pre-trained model is used. The ma x-pooling layer after the last conv \nlayer is removed. \nQ4. Object detection using Segmentation-aware CNN \nAnswer:Page 6 of 18 \n \n \n\u2022 There are close connection s between segmentation and detectio n. And segmentation \nrelated ques are empirically known to help object detection often. \n\u2022 Two modules are added:  Activation maps module for semantic segmentation -aware \nfeatures, and  regions adaptation module for grammarly segmentation -aware \nfeature. \n\u2022 There is no additional annotation used for training here. \n\u2022 FCN is used for an activation map module. \n\u2022 The last FC7 layer channels number is changed from 4096 to 512. \n \n\u2022 The w eakly supervised training  strategy is used.  Artificial foreground c lass-specific \nsegmentation mask is created using bounding box annotations.Page 7 of 18 \n \n\u2022 More particularly, the ground truth bounding boxes of an image are projected on the spatial \ndomain of the last hidden la yer of the FCN, and the \u201dpixels\u201d that lay inside the projected boxes \nare labelled as foreground while the rest are labelled as background. \n\u2022 After training the  FCN using the mask, the last classification layer is dropped. Only the rest \nof FCN is used. \n\u2022 Though it is weakly supervised training, the foreground probabilities shown as above still carry \nsome information, as shown above. \n\u2022 The bounding box used is 1.5\u00d7 larger than the original bounding box. \n \nQ5. What is CRAFT (Object detection)? \nAnswer: \nCRAFT stands for C ascade Region-proposal-network And FasT R-CNN. It is reviewed by the \nChinese Academy of Sciences and Tsinghua University. In Faster R-CNN, region proposal \nnetwork is used to generate proposals. These proposals, after ROI pooling, are going through \nnetwork for classification. However, CRAFT is found that there is a core problem in Faster \nR-CNN: \n\u2022 In proposal generation, there is still a large proportion of background regions. The existence of many \nbackground sample causes many false positives.Page 8 of 18 \n \n \nIn CRAFT(Cascade Region-proposal-network), as shown above, another CNN (Convolutional neural \nnetwork) is added after RPN to generate fewer proposals (i.e., 300 here). Then, classification is performed \non 300 proposals and outputs about 20 first detection results. For each primitive result , refined object \ndetection is performed using one-vs-rest classification.  \nCascade Proposal Generation \n   Baseline RPN \n\u2022 An ideal proposal generator should generate as few proposal as possible while covering almost all \nobject instances. Due to resolution loss caused by CNN pooling operation and the fixed aspect ratio \nof the sliding window, RPN is weak at covering objects with extreme shapes or scales.Page 9 of 18 \n \n \n     Recall Rates (is in %), Overall is 94.87%, lower than 94.87% is bold in the text. \n\u2022 The above results are baseline RPN based on VGG_M trained using PASCAL VOC \n2007 train+val, and tested on the test set. \n\u2022 The recall rate on each object category varies a lot. Object with extreme aspect ratio and scale are \nhard to be detected, such as boat and bottle. \n \n \n \n \n \n \nProposed Cascade StructurePage 10 of 18 \n \n \n          The concatenation classification network after RPN is denoted as FRCN Net here \n\u2022 An additional classification network that comes after RPN. \n\u2022 The additional network is the 2- class detection network denoted as FRCN net in above figure. It \nuses output of RPN as training data. \n\u2022 After RPN net is trained, the 2000 first proposals of each training image are used as training data \nfor the FRCN net. \n\u2022 During training, +ve and -ve sampling are based on 0.7 IoU for negatives and below 0.3 IoU for \nnegatives, respectively.", "mimetype": "text/plain", "start_char_idx": 205248, "end_char_idx": 209554, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "25d66321-35b9-4363-be72-76e33629616a": {"__data__": {"id_": "25d66321-35b9-4363-be72-76e33629616a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4f76dce8-3ccc-4bb1-add1-175abf8d9995", "node_type": "1", "metadata": {}, "hash": "adf17850d07c2539d1636749c476a4cf58ac17c4d051fa37cc375cbc754e0ff6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e6928295-da83-4da1-95a5-2be6f0d6718b", "node_type": "1", "metadata": {}, "hash": "1feec2598a33960ee4df64dd0a855bcd2c90fb9e4a09c7ec8dd5c737df7d0bb0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 There are 2 advantages: \n\u2022 1) First,  additional FRCN net further  improves quality of the object proposals  and shrinks \nmore background regions, making proposals fit better with task requirement. \n\u2022 2) Second, proposals from multiple sources can be merged as the input of the FRCN net so that \ncomplementary information can be used. \n \n \n \n \nQ6. Explain YOLOv1 for Object Detection. \nAnswer:Page 11 of 18 \n \nYOLOv1 stands for You Look Only Once, it is reviewed by FAIR (Facebook AI Research).The network \nonly looks at the image once to detect multiple objects. \n \nBy just looking image once, the detection speed is in real-time (45 fps). Fast YOLOv1 achieves 155 fps.  \nYOLO suggests having a unified network to perform all at once. Also, an end-to-end training network can \nbe achieved. \n \nThe input image is divided into the S\u00d7S grid (S=7). If the center of the object falls into the grid cell, that \ngrid cell is responsible for detecting that object. \nEach grid cell predict B bounding boxes (B=2) and confidence scores for those boxes. These confidence \nscore reflect how confident model is that the box contains an object, i.e., any objects in the box, P(Objects). \nEach bounding box consists of five predictions: x, y, w, h, and confidence.Page 12 of 18 \n \n\u2022 The (x, y) coordinates represent center of the box relative to the bound of the grid cell. \n\u2022 The height h and width w are predicted relative to whole image. \n\u2022 The confidence represents the IOU (Intersection Over Union) between the predicted box and any \nground truth box. \nEach grid cell also predicts conditional class probabilities, P(Class|Object). (Total number of classes=20) \n \nThe output size becomes: 7\u00d77\u00d7(2\u00d75+20)=1470 \n \n \n \nNetwork Architecture of YOLOv1Page 13 of 18 \n \n \nThe model consists of 24 convolutional layers, followed by two fully connected layers. Alternating 1\u00d71 \nconvolutional layers reduce features space from preceding layers. (1\u00d71)Conv has been used in GoogLeNet \nfor reducing the number of parameters.) \nFast YOLO fewer convolutional layers (9 instead of 24) and fewer filters  in those layers. The network \npipeline is summarized like below: \n \nTherefore, we can see that the input image goes through network once and then objects can be detected. \nAnd we can have end-to-end learning.Page 14 of 18 \n \nQ7. Adversarial Examples Improve Image Recognition \nAnswer: \nAdversarial examples crafted by adding imperceptible perturbations to images can lead  to \n(ConvNets)Convolutional Neural Networks  to make wrong predictions. The existence of adversari al \nexamples not only reveal  limited generalization ability of ConvNets, but also poses security threats on \nthe real-world deployment of these models. Since the first discovery of the vulnerability of ConvNets to \nadversarial attacks, many efforts have been made to improve network robustness.Page 15 of 18 \n \nAbove Fig. : AdvProp improves image recognition . By training model  on ImageNet, AdvProp helps \nEfficientNet-B7 to achieve 85.2% accuracy on ImageNet, 52.9% mCE (mean corruption error, lower is \nbetter) on ImageNet -C, 44.7% accuracy on ImageNet -A and 26.6 % accuracy on Stylized -ImageNet, \nbeating its vanilla counterpart by 0. 7%, 6.5%, 7.0% and 4.8%, respectively. Theses sample image s are \nrandomly selected from category \u201cgoldfinch.\u201d \nIn this paper, rather than focusing on defending against adversarial examples, we shift our attention to \nleveraging adversarial examples to improve accuracy. Previous works show that training with adversarial \nexamples can enhance model generalization but are restricted to certain situations \u2014the improvement is \nonly observed either on small datasets ( e.g., MNIST) in the fully -supervised setting  [5], or on larger \ndatasets but in the semi -supervised setting [21, 22]. Meanwhile, recent works  [15, 13, 31] also suggest \nthat training with adversarial examples on large datasets,  e.g., ImageNet [23], with supervised learning \nresults in performance degradation on clean images. To summarize, it remains an open question of how \nadversarial examples can be used effectively to help vision models.", "mimetype": "text/plain", "start_char_idx": 209556, "end_char_idx": 213668, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e6928295-da83-4da1-95a5-2be6f0d6718b": {"__data__": {"id_": "e6928295-da83-4da1-95a5-2be6f0d6718b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25d66321-35b9-4363-be72-76e33629616a", "node_type": "1", "metadata": {}, "hash": "7f0eaf0bb9ee21e73a307108ff16f82fe5182b63eeb404b8e76dc48e18f4cb2b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2f5b5056-6011-4570-bd8f-163a18bd4b46", "node_type": "1", "metadata": {}, "hash": "5f42f52805e66392d9d4d6f6de98eb6ec2222727b8c15051a6639969e8862b47", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We observe all previous  methods jointly train over clean images and adversarial examples without \ndistinction, even though they should be drawn from different underlying distributions. We hypothesize \nthis distribution mismatch between fresh examples and adversarial examples is a key factor that causes \nperformance degradation in previous works. \nQ8. Advancing NLP with Cognitive Language Processing Signals \nAnswer: \nWhen reading, humans process language \u201cautomatically\u201d without reflecting on each step \u2009\u2014\u2009Humans \nstring words together into sentences, understand the meaning of spoken and written ideas, and process \nlanguage without overthinking about how the underlying cognitive process happens. This process \ngenerates cognitive signals that could potentially facilitate natural language processing tasks. \nIn recent years, collecting these signals has become increasingly accessible and less \nexpensive Papoutsaki et al. (2016); as a result, using cognitive features to improve NLP tasks has become \nmore popular. For example, researchers have proposed a rang e of work that uses eye -tracking or gaze \nsignals to improve part-of-speech tagging (Barrett et al., 2016), sentiment analysis (Mishra et al., 2017), \nnamed entity recognition Hollenstein and Zhang (2019), among other tasks. Moreover, these signals have \nbeen used successfully to regularize attention in neural networks for NLP Barrett et al. (2018). \nHowever, most previous work leverages only eye -tracking data, presumably because it is the most \naccessible form of cognitive language processing signal. Also, most state-of-the-artwork(SOTA) focused \non improving a single task with a single type of cognitiv e signal. But can cognitive processing signal s \nbring consistent improvements across modality (e.g., eye -tracking and EEG) and across various NLPPage 16 of 18 \n \ntasks? And if so,  does the combination of different sources of cognitive signals bring incremental \nimprovements? \n \nQ8. Do you have any idea how can we use NLP on News headlines to \npredict index trends? \nAnswer: \nTraders generally look up information about the company they are looking to buy shares into, for long \nand short trading. A frequent source of information is news media, which provide s updates about the \ncompany\u2019s activities, such as expansion, better or worse revenues than expected, new products and much \nmore. Depending on the news, trader can determine a bearish or bullish trend and decide to invests in it. \nWe may be able to correlate overall public sentiments towards as the company and its stock price: Apple \nis generally well -liked by the public, receives daily news coverage of its new product  and financial \nstability, and its stock has been growing steadily. These facts may be correlated but first may not cause \nthe second; we will analyze if news coverage can be used to predict the market trend. To do so, we will \nexamine the top 25 news headline s of each open-market day from 2008 to late 2015 and try to predictPage 17 of 18 \n \nthe end-of-day value of DJIA index for the same day. The theory be hind predicting same day value is \nthat traders will resp ond to news quickly and thus,  the market will adjust within an hour of release. \nTherefore in the  single business day, if the news is spread du ring business hours, its effect  may be \nmeasured before closing bell of the market. \nThe motivation behind this analysis is that humans take decision using most of the available information. \nThis usually takes several minutes to dis cover new information and take the  decision. An algorithm is \ncapable of processing gigabytes of text s from multi-source streams in second . We could potentially \nexploit this difference in order to create a trading strategy. \nNLP (Natural Language Processing ) techniques can be used to extract different information from \nheadlines such as sentiment, subjectivity, context and named entities. We obtain an indicator vector using \neach of these techniques, which allows us to train different algorithms to predict a trend. To predict these \nvalues, we can use several methods that should be well suited for this type of information: Linear \nregression, Support Vector Machine (SVM), Long Short -Term Memory (LSTM) recurrent neural \nnetwork, and a dense feed-forward (MLP) neural network. We included techniques used by Bollen et al \n(2010), which resulted in state-of-the-art(SOTA) results. We will also analyze the method used in other \nstudies with a similar context \n Information in headlines \nLatent Sentiment Analysis is done by building up a corpus of labeled words which usually connote a \ndegree of +ve or -ve sentiment. We can extend the corpus to include emoticons (i.e.", "mimetype": "text/plain", "start_char_idx": 213670, "end_char_idx": 218376, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2f5b5056-6011-4570-bd8f-163a18bd4b46": {"__data__": {"id_": "2f5b5056-6011-4570-bd8f-163a18bd4b46", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e6928295-da83-4da1-95a5-2be6f0d6718b", "node_type": "1", "metadata": {}, "hash": "1feec2598a33960ee4df64dd0a855bcd2c90fb9e4a09c7ec8dd5c737df7d0bb0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "88548a1f-7190-4cf4-bf1d-835c87aa68ac", "node_type": "1", "metadata": {}, "hash": "3e9916711b7bf3e409e8a3ee28f91130ff04f1ab35452c2668896036f46ec548", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We can extend the corpus to include emoticons (i.e. \u201c:-)\u201d ) and expression, \nwhich often correlates to strong emotions. Naive sentiment analysis consists of a lookup of each word in \nsentence to be analyzed and evaluation of a score for  sentence overall. This approach is limited by its \nknown vocabulary, which can be mitigated by context an alysis and introduction of synonyms.S econd \nlimitation is sarcasm, which is prevalent in twitter feed analysi s. The sentiment inferred by  words is \nopposed to the sentiment assumed by the user. This is mitigated by technique  detecting sarcasm which \nlead to a polarity flip of such tweets.  \nSentiment analysis gives insight on how favorable the media is and maybe the bias traders may have \ntowards buying or selling. \nAnother NLP technique which gave promising results was context analysis. This is a recent deep learning \napproach where you rely on a large corpus of text in order to learn and predict the words around a target. \nYou can then deduce in what context it  usually appears. The result is a vector representing each word. \nOther vectors with little distance are usually synonyms. The representation also allows us to do algebra, \nsuch as the famous \u201cking - man + woman = queen\u201dPage 18 of 18 \n \nLearning this representation offers t he possibility of associating a specific context with a bullish or \nbearish market.P a g e  1 | 14 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview Preparation) \n \n# Day24P a g e  2 | 14 \n \nQ1.What is STN? \nAnswer: \nSTN stands for Spatial Transformer Network for image classification. Google Deepmind briefly reviews \nit. STN helps to c rop out and scale -normalizes appropriate region, which can simplify the subsequent \nclassification task and lead to better classification performance as below: \n \n                   \n(a) Input Image with Random Translation, Scale, Rotation, and Clutter, (b) STN Applied to \nInput Image, (c) Output of STN, (d) Classification PredictionP a g e  3 | 14 \n \n \nSpatial Transformer Network (STN) \n \n \n \n\uf0b7 STN is composed of Localisation Net, Grid Generator, and Sampler. \n \nLocalization Net \n\uf0b7 With input feature map  U, with (width )W, (height) H, and C channels, outputs are  \u03b8, \nparameters of transformation T\u03b8. It can be learned  as affine transform as above. Or to be more \nconstrained, such as the used for attention which only contains scaling and translation as below:P a g e  4 | 14 \n \n \nGrid Generator \n\uf0b7 Suppose we have a regular grid G, this G is a set of points with  source coordinates (xs_i, ys_i), \nwhich act as input. \n\uf0b7 Then we apply transformation T\u03b8 on G, i.e., T\u03b8(G). \n\uf0b7 After T\u03b8(G), a set of points with destination coordinates (xt_i, yt_i) is outputted. These points \nhave been altered based on the transformation parameters. It can be Translation, Scale, Rotation \nor More Generic Warping depending on how we set \u03b8 as mentioned above. \n \nSampler \n \n\uf0b7 Based on the new set of coordinates (xt_i, yt_i), we generate a transformed output feature \nmap V. This V is translated, scaled, rotated, warped, projective transformed or affined, whatever. \n\uf0b7 It is noted that STN can be applied to not only input image but also intermediate feature maps. \nQ2.What is decaNLP? \nAnswer: \nWe introduced the Natural Language Decathlon  (decaNLP) to explore models that generalize to many \ndifferent kinds of Natural Language Processing( NLP) tasks. decaNLP  encourages single model toP a g e  5 | 14 \n \nsimultaneously optimize for 10 tasks: question answering, machine translation, document \nsummarization, semantic parsing, sentiment analysis, natural language inference (NLI), semantic role \nlabeling, relation extraction, goal-oriented dialogue, and pronoun resolution. \nWe frame all the tasks as question answering [Kumar et al., 2016] by allowing task specification to take \nthe form of a natural language question  q: all inputs have a context, quest ion, and answer (Fig.  1). \nTraditionally, NLP examples have inputs  x and output y, and the underlying task t is provided through \nexplicit modeling constraints. Meta -learning approaches include  t as additional in put. Our approach \ndoes not use the single representation for any t but instead uses natural language questions that describe \nunderlying tasks.", "mimetype": "text/plain", "start_char_idx": 218325, "end_char_idx": 222598, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "88548a1f-7190-4cf4-bf1d-835c87aa68ac": {"__data__": {"id_": "88548a1f-7190-4cf4-bf1d-835c87aa68ac", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2f5b5056-6011-4570-bd8f-163a18bd4b46", "node_type": "1", "metadata": {}, "hash": "5f42f52805e66392d9d4d6f6de98eb6ec2222727b8c15051a6639969e8862b47", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "81d1a5b1-88ac-4c37-a933-c2971cb47c7b", "node_type": "1", "metadata": {}, "hash": "6796af5feaca33fd43fda41488b4420dbc2f5e3f355ec9ae15e1f4412d82c24a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This allows single models to multitask effectively and makes them more suitable as \npre-trained models for transfer learning and meta-learning: natural language questions allow a model to \ngeneralize to entirely new tasks through different but related task descriptions.  \nThe MQAN (multitask question answering network) is designed for decaNLP and makes use of a novel \ndual attention and multi-pointer-generator decoder to multitask across all tasks in decaNLP. Our results \nrepresent that training the MQAN jointly on all tasks with the right anti-curriculum strategy can achieve \nperformance comparable to that of ten separate MQANs, each trained separately. An MQAN pretrained \non decaNLP  shows improvements in transfer learning for machine translation and named entity \nrecognition(NER), domain adaptation for sentiment analysis and natural language inference (NLI), and \nzero-shot capabilities for text classification. Though not explicitly designed for any one job, \nMQAN proves to be a robust model in a single-task setting as well, achieving state-of-the-art results on \nthe semantic parsing component of decaNLP. \nIn the above figure: Overview of the decaNLP dataset with one example from each decaNLP task in the \norder presented in Section  2. They show how the datasets were pre -processed to become questionP a g e  6 | 14 \n \nanswering problems. Answer words in red are generated by pointing to the context, in green from the \nissue, and in blue if they are made from a classifier over the output vocabulary. \nQ3.Universal Transformers \nAnswer: \nConvolutional and fully -attentional feed -forward architectures such as  the Transformer model have \nrecently emerged as viable alternatives to RNNs(Recurrent neural networks) (for the range of sequence \nmodeling tasks, notably machine translation  (JonasFaceNet2017; transformer, ). These architectures \naddress the significant shortcoming of RNNs, namely their inherently sequential computation , which \nprevents parall elization across elements of  input seque nce while still addressing vanishing gradients \nproblem (vanishing-exploding-gradient). Transformer model , in particular,  achieves this by relying \nentirely on  the self-attention mechanism  (decomposableAttnModel; lin2017structured) to compute  \nseries of context -informed vector-space representations of  symbols in its input and output, which are \nthen used to predict distributions over subsequent s ymbols as the model predicts  output sequence \nsymbol-by-symbol. Not only in  this mechanism straightfor ward to parallelize , but as each symbol\u2019s \nrepresentation is also directl y informed by all other symbols  representations, this results in an active \nglobal receptive field. This stands , in contrast, to, e.g., convolutional architecture, which typically has \nlimited receptive field. \nNotably, however, Transformer foregoes the (Recurrent Neural Network)RNN\u2019s inductive bias towards \nlearning recursive or iterative transformations. Our experiments indicate that this inductive bias may be \nimportant for several algorithmic and language understanding tasks of varying complexity: in contrast \nto models such as the Neural Turing Machine, the Neural GPU, or Stack RNNs, the Transformer does \nnot generalize well to input lengths not encountered during training.P a g e  7 | 14 \n \nIn this paper, we propose a Universal Transformer. It combines the parallelizability and global receptive \nfield of a Transformer model with the recurrent inductive bias of RNNs, which seems to be better suited \nto range of algorithmic and natural language understanding(NLU) sequence-to-sequence problems. As \nthe name implies, in contrast to  standard Transforme r, under certain assumptions , a Universal \nTransformer can be shown to be computationally universal. \nIn each step, the Universal Transformer iteratively refine its representations for all positions in sequence \nin parallel with self-attention mechanism decomposableAttnModel (); lin2017structured (), followed by \nthe recurrent transformation consisting of a depth -wise separable convolution  (xception2016 ) or a \nposition-wise fully-connected layer (see above Fig). We also extend ed the Unive rsal Transformer by \nemploying an adaptive computation time m echanism at each position in  \nsequence (graves2016adaptive), allowing model to choose the required number of refinement steps for \neach symbol dynamically. \nWhen running for  fixed number of steps, the Universa l Transformer is equivalent to  a multi-layer \nTransformer with a tied parameter  across its layers. However, another, and possibly more inform ative, \nway of characterizing Universal Transformer is as recurrent function evolving per-symbol hidden states \nin parallel, based at each step on  a sequence of the previous un known state.", "mimetype": "text/plain", "start_char_idx": 222599, "end_char_idx": 227393, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "81d1a5b1-88ac-4c37-a933-c2971cb47c7b": {"__data__": {"id_": "81d1a5b1-88ac-4c37-a933-c2971cb47c7b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88548a1f-7190-4cf4-bf1d-835c87aa68ac", "node_type": "1", "metadata": {}, "hash": "3e9916711b7bf3e409e8a3ee28f91130ff04f1ab35452c2668896036f46ec548", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "53a6498f-cbe1-40e5-8cb0-195758c1d8d5", "node_type": "1", "metadata": {}, "hash": "092dc1e3129d4b8a830610a3d26897deb56f210067fe30a547b798c6dd69f82b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In this way, it is simi lar to \narchitectures such as  Neural GPU and the Neural Turing Machine . The Universal Transformer thereby \nretains the attractive computational efficiency of original feed-forward Transformer model, but with an \nadded recurrent inductive bias of RNNs . In its adaptive form, we  show that the Universal Transformer \ncan effectively interpolate between the feed -forward, fixed -depth Transformer , and a gated, recurrent \narchitecture running for several steps depending on the input data. \nOur experimental results show that its recurrence improve results in machine translation, where Universal \nTransformer outperforms t he standard Transformer with  a same no.of parameters. In experiments o n \nseveral algorithmic tasks, Universal Transformer consistently improves significantly over LSTM(Long \nShort Term Memory) RNNs and the standard Transformer. Furthermore, on bAbI and LAMBADA text \nunderstanding data sets, the Universal Transformer achieves a new state of the art.  \nQ4. What is StarSpace in NLP? \nAnswer: \nWe introduce StarSpace, the neural embedding model that is general enough to solve a wide variety of \nproblems: \n\uf0b7 Other labeling tasks, or Text classification, e.g., sentiment classification.P a g e  8 | 14 \n \n\uf0b7 Ranking of the set of entities, e.g., a classification of web documents given a query. \n\uf0b7 Collaborative filtering -based recommendation, e.g. , recommending documents, \nvideos or music. \n\uf0b7 Content-based recommendation where content is defined with discrete features, e.g., \nwords of documents. \n\uf0b7 Embedding graphs, e.g., multi-relational graphs such as Freebase. \n\uf0b7 Learning word, sentence, or document embeddings. \nIt can be viewed as a straight -forward and efficient strong baseline for an y of these \ntasks. In experiment,  it is shown to be on par with or outperform ing several \ncompeting methods whil e being generally applicable to c ases where many of that \nmethod are not. \nThe method works by learning entity embeddings with discrete feature \nrepresentation from relations among collections of those entities directly for the task \nof ranking or classification of interest. In the general case, StarSpace embeds objects \nof different types into a vectorial embedding space; hence, the \u201cstar\u201d (\u201c*,\u201d meaning \nall types) and \u201cspace\u201d in  a name and in that familiar space compares them a gainst \neach other. It learns to rank the  set of entities, documents , or objects given a query \nentity, document, or object, where the query is not necessarily of the same type as \nthe items in the set. \nQ5. TransferTransfo in NLP \nAnswer: \nNon-goal-oriented dialogue systems (chatbots) are interesting test -bed for interactive Natural \nLanguage Processing (NLP) systems and are also directly useful in wide range of applications ranging \nfrom technical support services to entertainment. However, building intelligent conversational agent \nremains an unsolved problem in artificial intelligence (AI) research. Recently, recurrent neural \nnetwork(RNN) based models with sufficient capacity and acces s to large datasets attracted large \ninterest when first attempted.  It showed that they were capable of generating meaningful responses \nin some chit -chat settings. Still, further inquiries in the capabilities of these neural networkP a g e  9 | 14 \n \narchitectures and developments  indicated that they were limited which made communicating with them a rather \nunsatisfying experience for human beings. \nThe main issues with these architectures can be summarized as:  \n\uf0b7 (i) the wildly inconsistent outputs and the lack of a consistent personality (Li and Jurafsky, 2016), \n\uf0b7 (ii) the absence of long -term memory as these models have difficulties in taking into account \nmore than the last dialogue utterance; and \n\uf0b7 (iii) a tendency to produce consensual and generic responses that are vague and not engaging for \nhumans (Li, Monroe, and Jurafsky, 2016). \nIn this work, we take a step toward more consistent and relevant data -driven conversational agents by \nproposing a model architecture, associated training and generation algorithms which are able to \nsignificantly improve over the traditional seq -2-seq and information -retrieval baselines in terms of (i) \nrelevance of the answer (ii) coherence with a predefined personality and dialog history, and (iii) \ngrammaticality and fluency as evaluated by auto.  \n \nQ6. Wizard of Wikipedia: Knowledge-Powered Conversational Agents  \nAnswer: \nArguably, one of the  critical goals of AI and the ultimate goal of natural language research  is for the \nhuman to be able to talk to the machine. In order to get close to t his goal, machines must master the  no.", "mimetype": "text/plain", "start_char_idx": 227394, "end_char_idx": 232063, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "53a6498f-cbe1-40e5-8cb0-195758c1d8d5": {"__data__": {"id_": "53a6498f-cbe1-40e5-8cb0-195758c1d8d5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "81d1a5b1-88ac-4c37-a933-c2971cb47c7b", "node_type": "1", "metadata": {}, "hash": "6796af5feaca33fd43fda41488b4420dbc2f5e3f355ec9ae15e1f4412d82c24a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03766a7a-c507-4508-8bce-1a378a8e8272", "node_type": "1", "metadata": {}, "hash": "dba99632583edc80ab0c830e94de9ab6c46ab4cbaf51eed752dffc05eb832135", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In order to get close to t his goal, machines must master the  no. \nof skills: to be able to comprehend language, employ memory to retain and recall knowledge,  to reason \nabout these concept together, and finally output a response that both fulfills fun ctional goals in \nconversation while simultaneously being captivating to their human speaking partner. The current state -\nof-the-art(SOTA) approaches, sequence to sequence (seq2seq) models of various kinds  (Sutskever \net al., 2014; Vinyals & Le,  2015; Serban et  al., 2016; Vaswani et  al., 2017) attempt to address some of \nthese skills, but generally suffer from  inability to bring memory and knowledge to bear; as indicated by \ntheir name, they involve encoding  input sequence, providing limit ed reasoning by transforming th eir \nhidden state given input, and then decoding to the output. To converse intelligently on the given topic, \nthe speaker needs knowledge of that subject, and it is our contention here that more direct knowledge \nmemory mechanisms need to be employed. In this work, we consider setups where this can be naturally \nmeasured and built. \nWe consider the task of open-domain dialogue, where two speakers conduct open-ended chit-chat given \nan initial starting topic, and during the conversa tion, the topic can broaden or focus on related themes. \nDuring such conversations, an interlocutor can glean new information and personal points of view fromP a g e  10 | 14 \n \ntheir speaking partner, while providing themselves similarly . This is a challenging task as it req uires \nseveral components not found in many standard models. We design a set of architectures specifically for \nthis goal that combine elements of Memory Network architectures  (Sukhbaatar et al., 2015) to retrieve \nknowledge and read and condition on it, and Transformer architectures (Vaswani et al., 2017) to provide \nstate-of-the-art text representations and sequence models for generating outputs, which we term \nTransformer Memory Networks. \n \nQ7. ERASER: A Benchmark to Evaluate Rationalized NLP Models  \nAnswer: \n \nInterest has recently grown in interpretable (Natural Language Processing) NLP systems that can \nreveal how and why model make their predictions. But work in this direction has been conducted on theP a g e  11 | 14 \n \ndifferent dataset with correspond ingly different metrics, and inherent subjectiv ity in defining what \nconstitute \u2018interpretability\u2019 has translated into researcher using different metrics to quantify performance. \nWe aim ed to facilitate measurable progress on designing interpretable NLP (Natural Language \nProcessing) models by releasing the  standardized benchmark of datasets \u2014 augmented and repurposed \nfrom pre-existing corpora, and spanning the range of NLP tasks \u2014 and associated metrics for measuring \nthe quality of rati onales. We refer to this as ERASER( Evaluating Rationales And Simple English \nReasoning) benchmark. \nIn curating and releasing ERA SER we take inspiration from stickiness of  GLUE (Wang et \nal., 2019b) and SuperGLUE Wang et al. (2019a) benchmarks for evaluating progress in natural language \nunderstanding(NLU) tasks. These have enabled rapid growth in models for inclusive language \nrepresentation learning. We believe still somewhat nascent subfield of interpretable NLP (Natural \nLanguage Processing) stands to similarly benefit from the analogous collection of standardized datasets \nor tasks and metric. \n\u2018Interpretability\u2019 is the broad topic with many possible realizations Doshi-Velez and Kim (2017); Lipton \n(2016). In ERASER , we focus es specifically on  rationales, i.e., snippets of text from the  source \ndocument that support a specific categorization. All datasets contained in ERASER include such rational, \nexplicitly marked by annotators as supporting specific classifications. By definition , rationales should \nbe sufficient to categorize document , but they may  not be comprehensi ve. Therefore, for some dataset,  \nwe have collected  complete rationales, i.e., in which  all evidence supporting the classification has been \nmarked. \nHow one measures  \u2018quality\u2019 of extracted rationales will invariably depend on their intended use. With \nthis in mind, we propose the suite of metrics to evaluate rationales that might be appropriate for different \nscenarios. Widely, this includes measures of agreement with human-provided rationales and assessment \nof faithfulness. The latter aim to capture  extent to  which rationales provided by the model, in fact, \ninformed its prediction.", "mimetype": "text/plain", "start_char_idx": 231997, "end_char_idx": 236526, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "03766a7a-c507-4508-8bce-1a378a8e8272": {"__data__": {"id_": "03766a7a-c507-4508-8bce-1a378a8e8272", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "53a6498f-cbe1-40e5-8cb0-195758c1d8d5", "node_type": "1", "metadata": {}, "hash": "092dc1e3129d4b8a830610a3d26897deb56f210067fe30a547b798c6dd69f82b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7b97b026-d0b9-4ab7-be8f-0326743db861", "node_type": "1", "metadata": {}, "hash": "12063448bfc1243d484551c6f262f641ef679d787ef210c6e9013a3e42529f95", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "While we propose metrics that we t hink are reasonable, we view  a problem of designing met rics for \nevaluating rationales-especially for capturing faithfulness \u2014 as a topic for further research that we hope \nthat ERASER will help fa cilitate. We plan to revisit  metrics proposed h ere in future iterations of \nbenchmark, ideally with input from  community. Notably, while we provide a \u2018leaderboard ,\u2019 this is \nperhaps better viewed as the \u2018results board\u2019; we do not privilege any particular metric. Instead, we hope \nthat ERASER permits comparison between models that provide rationales wrt different criteria o f \ninterest.P a g e  12 | 14 \n \nQ8. End to End memory networks  \nAnswer: \nTwo grand challenges in artificial intelligence (AI) research have been to build a model \nthat can m ake multiple computational step in the service of answering the question or \ncompleting the task, and models that can describe long term dependencies in sequential \ndata. \nRecently there has been the resurgence in models of computation using explicit storage \nand a notion of attention; manipulating such storage offers an approach to both of  these \nchallenges. In, the storage is endowed with  continuous representation; reads from and \nwrites to storage, as well as other proce ssing steps, are modeled by actions of neural \nnetworks. \nIn this work, we present the  new recurrent neural netw ork (RNN) architectu re where \nrecurrence reads from  possibly large external memory mu ltiple times before outputting  \nsymbol. Our model can be considered  the continuous form of the Mem ory Network \nimplemented in. The model in that work was not easy to train via back -propagation and \nrequired supervision at each layer of a network. The continuity of model we present here \nmeans that it can be trained end -to-end from input-output pairs, and so applies to more \ntasks, i.e., tasks where such supervision is not available, like in language modeling or \nrealistically supervised question answering tasks. Our model can also be seen as version \nof RNNsearch  with multiple computational steps per output symbol. We will show \nexperimentally that  various hops over the long -term memory are crucial to excellent \nperformance of our model on these tasks, and that training the memory representation \ncan be integrated in a scalable manner into our end-to-end neural network model.P a g e  13 | 14 \n \n \nQ9. What is LinkNet? \nAnswer: \nFrom my experience, LinkNet is lightning fast, which is one of the main improvements the authors site \nin their summary. LinkNet is a relatively lightweight network with around 11.5 million parameters; \nnetworks like VGG have more than 10x that amount. \nThe structure of LinkNet is to use a series of encoder and decoder blocks to break down the image and \nbuild it back up before passing it through a few final convolutional layers. The structure of the network \nwas designed to minimize the number of parameters so that segmentation could be done in real-time. \nI performed some tests of the LinkNet architecture but did not spend too much time iterating to \nimproving the models.P a g e  14 | 14P a g e  1 | 18 \n \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 03P a g e  2 | 18 \n \n  \nQ1. How do you treat heteroscedasticity in regression? \nHeteroscedasticity means unequal scattered distribution. In regression analysis, we generally talk about \nthe heteroscedasticity in the context of the error term. Heteroscedasticity is the systematic change in the \nspread of the residuals or errors over the range of measured values. Heteroscedasticity is the problem \nbecause Ordinary least squares (OLS) regression assumes that all residuals are drawn from a random \npopulation that has a constant variance. \n  \nWhat causes Heteroscedasticity? \nHeteroscedasticity occurs more often in datasets , where we have a large range between the  largest and \nthe smallest observed values. T here are many reasons why heteroscedasticity can exist,  and a generic \nexplanation is that the error variance changes proportionally with a factor. \n \nWe can categorize Heteroscedasticity into two general types:- \n \nPure heteroscedasticity:-  It refers to cases where we specify the correct model and let us observe the \nnon-constant variance in residual plots. \n \nImpure heteroscedasticity:-  It refers to cases where you incorrectly specify the model, and that causes \nthe non-constant variance.", "mimetype": "text/plain", "start_char_idx": 236528, "end_char_idx": 240967, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7b97b026-d0b9-4ab7-be8f-0326743db861": {"__data__": {"id_": "7b97b026-d0b9-4ab7-be8f-0326743db861", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "03766a7a-c507-4508-8bce-1a378a8e8272", "node_type": "1", "metadata": {}, "hash": "dba99632583edc80ab0c830e94de9ab6c46ab4cbaf51eed752dffc05eb832135", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "76229b56-26d6-410d-81e1-abdd9cb2a72b", "node_type": "1", "metadata": {}, "hash": "6e19f8dc23a99907089cd4d222c53208407bd4c90b4e10c33bd3661838291366", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "When you leave an important variable out of a model, the omitted effect is \nabsorbed into the error term. If the effect of the omitted variable varies throughout the observed range of \ndata, it can produce the telltale signs of heteroscedasticity in the residual plots. \n \nHow to Fix Heteroscedasticity \n \nRedefining the variables: \nIf your model is a cross -sectional model that includes large differences between the sizes of the \nobservations, you can find different  ways to specify the model that reduces the impact of the sizeP a g e  3 | 18 \n \ndifferential. To do this, change the model from using the raw measure to using rates and per capita values. \nOf course, this type of model answers a slightly different kind of question. You\u2019ll n eed to determine \nwhether this approach is suitable for both your data and what you need to learn. \n \nWeighted regression: \nIt is a method that assigns each data point to a weight based on the variance of its fitted value. The idea \nis to give small weights to observations associated with higher variances to shrink their squared residuals. \nWeighted regression minimizes the sum of the weighted squared residuals. When you use the correct \nweights, heteroscedasticity is replaced by homoscedasticity. \n \nQ2. What is multicollinearity, and how do you treat it?  \n \nMulticollinearity means independent variables are highly correlated to each other. In regression \nanalysis, it's an important assumption that the regression model should not be faced with a problem of \nmulticollinearity. \nIf two explanatory variables are highly correlated, it's hard to tell, which affects the dependent variable. \nLet's say Y is regressed against X1 and X2 and where X1 and X2 are highly correlated. Then the effect \nof X1 on Y is hard to dis tinguish from the effect of X2 on Y because any increase in X1 tends to be \nassociated with an increase in X2. \nAnother way to look at the multicollinearity problem is: Individual t-test P values can be misleading. It \nmeans a P -value can be high , which means the variable is not important, even though the variable is \nimportant. \n \nCorrecting Multicollinearity: \n1) Remove one of the highly correlated independent variables from the model. If you have two or more \nfactors with a high VIF, remove one from the model. \n2) Principle Component Analysis (PCA) - It cut the number of interdependent variables to a smaller set \nof uncorrelated components. Instead of using highly correlated variables, use components in the model \nthat have eigenvalue greater than 1. \n3) Run PROC VARCLUS and choose the variable that has a minimum (1-R2) ratio within a cluster. \n4) Ridge Regression - It is a technique for analyzing multiple regression data that suffer from \nmulticollinearity. \n5) If you include an interaction term (the product of two independent variables), y ou can also reduce \nmulticollinearity by \"centering\" the variables. By \"centering ,\" it means subtracting the mean from the \nvalues of the independent variable before creating the products.P a g e  4 | 18 \n \n \nWhen is multicollinearity not a problem? \n \n1) If your goal is to predict Y from a set of X variables, then multicollinearity is not a problem. The \npredictions will still be accurate, and the overall R2 (or adjusted R2) quantifies how well the model \npredicts the Y values. \n2) Multiple dummy (binary) variables that represent a categorical variable with three or more categories. \n \n \nQ3. What is market basket analysis? How would you do it in Python? \n \nMarket basket analysis is the study of items that are purchased or grouped in a single transaction or \nmultiple, sequential transactions. Understanding the relationships and the strength of those relationships \nis valuable information that can be used to make recommendations, cross -sell, up-sell, offer coupons, \netc. \nMarket Basket Analysis is one of the key techniques used by large  retailers to uncover associations \nbetween items. It works by looking for combinations of items that occur together frequently in \ntransactions. To put it another way, it allows retailers to identify relationships between the items that \npeople buy. \n \nQ4. What is Association Analysis? Where is it used? \n \nAssociation analysis uses a set of transactions to discover rules that indicate the likely occurrence of an \nitem based on the occurrences of other items in the transaction.  \n \nThe technique of association rules  is widely used for  retail basket analysis . It can also be used for \nclassification by using rules with class labels on the right-hand side.", "mimetype": "text/plain", "start_char_idx": 240968, "end_char_idx": 245522, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "76229b56-26d6-410d-81e1-abdd9cb2a72b": {"__data__": {"id_": "76229b56-26d6-410d-81e1-abdd9cb2a72b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7b97b026-d0b9-4ab7-be8f-0326743db861", "node_type": "1", "metadata": {}, "hash": "12063448bfc1243d484551c6f262f641ef679d787ef210c6e9013a3e42529f95", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7bdf8503-85ae-4272-a72e-3ee2562fc3a0", "node_type": "1", "metadata": {}, "hash": "12c96ad2f9bc98755d6e6c9ab8381e9913086b841513b8becbbe13f531033daf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is even used for outlier detection \nwith rules indicating infrequent/abnormal association. \n \nAssociation analysis al so helps us to identify cross -selling opportunities, for example , we can use the \nrules resulting from the analysis to place associated products together in a catalog, in the supermarket, \nor the Webshop, or apply them when targeting a marketing campaign  for product B at customers who \nhave already purchased product A.P a g e  5 | 18 \n \nAssociation rules are given in the form as below: \n \nA=>B[Support,Confidence] The part before => is referred to as if (Antecedent) and the part after => is \nreferred to as then (Consequent). \nWhere A and B are sets of items in the transaction data, a and B are disjoint sets. \nComputer=>Anti\u2212virusSoftware[Support=20%,confidence=60%] Above rule says: \n1. 20% transaction show Anti-virus software is bought with purchase of a Computer \n2. 60% of customers who purchase Anti-virus software is bought with purchase of a Computer \nAn example of Association Rules * Assume there are 100 customers \n1. 10 of them bought milk, 8 bought butter and 6 bought both of them 2 .bought milk => bought \nbutter \n2. support = P(Milk & Butter) = 6/100 = 0.06 \n3. confidence = support/P(Butter) = 0.06/0.08 = 0.75 \n4. lift = confidence/P(Milk) = 0.75/0.10 = 7.5 \n \nQ5. What is KNN Classifier ? \n \nKNN means K-Nearest Neighbour Algorithm. It can be used for both classification and regression. \n \n  \nIt is the simplest machi ne learning algorithm. Also known as  lazy learning (why? Because it does not \ncreate a generalized model during the time of training, so the testing phase is very important where it \ndoes the actual job. Hence Testing is very costly - in terms of time & money). Also called an instance-\nbased or memory-based learning \nIn k-NN classification, the output is a class membership. An object is classified by a plurality vote of its \nneighbors, with the object being assigned to the class most common among its k nearest neighbors (k is \na positive integer, typically small). If k = 1, then the object is assigned to the class of that single nearest \nneighbor.P a g e  6 | 18 \n \n \nIn k-NN regression, the output is the property value for the object. This value is the average of the \nvalues of k nearest neighbors. \n All three distance measures are only valid for continuous variables. In the instance of categorical \nvariables, the Hamming distance must be used. \n  \nHow to choose the value of K:  K value is a hyperparameter which needs to choose during the time of \nmodel building \nAlso, a small number of neighbors are most flexible fit, which will have a low bias, but the high variance \nand a large number of neighbors will have a smoother decision boundary , which means lower variance \nbut higher bias. \nWe should choose an odd number if the number of classes is even. It is said the most common values are \nto be 3 & 5. \n \nQ6. What is Pipeline in sklearn ? \n \nA pipeline is what chains several steps together, once the initial exploration is done. For example, some \ncodes are meant to trans form features \u200a\u2014\u200anormalize numerical ly, or turn text into vectors, or fill up \nmissing data, and they are transformers; other codes are meant to predict variables by fitting an algorithm,P a g e  7 | 18 \n \nsuch as random forest or support vector machine, they are estimators. Pipeline chains all these together, \nwhich can then be applied to training data in block. \nExample of a pipeline that imputes data with the most frequent value of each column, and then fit a \ndecision tree classifier. \nFrom sklearn.pipeline import Pipeline \n steps = [('imputation', Imputer(missing_values='NaN', strategy = 'most_frequent', axis=0)), \n          ('clf', DecisionTreeClassifier())] \n pipeline = Pipeline(steps) \n clf = pipeline.fit(X_train,y_train)``` \n  \n Instead of fitting to one model, it can be looped over several models to find the best one.", "mimetype": "text/plain", "start_char_idx": 245523, "end_char_idx": 249428, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7bdf8503-85ae-4272-a72e-3ee2562fc3a0": {"__data__": {"id_": "7bdf8503-85ae-4272-a72e-3ee2562fc3a0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "76229b56-26d6-410d-81e1-abdd9cb2a72b", "node_type": "1", "metadata": {}, "hash": "6e19f8dc23a99907089cd4d222c53208407bd4c90b4e10c33bd3661838291366", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54ecedd6-5cd5-4e61-b6b3-f01069a7927a", "node_type": "1", "metadata": {}, "hash": "72493f70809ec8e89efd917233b82c48b98de82a64d06f57a09af8b57ea88e46", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "classifiers = [ KNeighborsClassifier(5), RandomForestClassifier(), GradientBoostingClassifier()] \nfor clf in classifiers: \nsteps = [('imputation', Imputer(missing_values='NaN', strategy = 'most_frequent', axis=0)), \n      ('clf', clf)] \n  \npipeline = Pipeline(steps) \n \nI also learned the pipeline itself can be used as an estimator and passed to cross-validation or grid \nsearch. \nfrom sklearn.model_selection import KFold \n from sklearn.model_selection import cross_val_score \n kfold = KFold(n_splits=10, random_state=seed) \n results = cross_val_score(pipeline, X_train, y_train, cv=kfold) \n print(results.mean()) \n \nQ7. What is Principal Component Analysis(PCA), and why we do? \n \nThe main idea of principal component analysis (PCA) is to reduce the dimensionality of a data set \nconsisting of many variables correlated with each other, either heavily or lightly, while retaining the \nvariation present in the dataset, up to the maximum extent. The same is done by transforming the \nvariables to a new set  of variables, which are known as the principal components (or simply, the PCs) \nand are orthogonal, ordered such that the retention of variation present in the original variables decreases \nas we move down in the order. So, in this way, the 1st principal co mponent retains maximum variation \nthat was present in the original components. The principal components are the eigenvectors of a \ncovariance matrix, and hence they are orthogonal.P a g e  8 | 18 \n \n \n \nMain important points to be considered: \n1. Normalize the data \n2. Calculate the covariance matrix \n3. Calculate the eigenvalues and eigenvectors \n4. Choosing components and forming a feature vector \n5. Forming Principal Components \n \nQ8. What is t-SNE? \n \n(t-SNE) t-Distributed Stochastic Neighbor Embedding is a non-linear dimensionality reduction algorithm \nused for exploring high -dimensional data. It maps multi -dimensional data to two or more dimensions \nsuitable for human observation. With the help of the t -SNE algorithms, you may have to plot fewer \nexploratory data analysis plots next time you work with high dimensional data. \n \nQ9. VIF(Variation Inflation Factor),Weight of Evidence & Information  \n        Value. Why and when to use? \n \nVariation Inflation Factor \nIt provides an index that measures how much the variance (the square of the estimate's standard \ndeviation) of an estimated regression coefficient is increased because of collinearity. \nVIF = 1 / (1-R-Square of j-th variable) where R2 of jth variable is the coefficient of determination of the \nmodel that includes all independent variables except the jth predictor. \nWhere R-Square of j -th variable is the multiple R2 for the regression of Xj on the other independent \nvariables (a regression that does not involve the dependent variable Y). \nIf VIF > 5, then there is a problem with multicollinearity. \n \nUnderstanding VIF \nIf the variance inflation factor of a predictor variable is 5 this means that variance for the coefficient of \nthat predictor variable is 5 times as large as it would be if that predictor variable were uncorrelated with \nthe other predictor variables. \nIn other words, if the variance inflation factor of a predictor variable is 5 this means that the standard \nerror for the coefficient of that predictor variable is 2.23 times (\u221a5 = 2.23) as large as it would be if that \npredictor variable were uncorrelated with the other predictor variables.P a g e  9 | 18 \n \nWeight of evidence (WOE) and information value (IV) are simple, yet powerful techniques to \nperform variable transformation and selection. \n  \nThe formula to create WOE and IV is  \n \n \n  \nHere is a simple table that shows how to calculate these values. \n  \nThe IV value can be used to select variables quickly.P a g e  10 | 18 \n \n \n \nQ10: How to evaluate that data does not have any outliers ? \n \nIn statistics, outliers are data points that don\u2019t belong to a certain population. It is an abnormal observation \nthat lies far away from other values. An outlier is an observation that diverges from otherwise well -\nstructured data. \nDetection: \n \nMethod 1 \u2014 Standard Deviation: In statistics, If a data distribution is approximately normal , then \nabout 68% of the data values lie within one standard deviation of the mean , and about 95% are within \ntwo standard deviations, and about 99.7% lie within three standard deviations.", "mimetype": "text/plain", "start_char_idx": 249430, "end_char_idx": 253804, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "54ecedd6-5cd5-4e61-b6b3-f01069a7927a": {"__data__": {"id_": "54ecedd6-5cd5-4e61-b6b3-f01069a7927a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7bdf8503-85ae-4272-a72e-3ee2562fc3a0", "node_type": "1", "metadata": {}, "hash": "12c96ad2f9bc98755d6e6c9ab8381e9913086b841513b8becbbe13f531033daf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed2dd69e-328d-4c19-953d-f3d9cc7a3895", "node_type": "1", "metadata": {}, "hash": "649778fa97b5796673835a3e628a1f5e34b2e2451c93b06b08037557431e0b84", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Therefore, if you have any data point that is more than 3 times the standard deviation, then those points \nare very likely to be anomalous or outliers. \n \nMethod 2 \u2014 Boxplots: Box plots are a graphical depiction of numerical data through their quantiles. It \nis a very simple but effective way to visualize outliers. Think about the lower and upper whiskers as the \nboundaries of the data distribution. Any data points that show above or below the whiskers  can be \nconsidered outliers or anomalous.P a g e  11 | 18 \n \nMethod 3 - Violin Plots: Violin plots are similar to box plots, except that they also show the probability \ndensity of the data at different values, usually smoothed by a kernel density estimator. Typically a violin \nplot will include all the data that is in a box plot: a marker for the median of the data , a box or marker \nindicating the interquartile range, and possibly all sample points if the number of samples is not too high. \n  \nMethod 4 - Scatter Plots: A scatter plot  is a type of plot or mathematical diagram using Cartesian \ncoordinates to display values for typically two variables for a set of da ta. The data are displayed as a \ncollection of points, each having the value of one variable determining the position on the horizontal axis \nand the value of the other variable determining the position on the vertical axis. \n \n  \nThe points which are very far away from the general spread of data and have a very few neighbors are \nconsidered to be outliersP a g e  12 | 18 \n \n \nQ11: What you do if there are outliers? \n \nFollowing are the approaches to handle the outliers: \n1. Drop the outlier records \n2. Assign a new value: If an outlier seems to  be due to a mistake in your data, you try imputing a \nvalue. \n3. If percentage-wise the number of outliers is less , but when we see numbers , there are several, \nthen, in that case,  dropping them might cause a loss in insight. We should group them in that \ncase and run our analysis separately on them. \n \nQ12: What are the encoding techniques you have applied with  \n          Examples ? \n \nIn many practical data science activities, the data set will contain categorical variables. These variables \nare typically stored as text values\". Since machine learning is based on mathematical equations, it would \ncause a problem when we keep categorical variables as is. \n \nLet's consider the following dataset of fruit names and their weights. \nSome of the common encoding techniques are: \nLabel encoding: In label encoding, we map each category to a number or a label. The labels chosen for \nthe categories have no relationship. So categories that have some ties or are close to each other lose such \ninformation after encoding. \nOne - hot encoding: In this method, w e map each category to a vector that contains 1 and 0 denoting \nthe presence of the feature or not. The number of vectors depends on the categories which we want to \nkeep. For high cardinality features, this method produces a lot of columns that slows down t he learning \nsignificantly. \n \n \nQ13: Tradeoff between bias and variances, the relationship between  \n         them. \n \nWhenever we discuss model prediction, it\u2019s important to understand prediction errors (bias and variance). \nThe prediction error for any machine learning algorithm can be broken down into three parts: \n\uf0b7 Bias Error \n\uf0b7 Variance Error \n\uf0b7 Irreducible ErrorP a g e  13 | 18 \n \nThe irreducible error cannot be reduced regardless of what algorithm is used. It is the error introduced \nfrom the chosen framing of the problem and may be caused by factors l ike unknown variables that \ninfluence the mapping of the input variables to the output variable. \n \nBias: Bias means that the model favo rs one result more than the others. Bias is the simplifying \nassumptions made by a model to make the target function easier to learn. The model with high bias pays \nvery little attention to the training data and oversimplifies the model. It always leads to a high error in \ntraining and test data. \n \nVariance: Variance is the amount that the estimate of the target function will change if different training \ndata was used. The m odel with high variance pays a lot of attention to training data and does not \ngeneralize on the data which it hasn\u2019t seen before. As a result, such models perform very well on training \ndata but have high error rates on test data. \n  \nSo, the end goal is to come up with a model that balances both Bias and Variance. This is called  Bias \nVariance Trade-off.", "mimetype": "text/plain", "start_char_idx": 253807, "end_char_idx": 258314, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ed2dd69e-328d-4c19-953d-f3d9cc7a3895": {"__data__": {"id_": "ed2dd69e-328d-4c19-953d-f3d9cc7a3895", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54ecedd6-5cd5-4e61-b6b3-f01069a7927a", "node_type": "1", "metadata": {}, "hash": "72493f70809ec8e89efd917233b82c48b98de82a64d06f57a09af8b57ea88e46", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c21972ca-1389-4f54-be2a-b2c8854b1e56", "node_type": "1", "metadata": {}, "hash": "217ae0cac9917bf4737fd6b69ea9226d86cc180c1993aa93941caf9e223fd349", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This is called  Bias \nVariance Trade-off. To build a good model, we need to find a good balance between bias and variance \nsuch that it minimizes the total error. \n \nQ14: What is the difference between Type 1 and Type 2 error and  \n          severity of the error?    \n \nType I Error \nA Type I error is often referred to as a \u201cfalse positive\" and is the incorrect rejection of the true null \nhypothesis in favor of the alternative. \nIn the example above, the null hypothesis refers to the natural state of things or the absence of the tested \neffect or phenomenon, i.e., stating that the patient is HIV negative. The alternative hypothesis states that \nthe patient is HIV positive. Many medical tests will have the disease they are testing for as the alternative \nhypothesis and the lack of that disease as the null hypothesis.P a g e  14 | 18 \n \nA Type I error would thus occur when the patient doesn\u2019t have the virus, but the test shows that they do. \nIn other words, the test incorrectly rejects the true null hypothesis that the patient is HIV negative. \n \nType II Error \nA Type II error is the inverse of a Type I error and is the false acceptance of a null hypothesis that is not \ntrue, i.e., a false negative. A Type II error would en tail the test telling the patient they are free of HIV \nwhen they are not. \n \nConsidering this HIV example, which error type do you think is more acceptable? In other words, would \nyou rather have a test that was more prone to Type I or Types II error? With HIV, the momentary stress \nof a false positive is likely better than feeling relieved at a false negative and then failing to take steps to \ntreat the disease. Pregnancy tests, blood tests, and any diagnostic tool that has serious consequences for \nthe health of a patient are usually overly sensitive for this reason \u2013 they should err on the side of a false \npositive. \n \nBut in most fields of science, Type II errors are seen as less serious than Type I errors. With the Type II \nerror, a chance to reject the null hypothesis was lost, and no conclusion is inferred from a non -rejected \nnull. But the Type I error is more serious  because you have wrongly rejected the null hypothesis and \nultimately made a claim that is not true. In science, finding a  phenomenon where there is none is more \negregious than failing to find a phenomenon where there is.  \n \nQ15: What is binomial distribution and polynomial distribution? \n \nBinomial Distribution:  A binomial distribution can be thought of as simply the probability of a \nSUCCESS or FAILURE outcome in an experiment or survey that is repeated multiple times. The \nbinomial is a type of distribution that has two possible outcomes (the  prefix \u201cbi\u201d means two, or twice). \nFor example, a coin toss has only two possible outcomes: heads or tails, and taking a test could have two \npossible outcomes: pass or fail. \nMultimonial/Polynomial Distribution:  Multi or Poly means many. In probability theor y, the \nmultinomial distribution is a generalization of the binomial distribution. For example, it models the \nprobability of counts of each side for rolling a k-sided die n times. For n independent trials each of which \nleads to success for exactly one of k categories, with each category having a given fixed success \nprobability, the multinomial distribution gives the probability of any particular combination of numbers \nof successes for the various categoriesP a g e  15 | 18 \n \nQ16: What is the  Mean Median Mode standard deviation for the       \n         sample and population?  \n \nMean It is an important technique in statistics. Arithmetic Mean can also be called an average. It is the \nnumber of the quantity obtained by summing two or more numbers/variables and then dividing the sum \nby the number of numbers/variables. \n \nMode The mode is also one of the types for finding the average. A mode is a number that occurs most \nfrequently in a group of numbers. Some series might not have any mode; some might have two modes , \nwhich is called a bimodal series. \nIn the study of statistics, the three most common \u2018averages\u2019 in statistics are mean, median, and mode. \n \nMedian is also a way of finding the average of a group of data points. It\u2019s the middle number of a set of \nnumbers. There are two possibilities, the data points can be an  odd number group, or it can be an even \nnumber group. \nIf the group is odd, arrange the numbers in the group from smallest to largest. The median will be the \none which is exactly sitting in the middle, with an equal number on either side of it.", "mimetype": "text/plain", "start_char_idx": 258273, "end_char_idx": 262820, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c21972ca-1389-4f54-be2a-b2c8854b1e56": {"__data__": {"id_": "c21972ca-1389-4f54-be2a-b2c8854b1e56", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed2dd69e-328d-4c19-953d-f3d9cc7a3895", "node_type": "1", "metadata": {}, "hash": "649778fa97b5796673835a3e628a1f5e34b2e2451c93b06b08037557431e0b84", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "21b2ae83-3834-4907-afb4-0986b06ee2e9", "node_type": "1", "metadata": {}, "hash": "499cebe936efd6cbf323aabea0788d39e65e11d24cfa77673908aef31fbe6a2e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "If the group is even, \narrange the numbers in order and pick the two middle numbers and add them then divide by 2. It will be \nthe median number of that set. \n \nStandard Deviation (Sigma) Standard Deviation is a measure of how much your data is spread out in \nstatistics. \n \nQ17: What is Mean Absolute Error ? \n \nWhat is Absolute Error?  Absolute Error is the amount of error in your measurements. It is the \ndifference between the measured value and the \u201ctrue\u201d value. For example, if a scale states 90 pounds , \nbut you know your true weight is 8 9 pounds, then the scale has an absolute error of 90 lbs \u2013 89 lbs = 1 \nlbs. \nThis can be caused by your scale , not measuring the exact amount you are trying to measure. For \nexample, your scale may be accurate to the nearest pound. If you weigh 89.6 lbs, the s cale may \u201cround \nup\u201d and give you 90 lbs. In this case the absolute error is 90 lbs \u2013 89.6 lbs = .4 lbs. \n \nMean Absolute Error The Mean Absolute Error(MAE) is the average of all absolute errors. The formula \nis: mean absolute errorP a g e  16 | 18 \n \nWhere, \nn = the number of errors, \u03a3 = summation symbol (which means \u201cadd them all up\u201d), |xi \u2013 x| = the absolute \nerrors. The formula may look a little daunting, but the steps are easy: \nFind all of your absolute errors, xi \u2013 x. Add them all up. Divide by the number of errors. For example, if \nyou had 10 measurements, divide by 10. \n \nQ18: What is the difference between long data and wide data? \n \nThere are many different ways that you can present the same dataset to the world. Let's take a look at \none of the most important and fundamental distinctions, whether a dataset is wide or long. \nThe difference between wide and long datasets boils down to whether we prefer to have more columns \nin our dataset or more rows. \n \nWide Data A dataset that emphasizes putting additional data about a single subject in columns is called \na wide dataset because, as we add more columns, the dataset becomes wider. \n \nLong Data Similarly, a dataset that emphasizes including additional data about a subject in rows is called \na long dataset because, as we add more rows, the dataset becomes longer. It's important to point out that \nthere's nothing inherently good or bad about wide or long data. \nIn the world of data wrangling, we sometimes need to make a long dataset wider, and we sometimes need \nto make a wide dataset longer. However, it is true that, as a general rule, data scientists who embrace the \nconcept of tidy data usually prefer longer datasets over wider ones. \n \nQ19: What are the data normalization method you have applied, and \nwhy? \n \nNormalization is a technique often applied as part of data preparation for machine learning. The goal of \nnormalization is to change the values of numeric columns in the dataset to a common scale, without \ndistorting differences in the ranges of values. For machine learning, every dataset does not require \nnormalization. It is required only when features have different ranges. \nIn simple words, when multiple attributes are there , but attributes have values on different scales, this \nmay lead to poor data models while performing data mining operations. So they are normalized to bring \nall the attributes on the same scale, usually something between (0,1). \nIt is not always a good idea to normalize the data since we might lose information about maximum and \nminimum values. Sometimes it is a good idea to do so. \nFor example, ML algorithms such as Linear Regression or Support Vector Machines typically converge \nfaster on normalized data. But on algorithms like K-means or K Nearest Neighbours, normalization couldP a g e  17 | 18 \n \nbe a good choice or a bad depending on the use case since the dista nce between the points plays a key \nrole here. \n  \n \nTypes of Normalisation : \n1 Min-Max Normalization: In most cases, standardization is used feature-wise \n 2 Z-score normalization In this technique, values are normalized based on a mean and standard \ndeviation of the data \n \n \nv\u2019, v is new and old of each entry in data respectively. \u03c3A, A is the standard deviation and mean of A \nrespectively.", "mimetype": "text/plain", "start_char_idx": 262821, "end_char_idx": 266941, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "21b2ae83-3834-4907-afb4-0986b06ee2e9": {"__data__": {"id_": "21b2ae83-3834-4907-afb4-0986b06ee2e9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c21972ca-1389-4f54-be2a-b2c8854b1e56", "node_type": "1", "metadata": {}, "hash": "217ae0cac9917bf4737fd6b69ea9226d86cc180c1993aa93941caf9e223fd349", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e217dbf9-60c7-412a-a252-ea141a98edad", "node_type": "1", "metadata": {}, "hash": "043fd615c4d02b35d7ab546dfd0d3d5aaf7c7f832b0e708b891009cdc92522fe", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u03c3A, A is the standard deviation and mean of A \nrespectively. \nstandardization (or Z-score normalization) is that the features will be rescaled so that they\u2019ll have the \nproperties of a standard normal distribution with \n\u03bc=0 and \u03c3=1 where \u03bc is the mean (average) and \u03c3 is the standard deviation from the mean; standard \nscores (also called z scores) of the samples are calculated as follows: \nz=(x\u2212\u03bc)/\u03c3P a g e  18 | 18 \n \nQ20: What is the difference between normalization  and  \n          Standardization with example? \n \nIn ML, every practitioner knows that feature scaling is an important issue. The two most discussed \nscaling methods are Normalization and Standardization. Normalization typically means it rescales the \nvalues into a range of [0,1]. \nIt is an alternative approach to Z -score normalization (or standardization) is the so -called Min -Max \nscaling (often also called \u201cnormalization\u201d - a common cause for ambiguities). In this approach, the data \nis scaled to a fixed range - usually 0 to 1. Scikit-Learn provides a transformer called MinMaxScaler for \nthis. A Min-Max scaling is typically done via the following equation: \nXnorm = X-Xmin/Xmax-Xmin \nExample with sample data: Before Normalization: Attribute Price in Dollars Storage Space Camera \n\uf0b7 Attribute Price in Dollars Storage Space Camera \n\uf0b7 Mobile 1 250 16 12 \n\uf0b7 Mobile 2 200 16 8 \n\uf0b7 Mobile 3 300 32 16 \n\uf0b7 Mobile 4 275 32 8 \n\uf0b7 Mobile 5 225 16 16 \nAfter Normalization: (Values ranges from 0-1 which is working as expected) \n\uf0b7 Attribute Price in Dollars Storage Space Camera \n\uf0b7 Mobile 1 0.5 0 0.5 \n\uf0b7 Mobile 2 0 0 0 \n\uf0b7 Mobile 3 1 1 1 \n\uf0b7 Mobile 4 0.75 1 0 \n\uf0b7 Mobile 5 0.25 0 1 \nStandardization (or Z -score normalization) typically means rescales data to have a mean of 0 and a \nstandard deviation of 1 (unit variance) Formula: Z or X_new=(x\u2212\u03bc)/\u03c3 where \u03bc is the mean (average), \nand \u03c3 is the standard deviation from the mean; standard scores (also called z scores) Scikit -Learn \nprovides a transformer called StandardScaler for standardization Example: Let\u2019s take an approximately \nnormally distributed set of numbers: 1, 2, 2, 3, 3, 3, 4, 4, and 5. Its mean is 3, and its standard deviation: \n1.22. Now, let\u2019s subtract the mean from all data points. we get a new data set of: -2, -1, -1, 0, 0, 0, 1, 1, \nand 2. Now, let\u2019s divide each data point by 1.22. As you can see in the picture below, we get: -1.6, -0.82, \n-0.82, 0, 0, 0, 0.82, 0.82, and 1.63DATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 07Q1. What is the process to make data stationery from non- \n       stationary in time series? \nAns: \nThe two most common ways to make a non-stationary time series stationary are: \n\uf0b7 Differencing \n\uf0b7 Transforming \n \nLet us look at some details for each of them: \n \nDifferencing: \nTo make your series stationary, you take a difference between the data points. So let us say, your \noriginal time series was: \n \nX1, X2, X3,...........Xn \n \nYour series with a difference of degree 1 becomes: \n \n(X2 - X1, X3 - X2, X4 - X3,.......Xn - X(n-1) \n \nOnce, you make the difference, plot the series and see if there is any improvement in the ACF curve. \nIf not, you can try a second or even a third -order differencing. Remember, the more you difference, \nthe more complicated your analysis is becoming.Transforming: \nIf we cannot make a time series stationary, you can try out transforming the variables. Log transform \nis probably the most com monly used tran sformation if we  see the diverging time series.", "mimetype": "text/plain", "start_char_idx": 266881, "end_char_idx": 270385, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e217dbf9-60c7-412a-a252-ea141a98edad": {"__data__": {"id_": "e217dbf9-60c7-412a-a252-ea141a98edad", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "21b2ae83-3834-4907-afb4-0986b06ee2e9", "node_type": "1", "metadata": {}, "hash": "499cebe936efd6cbf323aabea0788d39e65e11d24cfa77673908aef31fbe6a2e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "076c1e04-b35c-4a6e-902b-680056f01004", "node_type": "1", "metadata": {}, "hash": "514273cd3a15c1d7bbddf33814b2cc9f6a8d5dd930b70e780f1b2b0b46807db5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "However, it is suggested that you use transformation only in case differencing is not working. \n \n \nQ2. What is the process to check stationary data ? \n \nAns: \n \nStationary series: It is one in which the properties \u2013 mean, variance and covariance, do not vary \nwith time. \n \n \n \nLet us get an idea with these three plots: \n \n\uf0b7 In the first plot, we can see that the mean varies (increases) with time, which results in an \nupward trend. This is the non-stationary series.  \nFor the series classification as stationary, it should not exhibit the trend. \n\uf0b7 Moving on to the second plot, we do not see a trend in the series, but the variance of the series \nis a function of time. As mentioned previously, a stationary series must have a constant \nvariance.\uf0b7 If we look at the third plot, the spread becomes closer, as the time increases, which implies that \ncovariance is a function of time. \n \nThese three plots refer to the non-stationary time series. Now give your attention to fourth: \n \n \n \nIn this case, Mean, Variance and Covariance are constant with time. This is how a stationary time \nseries looks like. \n \nMost of the statistical models require the series to be stationary to make an effective and precise \nprediction. \n \nThe various process you can use to find out your data is stationary or not by the following terms: \n1. Visual Test \n2. Statistical Test \n3. ADF(Augmented Dickey-Fuller) Test \n4. KPSS(Kwiatkowski-Phillips-Schmidt-Shin) Test \nQ3. What are ACF and PACF?. \nAns: \nACF is a (complete) auto-correlation function which gives us the values of the auto-correlation of \nany series with lagged values. We plot these values along with a confidence band.We have an ACF \nplot. In simple terms, it describes how well the present value of the series is related to its past \nvalues. A time series can have components like the trend, seasonality, cyclic and residual. ACF \nconsiders all the components while finding correlations; hence, it\u2019s a \u2018complete auto-correlation \nplot\u2019. \nPACF is a partial autocorrelation function. Instead of finding correlations of present with lags like \nACF, it finds the correlations of the residuals with the next lag value thus \u2018partial\u2019 and not \n\u2018complete\u2019 as we remove already found variations before we find next correlation. So if there are \nany hidden pieces of information in the residual which can be modelled by next lag, we might get a \ngood correlation, and we\u2019ll keep that next lag as a feature while modelling. Remember, whilemodelling we don\u2019t want to keep too many correlated features, as that it can create multicollinearity \nissues. Hence we need to retain only relevant features. \n        \nQ4. What do you understand by the trend of data? \nAns: \nA general systematic linear or (most often) nonlinear component that changes over time and does not \nrepeat. \nThere are different approaches to understanding trend. A positive trend means it is likely that \ngrowth continues. Let's illustrate this with a simple example: \n         \nHmm, this looks like there is a trend. To build up confidence, let's add a linear regression for this \ngraph: \n           \nGreat, now it\u2019s clear theirs a trend in the graph by adding Linear Regression.Q5. What is the Augmented Dickey-Fuller Test? \nAns: \nThe Dickey-Fuller test: It is one of the most popular statistical tests. It is used to determine the \npresence of unit root in a series, and hence help us to understand if the series is stationary or not. \nThe null and alternate hypothesis for this test is: \nNull Hypothesis: The series has a unit root (value of a =1) \nAlternate Hypothesis: The series has no unit root. \nIf we fail to reject the null hypothesis, we can say that the series is non-stationary. This means that \nthe series can be linear or difference stationary. \n \n \n \nQ6. What is AIC and BIC into time series? \nAns: \nAkaike\u2019s information criterion (AIC) compares the quality of a set of statistical models to each \nother. For example, you might be interested in what variables contribute to low socioeconomic \nstatus and how the variables contribute to that status. Let\u2019s say you create several regression models \nfor various factors like education, family size, or disability status; The AIC will take each model \nand rank them from best to worst.", "mimetype": "text/plain", "start_char_idx": 270388, "end_char_idx": 274643, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "076c1e04-b35c-4a6e-902b-680056f01004": {"__data__": {"id_": "076c1e04-b35c-4a6e-902b-680056f01004", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e217dbf9-60c7-412a-a252-ea141a98edad", "node_type": "1", "metadata": {}, "hash": "043fd615c4d02b35d7ab546dfd0d3d5aaf7c7f832b0e708b891009cdc92522fe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e14964cb-028f-4385-8537-37b90a5f3080", "node_type": "1", "metadata": {}, "hash": "f1fd255e80a444c8a87bee3a92b6a79e2310b58b4de4cc5a8d7fa3cd6f34d4b5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The \u201cbest\u201d model will be the one that neither under-fits nor over-\nfits.The Bayesian Information Criterion (BIC) can be defined as:  \nk log(n)- 2log(L(\u03b8\u0302)). \nHere n is the sample size. \nK is the number of parameters which your model estimates. \n\u03b8 is the set of all parameter. \nL (\u03b8\u0302) represents the likelihood of the model tested, when evaluated at maximum likelihood values \nof \u03b8. \nQ7. What are the components of the Time -Series? \nAns: \nTime series analysis: It provides a body of techniques to understand a dataset better. The most \nuseful one is the decomposition of the time series into four constituent parts- \n1. Level- The baseline value for the series if it were a straight line. \n2. Trend - The optional and linear, increasing or decreasing behaviour of series over time. \n3. Seasonality - Optional repeated patterns /cycles of behaviour over time. \n4. Noise - The optional variability in the observations that cannot be explained by the model. \n \nQ8. What is Time Series Analysis? \nAns: \nTime series analysis: It involves developing models that best capture or describe an observed time \nseries to understand the underlying cause. This study seeks the \u201cwhy\u201d behind the time-series \ndatasets. This involves making assumptions about the form of data and decomposing time-series \ninto the constitution component. \n \nQuality of descriptive model is determined by how well it describes all available data and the \ninterpretation it provides to inform the problem domain better.Q9. Give some examples of the Time-Series forecast? \nAns: \nThere is almost an endless supply of the time series forecasting problems. Below are ten examples \nfrom a range of industries to make the notions of time series analysis and forecasting more \nconcrete. \n1. Forecasting the corn yield in tons by the state each year. \n2. Forecasting whether an EEG trace in seconds indicates a patient is having a seizure or not. \n3. Forecasting the closing price of stocks every day. \n4. Forecasting the birth rates at all hospitals in the city every year. \n5. Forecasting product sales in the units sold each day for the store. \n6. Forecasting the number of passengers through the train station each day. \n7. Forecasting unemployment for a state each quarter. \n8. Forecasting the utilisation demand on the server every hour. \n9. Forecasting the size of the rabbit populations in the state each breeding season. \n10. Forecasting the average price of gasoline in a city each day. \n \nQ10. What are the techniques of Forecasting? \nAns: \nThere are so many statistical techniques available for time series forecast however we have found a \nfew effective ones which are listed below: \n\uf0b7 Simple Moving Average (SMA) \n\uf0b7 Exponential Smoothing (SES) \n\uf0b7 Autoregressive Integration Moving Average (ARIMA) \n \nQ11. What is the Moving Average? \nAns: \nThe moving average model is probably the most naive approach to time series modelling. This model \nstates that the next observation is the mean of all past observations. \nAlthough simple, this model might be surprisingly good, and it represents a good starting point. \nOtherwise, the moving average can be used to identify interesting trends in the data. We can define \na window to apply the moving average model to smooth the time series and highlight different trends.Example of a moving average on a 24h window \nIn the plot above, we applied the moving average model to a 24h window. The green \nline smoothed the time series, and we can see that there are two peaks in the 24h period. \nThe longer the window, the smoother the trend will be.  \nBelow is an example of moving average on a smaller window. \n \n \nExample of a moving average on a 12h windowQ12. What is  Exponential smoothing? \nAns: \nExponential smoothing uses similar logic to moving average, but this time, different decreasing \nweight is assigned to each observation. We can also say, less importance is given to the \nobservations as we move further from the present. \nMathematically, exponential smoothing is expressed as: \n \n \nHere, alpha is the smoothing factor which takes values between 0 to 1. It determines how fast the \nweight will decrease for the previous observations. \n \n \nFrom the above plot, the dark blue line represents the exponential smoothing of the time series \nusing a smoothing factor of 0.3, and the orange line uses a smoothing factor of 0.05. As we can see, \nthe smaller the smoothing factor, the smoother the time series will be.", "mimetype": "text/plain", "start_char_idx": 274644, "end_char_idx": 279075, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e14964cb-028f-4385-8537-37b90a5f3080": {"__data__": {"id_": "e14964cb-028f-4385-8537-37b90a5f3080", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "076c1e04-b35c-4a6e-902b-680056f01004", "node_type": "1", "metadata": {}, "hash": "514273cd3a15c1d7bbddf33814b2cc9f6a8d5dd930b70e780f1b2b0b46807db5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "de0df7ac-b806-4fdb-964b-1b6fbcff1ae7", "node_type": "1", "metadata": {}, "hash": "0663878e38b833bf02c1ae69fad21f6764cf7215c563d9f9ef81823562d40711", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Because as smoothing factor \napproaches 0, we approach to the moving average model \n------------------------------------------------------------------------------------------------------------------------P a g e  1 | 16 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview Preparation) \n \n# Day29P a g e  2 | 16 \n \nQ1. What is SuperGlue? \nAnswer: \n \n \nSuperGlue is a  Learning Feature Matching with Graph Neural Networks . Correspondences between \npoints in imag es are essential for estimating 3D structure and camera poses in geometric computer \nvision(OpenCV) tasks such as SLAM(Simultaneous Localization and Mapping ) and SfM( Structure-\nfrom-Motion). Such correspondences are generally estimat ed by matching local fea tures, the  process \ncalled as data association. Broad viewpoint and lighting changes, occlusion, blur, and lack of texture are \nfactors that make 2D-to-2D data association particularly challenging. \nIn this paper, we present new way of thinking about feature matching problem. Instead of learning better \ntask-agnostic local features followed by simple matching heuristics and tricks, we propose to determine \nthe matching process from pre-existing local features using a novel neural architecture called SuperGlue. \nIn the context of SLAM, which typically decomposes the problem into the visual feature extraction front-\nend and the bundle adjustment or pose s estimation back-end, o ur network lies directly in middle \n\u2013 SuperGlue is a learnable middle-end (see in above Figure). \nIn this work, learning feature matching is viewed as finding partial assignment between two sets of local \nfeature. We revisit classical graph-based strategy of matching by solving the linear assignment problem, \nwhich, when relaxed to the optimal transport problem, can be solved differentiably. The cost function of \nthis optimization is predicted by a GNN(Graph Neural Network). Inspired by success of the Transformer, \nit uses self - (intra-image) and cross - (inter-image) attention to leverag ing both spatial relationships ofP a g e  3 | 16 \n \nkeypoints and their visual appearance. This formulation enforces assignment structure of the prediction \nwhile enabling cost to learn complex priors, handling occlusion , and non -repeatable keypoints. Our \nmethod is trained end-to-end from images pair \u2013 we learn priors for pose estimation from large annotated \ndataset, enabling SuperGlue to reason about 3D scen e and assignment. Our work can be applied to a \nvariety of multiple -view geometry problems that require high -quality features correspondences (see in \nbelow Figure). \nWe show superiority of SuperGlue compared to both handcrafted matches and learned inlier cla ssifiers. \nWhen combined with SuperPoint, a deep front-end, SuperGlue advances the state-of-the-art on the tasks \nof indoor and outdoor pose estimation and paves the way towards end-to-end deep SLAM. \n \n \n \nQ2. What is MixNMatch? \nAnswer:P a g e  4 | 16 \n \nIt is a Multifactor Disentanglement and Encoding for Conditional Image Generation. Consider the real \nimage of the yellow bird in the above Fig, First column. What would a bird look like in a different \nbackground, say that of a duck? How about in the different texture, perhaps that of the rainbow \ntextured bird in the second column? What if we wanted to keep its texture but changes its shape to that \nof rainbow bird and background and pose to that of duck, as in the 3rd column? How about sampling \nshape, pose, texture, and experience from 4 different reference images and combining them to create \nentirely new image (last column) \nProblem. \nWhile research in conditional image generation has made tremendous progress , no actual work can \nsimultaneously disentang le background, object pose , shape, and  texture with minimal supervision, so \nthat these factors can be combined from  multiple real images  for fine -grained controllable image \ngenerations. Learning disentangled representations with minimal sup ervision is the extremely \nchallenging problem since the underlying factors that give rise to the data are often highly correlated and \nintertwined. Work that disentangles two such factors, by taking as input 2 reference images, e.g., one for \nappearance and another for pose, do exist  [huang-eccv2018, joo-cvpr18, lee-eccv18, lorenz-\ncvpr2019, xiao-iccv2019], but they cannot disentangle other factor such as pose vs. shape or foreground \nvs. background appearance.", "mimetype": "text/plain", "start_char_idx": 279076, "end_char_idx": 283524, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "de0df7ac-b806-4fdb-964b-1b6fbcff1ae7": {"__data__": {"id_": "de0df7ac-b806-4fdb-964b-1b6fbcff1ae7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e14964cb-028f-4385-8537-37b90a5f3080", "node_type": "1", "metadata": {}, "hash": "f1fd255e80a444c8a87bee3a92b6a79e2310b58b4de4cc5a8d7fa3cd6f34d4b5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6904bdec-6926-4c17-b0d9-4b23688e9672", "node_type": "1", "metadata": {}, "hash": "e423b7acb5b925ac5601bf5fc9626132e2ad56deac66f383808af5dcabec9416", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "shape or foreground \nvs. background appearance. Since only two factors can be controlled, these approaches cannot arbitrarily \nchange,e.g., the object\u2019s background, shape, and texture, while keeping its pose the same. Others require \nintense supervision in the form of keypoint or pose or mask annotations [peng-iccv2017, Balakrishnan-\ncvpr2018, ma-cvpr2018, esser-cvpr2018], which limit their scalability and still fall short of disentangling \nall of four factors outlined above. \nOur proposed conditional generative model,  MixNMatch, aim  to fill this void. MixNMatch learns to \ndisentangle and encode background, object pose, shape, and texture latent factors from the real images, \nand importantly, does so with minimal human supervision. This allows, e.g., each factor to be extracted \nfrom a different actual image, and then combined for mix-and-match image generation; see in above fig. \nDuring training, MixNMatch only requires a loose bounding box around the object to the model \nbackground but requires no other supervision for modeling the object\u2019s pose, shape, and texture.P a g e  5 | 16 \n \n \nQ3. FAN: Feature Adaptation Network  \nAnswer: \n \n \nFigure: Visual results on four datasets. Vertically we show input in row first and our results in row third. \nFor LFW and SCface datasets, we show the ground truth and gallery images in second row, respectively. \nFor WIDER FACE and QMUL-SurFace datasets which do not have ground truth high-resolution images, \nwe compare with two state -of-the-art(SOTA) methods: Bulat et al.  [bulatyang2018learn] and \nFSRGAN [CT-FSRNet-2018] in row 2, respectively. \nIt is used for Surveillance Face Recognition and Normalization. Surveillance Face Recognition (FR) is \na challenge and a significant problem yet less studied. The performance on conventional benchmarks \nsuch as LFW  [LFWTech] and IJB-A have been greatly improved by state-of-the-art (SOTA) (Face \nRecognition(FR) methods [wang2018cosface, wen2016discriminative, deng2019arcface], which still \nsuffer when applied to surveillance Face Recognition(FR). One intuitive approach is to perform Face \nSuper-Resolution (FSR) on surveillance face to enhance facial details. However, existing Face Super-\nResolution(FSR) methods are problematic to handle surveillance faces, because they usually ignore \nthe identity information and require to paired training data. Preserving identity information is more \ncrucial for surveillance of all face than recovering other information, e.g., background, Pose, \nIllumination, Expression (PIE). \nIn this work, we study surveillance face recognition (FR) and norma lization. Specifically, given the \nsurveillance face image, we aim to learn robust identity features for Face recognition(FR). Meanwhile, \nthe feature  are used to generate a normalized face with enhanced facial details and neutral PIE. Our \nnormalization is performed mainly on the aspect of the resolution. While sharing same goal as traditional \nSR, it differs in removing the pixel-to-pixel correspondence between original and super-resolved images, \nas required by conventional SR. Therefore, we term it as face  normalization. For  same reason, weP a g e  6 | 16 \n \ncompare ours to FSR  instead of prior normalization methods operating on pose  or expression. To the \nbest of our knowledge, this is a first work to study surveillance face normalization. \nWe propose the  novel Feature Adaptation Network (FAN) to jointly perform face recognition and \nnormalization, which has 3 advantages over conventional FSR. i) Our joint learning scheme can benefit \neach other , while most  FSR methods do not consider a  recognition task.  ii) Our framework enables \ntraining with both paired and unpaired data while conventional SR methods only support paired \ntraining. iii) Our approach simultaneously improves resolution and alleviates the background and PIE \nfrom real surveillance faces while traditional methods only act on recommendation. Examples in below \nFig. One demonstrates the superiority of FAN over SOTA SR methods. \n \nOur Feature Adaptation Network (FAN) consists of 2 stages. In first stage, we adopt disentangled features \nlearning to learns both identity and non-identity characteristics mainly from high-resolution(HR) images, \nwhich are combined as input to the decoder for pixel-wise face recovering.", "mimetype": "text/plain", "start_char_idx": 283477, "end_char_idx": 287801, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6904bdec-6926-4c17-b0d9-4b23688e9672": {"__data__": {"id_": "6904bdec-6926-4c17-b0d9-4b23688e9672", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "de0df7ac-b806-4fdb-964b-1b6fbcff1ae7", "node_type": "1", "metadata": {}, "hash": "0663878e38b833bf02c1ae69fad21f6764cf7215c563d9f9ef81823562d40711", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4121a336-0668-4093-b5db-67770641776f", "node_type": "1", "metadata": {}, "hash": "a4f775e8fa71ba1fcfc94ee28313f932adb9e6f566829d931e438f145fbfb651", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In second stage, we propose \nfeature adaptation to f acilitate the feature further  learning from the low -resolution ( LR) images by \napproximating feature distribution between th e low-resolution and high-resolution identity encoders. \nThere are two advantages to use Feature Adaption Network( FAN) for surveillance facial-\nrecognition(FR) and normalization. First,  Feature Adaption Network ( FAN) focuses on learning \ndisentangled identity features from Low-resolution(LR) images, which is better for facial recognition \n(FR) than extracting features from super -resolved \nfaces [tran2017disentangled, zhang2018facesr, wu2016j]. 2nd , our  adaptation is performed in \ndisentangled identity feature space, which enables training with unpaired data without pixel -to-pixelP a g e  7 | 16 \n \ncorrespondences. As shown in the last fig. , the synthetic paired data used in prior \nworks [CBN_ECCV16, CT-FSRNet-\n2018, bulatyang2018learn, wu2016j, zhang2018facesr, DRRN, MemNet_ICCV17, rad2019srobb]can \nnot accurately reflect  difference between real low-resolution(LR) and high-resolution(HR in-the-wild \nfaces, which is also observed in [cai2019toward]. \nFurthermore, to better handle surveillance faces with  the unknown and diverse resolution, we propose \nthe Random Scale Augmentation (RSA) method that enables the network to learn all kinds of scales \nduring training. Prior FSR  [CT-FSRNet-2018, CBN_ECCV16, URDGN_ECCV16] methods \neither artificially generate the LR images from the HR ones by simple  down-sampling, or  learn the \ndegradation mapping via a Convolutional Neural Network (CNN). However, their common drawback is \nto learn reconstruction under fixed scales, which may greatly limit their applications to surveillance faces. \nIn contrast, our RSA efficiently alleviates the constraint on scale variation. \nQ5. WSOD with PSNet and Box Regression \nAnswer: \nThe object detection task is to find  objects belonging to specified cl asses and their locations in  images. \nBenefiting from the rapid development of deep learning(DL) in recent years, the fully supervised object \ndetection task has made si gnificant progress. However, fully supervised task requires instance -level \nannotation for training, which costs  lot of time and resources. Unlabeled or image s labeled datasets \ncannot be effectively used by fully supervised method. On another hand, image-level annotated datasets \nare easy to generate and can even be automatically generated by web search engines. To effectively \nutilize these readily available datasets, we focus on weakly-supervised object detection(WSOD)  tasks. \nThe WSOD task only takes  image-level annotations to train  instance-level object detection network, \nwhich is different from the fully supervised object detection task.P a g e  8 | 16 \n \n \nFig.: Examples of PSNet outputs: (i) a dog without proposal occlusion, (ii) a dog whose head is occluded \nby the proposal box, (iii) a dog that proposal covers part of the body, and (iv) proposal completely cover \nthe entire dog. If proposal does not completely include the whole dog, PSNet gives a high score. If \nproposal ultimately consists of the whole dog, PSNet gives a low score. \nThere are 3 main methods for weakly supervised object det ection: The fir st is to update detector and \npseudo labels from inaccurate pseudo labels iteratively; The second is to construct an end-to-end network \nthat can take image-level annotation as supervision to train this object detection network. The third two-\nstage method is that taking an algorithm to optimize pseudo labels from other WSOD network s and \ntraining a fully supervised object detection network. In addition, according to different m odes of \nproposing proposals, each of  above methods can be divided int o 2 classes: one is to propose proposals \nbased on feature map that predicts probability of each pixel belonging to each class, and then get the \npossible instances and their locations in image; The second is detector-based method that uses the trained \ndetector to identify multiple proposals and determines whether each proposal belongs to a specific object \nclass or not. Comparing the effects of these methods, the end -to-end detector-based approach performs \nwell, and our work follows this series of process. \nThe earliest end -to-end detector -based WSOD network is WSDDN  Bilen and Vedaldi ( 2016), which \ntrains a two-streams network to predict the classification accuracy of each proposal and its contributions \nto each class.", "mimetype": "text/plain", "start_char_idx": 287802, "end_char_idx": 292302, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4121a336-0668-4093-b5db-67770641776f": {"__data__": {"id_": "4121a336-0668-4093-b5db-67770641776f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6904bdec-6926-4c17-b0d9-4b23688e9672", "node_type": "1", "metadata": {}, "hash": "e423b7acb5b925ac5601bf5fc9626132e2ad56deac66f383808af5dcabec9416", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "10df4883-3f01-4dc7-855f-c21452e6f3fe", "node_type": "1", "metadata": {}, "hash": "628a93f0fea69f6d16c85462ad0bb526c37f02ee0b00f93dfc642e4815ed96a8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The results of the two streams are combined to get the image classification score  so that \nthe WSDDN can take advantage of image-label annotations for training. Subsequent other work aims to \nimprove performance of this network, like a dding more classification streams, using the clustering \nmethod, adding a fully supervised module, and so on. The end -to-end detector-based approach has 2 \ndrawbacks: one is that context information cann ot be fully used to classify proposal; The second is that \nthe most discriminative parts of the object may be detected instead of the entire object.P a g e  9 | 16 \n \n \n \n \nTo make full use of the context information of the proposal and avoid finding only the most \ndiscriminative part, we design a new network structure that adds a box regression branch to the traditional \nWSOD network. In the previous WSOD network, there is usually no box regression part, while this \nbranch plays an essential role in fully supervised object detection networks. The box regression network \ncan adjust position and scale of proposal, make it closer to the ground truth. In the fully supervised object \ndetection task, we can use the instance-level label as supervision to train box regression network; but in \nWSOD task, network cannot obtain the instance -level annotation and thus cannot train this branch. To \nobtain reliable instance annotation  to train the r egression network, we designed the  proposal scoring \nnetwork named P SNet that can detect whether  proposal completely covers the object. Th e PSNet is \nspecially trained multi -label cl assification network. Even if the  object in the image is occluded or \nincomplete, the PSNet can detect the presence of the object. The PSNet can be used to evaluate image s \nwithout proposal area. If the proposal completely covers whole object, rest of the image will not contain \ninformation about it. We use  PSNet to evaluate the output of the WSOD network, and then select \nappropriate proposals as pseudo labels to train box regression network. Examples of the output of PSNet \nare shown in the above Figure. \n \nQ6. Autonomous Driving Assistance Systems (ADAS) and Vehicle \nAutomation. \nAnswer: \nVehicles are being equipped with increasingly complex autonomous driving assistance systems (ADAS) \nthat take over parts of driving tasks previously performed by the human driver. There are several different \nADAS technologies in vehicles, starting from basics that have been in vehicles for several years, such as \nautomatic windscreen wipers and anti -lock braking systems. More advanced techn iques are already onP a g e  10 | 16 \n \nthe road today, where both the longitudinal (braking/accelerating, e.g., adaptive cruise control) and lateral \n(steering, e.g., assisted lane-keeping) control of the vehicle is shifting to ADAS. Further enhanced levels \nof automated drivi ng functionality include autopilot (Tesla), intellisafe (Volvo), and Distronic plus \nsteering assist (Mercedes). Overall this fast pace of market penetration of ADAS in vehicles has n ot \nallowed drivers to develop understanding of new systems over an extended period. \nThe most common taxonomy to capture the development of ADAS technology in cars are SAE\u2019s levels \nof automation sae. This approach is based on six levels of automation, ranging from no automation (level \n0) to full automation (level 5). In particular, in levels 2/3, the automated system  can take partial control \nof vehicle, where level 2 expectations of the human driver are to monitor the system and intervene \nappropriately, while the level 3 expectation of the human driver is to intervene appropriately upon a \nrequest from the system. Today most ADAS technology equipped cars are at level 1, in which \nprogression to partial/semi-automation (level 2/3) with in-built ADAS technology in even lower-priced \ncar models is becoming more common. Also, level 2/3 automation will likely be reality for some time to \ncome, given that fuller automation (4/5) is emerging slowly without clear market deployment roadmap. \nOne of main challenges that arise in level 2/3 automation is transition of control from the ADAS to the \nhuman driver, often referred to as the \u201chandover problem.\u201d This transition is, according to social factors \nand safety research, a phase where human attention and reliability is c ritical, but where humans tend to \nunderperform in those respects  son2017situation. E.g. , research has indicated that automatic cruise \ncontrol technology leads to a reduction in mental workload and, thus, to problems with regaining control \nof the vehicle in  failure scenarios  stanton1998vehicle.", "mimetype": "text/plain", "start_char_idx": 292303, "end_char_idx": 296936, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "10df4883-3f01-4dc7-855f-c21452e6f3fe": {"__data__": {"id_": "10df4883-3f01-4dc7-855f-c21452e6f3fe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4121a336-0668-4093-b5db-67770641776f", "node_type": "1", "metadata": {}, "hash": "a4f775e8fa71ba1fcfc94ee28313f932adb9e6f566829d931e438f145fbfb651", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5b497545-33fc-4541-9428-67df266167b4", "node_type": "1", "metadata": {}, "hash": "0979838f2e423a61a1b53f526433ef1e344149d87d62501d35d5ec6508b8f54b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Additionally, a common misconception \nconcerning ADAS technology is that when more automation is introduced, human error will \ndisappear atlantic2015save, which may give rise to the problematic idea that driver training  is not \nnecessarily needed. However, social factors research advises against not training for the use of new \nsophisticated automation technology lee2006human; salas2006design; saetren2015effects, as humans in \nthe technology loop will still be needed for use, maintenance or design of the technology. It may even be \nthat increased automation increases the level of competence require d for the driver, as the  driver must \nknow both how to handle system manually, for instance, if the sensors in a car stop working  due to bad \nweather, in addition to knowing how to control and supervise the advanced automation technology. \nIn our previous work  rismani2018qualitative, we performed a qualitative survey and found that the \nhandover problem is challenging , and it is unclea r to drivers how this could best be handled securely. \nFurthermore, drivers were worried about the implications of vehicle automation due to lack of knowledge \nand experience of level 2/3 systems and seemed concerned about the kind of training and licensing that \naccompanies these developments in vehicle automation. The lack of certainty around tra ining and \nlicensing concerning emerging ADAS technologies is a relevant ethical concern, as it exposes a gap in \nregulation and industry best practices that have not been the focus of much research to date.P a g e  11 | 16 \n \nThis lack of certainty around driver training and licensing wrt level 2/3 automation systems underscores \nthe need to understand better the following research questions: (i) What are drivers\u2019 awareness of ADAS \nin their vehicles, (ii) How knowledgeable are drivers about ADAS in their vehicles, and (iii) How willing \nare drivers to engage or use ADAS in their vehicles? Overall we expect to see peo ple\u2019s engagement or \nuse pattern of ADAS technologies in their vehicle  correlate to their awareness and  knowledge of those \ntechniques. \nPrevious work has looked at driver perception of ADAS and vehicle automation, including understanding \nlearner drivers\u2019 perspective of Blind Spot Detection(BSD) and Adaptive Cruise Control(ACC) systems. \nThat work found that driver\u2019s  awareness, use, and perceived safety of Blind Spot Detection(BSD) was \nhigher than that of ACC  tsapi_introducing_2015, and contributed to a greater understanding of driver \npreparation and acceptance of ADAS  crump2016differing, and how drivers learn and prefer to learn \nabout ADAS, and what their expectations are regarding ADAS and vehicle \nautomation hoyos2018consumer. \nTo answer our research questions , we performed a quantitative public survey of issues specifi c to the \npublic\u2019s awareness, knowledge, and use of ADAS technologies in level 2/3 automation. Also, based on \nprevious work tsapi_introducing_2015; crump2016differing; hoyos2018consumer, we analyzed gender \nand age relationships as well as income and type of training with regards to our research questions above. \nQ7. Robot Learning and Execution of Collaborative Manipulation Plans \nfrom YouTube Videos. \nAnswer:  \n We focus on problem of learning collaborative action plans for  robot. Our goal is to have robot \u201cwatch\u201d \nunconstrained videos on web, extract the action sequences shown in the videos and convert them to an \nexecutable plan that it can perform either independently or as part of a human-robot or robot-robot team. \nLearning from online videos is har d, particularly in collaborative settings: it requires recognizing the \nactions executed, together with manipulated tools and objects. In many collaborative tasks, these actions \ninclude handing objects over or holding object for the other person to manipulate. There is a very large \nvariation in how the actions are performed and collaborative actions may overlap spatially and \ntemporally. \nIn our previous work  [hejia_isrr19], we proposed a system for learning activities p erformed by two \nhumans collaborating at the cooking task. The system implements a collabor ative action grammar built \nupon action grammar initially proposed by Yang et al. [yang2015robot]. Qualitative analysis in 12 clips \nshowed that parsing these clips with grammar results in human-interpretable tree structures representingP a g e  12 | 16 \n \na variety of single and collaborative actions.", "mimetype": "text/plain", "start_char_idx": 296937, "end_char_idx": 301403, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5b497545-33fc-4541-9428-67df266167b4": {"__data__": {"id_": "5b497545-33fc-4541-9428-67df266167b4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "10df4883-3f01-4dc7-855f-c21452e6f3fe", "node_type": "1", "metadata": {}, "hash": "628a93f0fea69f6d16c85462ad0bb526c37f02ee0b00f93dfc642e4815ed96a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ba2aeae3-a9a8-4603-9e73-b96220b79327", "node_type": "1", "metadata": {}, "hash": "7f8e8c56e30524b92a1e0a87fff13d9d96fab7bbd1dad0b4def151f780969719", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The clips were manually segmented and were approximate \n100 frames each.P a g e  13 | 16 \n \n \nIn this paper, we generalize this work with a framework for  generating single and collaborative action \ntrees from full -length YouTube videos lasting several minutes  and concatenating the trees in an action \ngraph that is executable by one or more robotic arms. \nThe framework takes as input YouTube video showing collaborative tasks from start to end. We assumes \nthat objects in video are annotated with label  and bou nding boxes, e.g., by running the YOLOv3 \nalgorithm. We also think a skill library that associates a detected action with skill -specific motion \nprimitives. We focus on cooking tasks because of the variety of manipulation actions and their \nimportance in-home service robotics. \nIn second fig.  shows the components of  proposed framework. We rely on insight that hands are  main \ndriving force of manipulation actions. We detect the human hands in the video and use the hand \ntrajectories to split the video into clips. We then associate objects and hands spatially and temporally to \nrecognize the actions and generate human -interpretable robot commands. Finally, we propose an open -\nsourced platform for creating and executing an action graph. We provide a quantitative analysis of \nperformance in two YouTube videos of 13401 frames in total and a demonstration in the simulation of \nrobots learning and performing the actions of the third video of 2421 frames correctly. \nWhile the extracted act ion sequences are executed in the  open-loop manner and thus do not withstand \nreal-world failures or disturbances, we find that this work brings us the step closer to havi ng robots \ngenerate and execute variety of semantically meaningful plans from watching videos online. \nQ8. JEC-QA: A Legal-Domain Question Answering Dataset \nLegal Question Answering (LQA) aims to provide explanations, advice, or solutions for legal issues. A \nqualified LQA system can not only demonstrates a professional consulting service for unskilled humans \nbut also help professionals to improve work efficiency and analyze real cases more accurately, which \nmakes LQA an import ant NLP application in the legal domain. Recently, many researchers attempt toP a g e  14 | 16 \n \nbuild LQA systems with machine learning techniques  and neural network s. Despite these efforts in \nemploying advanced NLP models, LQA is still confronted with the following two significant challenges. \nThe first is that there is less qualified LQA dataset, which limits the research. The second is that the cases \nand questions in the legal domain are very complex and rigorous. As shown in Table  1, most problems \nin LQA can be divided into two typical types: the knowledge-driven questions (KD-questions) and case-\nanalysis questions (CA-questions). KD-questions focus on the understanding of specific legal concepts, \nwhile CA -questions concentrate more on the analysis of real cases. Both types of questions require \nsophisticated reasoning ability and text comprehension ability, which makes LQA a hard task in NLP. \n \n \nTo get a better understanding of these reasoning abilities, we show a question of JEC -QA in \nFig. 1describing a criminal behavior that results in two crimes. The mo dels must understand \n\u201cMotivational Concurrence\u201d to reason out further evidence rather than lexical-level semantic matching. \nMoreover, the models must have the ability of multi -paragraph reading and multi -hop reasoning to \ncombine the direct evidence and the additional evidence to answer the question, while numerical analysis \nis also necessary for comparing which crime is more dangerous. We can see that answering one question \nwill need multiple reasoning abilities in both retrieving and answering, makes JEC -QA a challenging \ntask. \nTo investigate the challenges and characteristics of LQA, we design a unified OpenQA framework and \nimplement seven representative neural methods of reading comprehension. By evaluating theP a g e  15 | 16 \n \nperformance of these methods on JEC -QA, we sh ow that even the best approach can only achieve \nabout 25% and 29% on KD -questions and CA -questions, respectively, while skilled humans and \nunskilled humans can reach  81% and 64% accuracies on JEC -QA. The experimental results show that \nexisting OpenQA metho ds suffer from the inability of complex reasoning on JEC -QA as they cannot \nwell understand legal concepts and handle multi-hop logic. \n \n \nQ9. SpoC: Spoofing Camera Fingerprints \nAnswer: \n \nFigure 1: SpoC learns to spoof camera fingerprints. It can be used to insert camera traces to a generated \nimage. Experiments show that we can fool state -of-the-art camera-model identifiers that were not seen \nduring training.", "mimetype": "text/plain", "start_char_idx": 301404, "end_char_idx": 306160, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ba2aeae3-a9a8-4603-9e73-b96220b79327": {"__data__": {"id_": "ba2aeae3-a9a8-4603-9e73-b96220b79327", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5b497545-33fc-4541-9428-67df266167b4", "node_type": "1", "metadata": {}, "hash": "0979838f2e423a61a1b53f526433ef1e344149d87d62501d35d5ec6508b8f54b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0086a0b8-7a23-4d3c-9805-738e51efb9ed", "node_type": "1", "metadata": {}, "hash": "f82a458f905de3e6270548a792cbfde58f0722ce3e625e1e1f1eb9b643e83044", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Figure 2: A digital image of a scene contains camera-related traces of the image formation process that \ncould act as a fingerprint of a camera model. The used lenses and filters, the sensor, and the manufacturer-\nspecific digital processing pipelines result in unique patterns. These patterns c an be used to identify \ncamera models. \nThere have been astonishing advances in synthetic media generation in the last few years, thanks to deep \nlearning, and in particular to Generative Adversarial Networks (GANs). This technology -enabled aP a g e  16 | 16 \n \nsignificant improvement in the level of realism of generated data, increasing both resolution and quality. \nNowadays, powerful methods exist for creating an image from scratch, and for changing its style or only \nsome specific attributes. These methods are beneficial, especially on faces, and allow one to change the \nexpression of a person easily  or to modify its identity through face -swapping. This manipulated visual \ncontent can be used to build more effective fake news. It has been estimated that the average number of \nreposts for a report containing an image is  11 times larger than for those  without images. This raises \nserious concerns about the trustworthiness of digital content, as testified by the growing attention to the \nprofound fake phenomenon. \nThe research community has responded to this threat by developing several forensic detectors. Some of \nthem exploit high-level artifacts, like asymmetries in the color of the eyes, or anomalies arising from an \nimprecise estimation of the underlying geometry. However, technology improves so fast that these visual \nartifacts will soon disappear. Other approaches rely on the fact that any acquisition device leaves \ndistinctive traces on each captured image , because of its hardware, or its signal processing suite. They \nallow associating a media with its acquisition device at various levels, from the type of source (camera, \nscanner, etc.), to its brand/model (e.g., iPhone6 vs. iPhone7), to the individual device. A primary impulse \nto this field has been given by the seminal wor k of Luk\u00e0s et al., where it has been shown that reliable \ndevice identification is possible based on the camera photo -response non-uniformity (PRNU) pattern. \nThis pattern is due to tiny imperfections in the silicon wafer used to manufacture the imaging sensor and \ncan be considered as a type of device fingerprint. \nBeyond extracting fingerprints that contain device -related traces, it is also possible to re cover camera \nmodel fingerprints. These are related to the internal digital acquisition pipeline, including operations like \ndemosaicing, color balancing, and compression, whose details differ according to the brand and specific \nmodel of the camera (See Fig.2). Such differences help attribute images to their source camera, but can \nalso be used to highlight better anomalies caused by image manipulations . The absence of such traces, \nor their modification, is a strong clue that the image is synthetic or h as been manipulated in some way . \nDetection algorithms, however, must confront with the capacity of an adversary to fool them. This applies \nto any classifier and is also very well known in forensics, where m any counter-forensics methods have \nbeen proposed in the literature . Indeed, forensics and counter -forensics go hand in hand, a competition \nthat contributes to improving the level of digital integrity over time. \nIn this work, we propose a method to synthesi ze traces of cameras using a generative approach that is \nagnostic to the detector (i.e., not just targeted adversarial noise). We achieve this by training a conditional \ngenerator to jointly fool an adversarial discriminator network as well as a camera embe dding network. \nTo this end, the proposed method injects the distinctive traces of a target camera model in synthetic \nimages, while reducing the first generation traces themselves, leading all tested classifiers to attribute \nsuch images to the target camera (\u2019targeted attack\u2019).P a g e  1 | 15 \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n   (30 Days of Interview \nPreparation) \n \n# Day21P a g e  2 | 15 \n \nQ1. Explain Grad-CAM architecture? \nAnswer: \nAccording to the research paper, \u201cWe propose a technique for making Convolutional Neural Network \n(CNN)-based models more transparent by visualizing input regions that are \u2018important\u2019 for \npredictions \u2013 producing visual explanations . Our approach is  called Gradient -weighted Class \nActivation Mapping (Grad -CAM), which uses class -specific gradient information to localize the \ncrucial regions. These localizations are combined with  the existing pixel -space visualizations to \ncreate a new high-resolution, and class-discriminative display called the Guided Grad-CAM.", "mimetype": "text/plain", "start_char_idx": 306164, "end_char_idx": 310966, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0086a0b8-7a23-4d3c-9805-738e51efb9ed": {"__data__": {"id_": "0086a0b8-7a23-4d3c-9805-738e51efb9ed", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ba2aeae3-a9a8-4603-9e73-b96220b79327", "node_type": "1", "metadata": {}, "hash": "7f8e8c56e30524b92a1e0a87fff13d9d96fab7bbd1dad0b4def151f780969719", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8bbbf261-9544-439f-a918-4ec17020447c", "node_type": "1", "metadata": {}, "hash": "c964cc9221a1926af9ca91f52033b3aa92b3e2a323592ea5d27b231030d866ea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These \nmethods help better to understand CNN-based models, including image captioning and the apparent \nquestion answering (VQA) models. We evaluate our visual explanations by measuring the ability to \ndiscriminate between  the classes and  to inspire trust in humans, and their correlation with the \nocclusion maps. Grad-CAM provides a new way to understand the CNN-based models.\u201d \nA technique for making CNN(Convolutional Neural Network) -based models more transparent by \nvisualizing the regions of input that are \u201cimportant\u201d for predictions from these models \u2014 or visual \nexplanations. \n \nThis visualization is both high-resolution (when the class of interest is \u2018tiger cat,\u2019 it identifies crucial \n\u2018tiger cat\u2019 features like stripes, pointy ears and eyes) and class-discriminative (it shows the \u2018tiger cat\u2019 \nbut not the \u2018boxer (dog)\u2019).P a g e  3 | 15 \n \nQ2.Explain squeeze-net architecture? \nAnswer: \nNowadays, technology is at its peak. Self-driving cars and IoT is going to be household talks in the \nnext few years to come. Therefore, everything is controlled remotely, say , e.g., in self-driving cars, \nwe will need our system to co mmunicate with the servers regularly . So accordingly, if we have a \nmodel that has a small size, then we can quickly deploy it in the cloud. So that\u2019s why we needed an \narchitecture that is less in size and also achieve s the same level of accuracy  that other architecture \nachieves. \nIt\u2019s Architecture \n\uf0b7 Replace 3x3 filters with 1x1 filter - We plan to use the maximum number of 1x1 filters as \nusing a 1X1 filter rather than a 3X3 filter can reduce the number of parameters by 9X. We  \nmay think that replacing 3X3 filters with 1X1 filters may perform badly as it has less \ninformation to work on. But this is not a case . Typically 3X3 filter may capture the spatial \ninformation of pixels close to each other while the 1X1 filter zeros in on pixel and captures  \nfeatures amongst its channels. \n \n\uf0b7 Decrease number of input channels to 3x3 filters - to maintain a small total number of \nparameters in a CNN, and it is crucial not only to decrease the number of 3x3 filters, but also \nto decrease the  number of input channels to  3x3 filters. We reduce the number of input \nchannels to 3x3 filters using squeeze layers. The author of this paper has used a term called \nthe \u201cfire module,\u201d in which there is a squeeze layer and an expan ded layer. In the squeeze \nlayer, we are using 1X1 filters, while in the expanded layer, we are using  a combo of 3X3 \nfilters and 1X1 filters . The author is trying to limit the number of inputs to  3X3 filters to \nreduce the number of parameters in the layer.P a g e  4 | 15 \n \n\uf0b7 Downsample late in a network so that convolution layers have a large activation \nmap- Having got an intuition about contracting  the sheer number of parameters we are \nworking with, how the model is getting most out of the remaining set of parameters. The \nauthor in this paper has downsampled the feature map in later layers , and this increases \nthe accuracy. But this is an excellent contrast to networks like VGG where a large feature \nmap is taken, and then it gets smaller as network approach towards the end. This different \napproach is too interesting, and they cite the  paper by K. He and H. Sun  that similarly \napplies delayed downsampling that leads to higher classification accuracy. \nThis architecture consists of the fire module, which enables it to bring down the number \nof parameters. \n \nAnd other thing that surprises  me is the lack of fully conn ected layers or dense layers at the end , \nwhich one will see in a typical CNN architecture. The dense layers , in the end,  learn all the \nrelationships between the high -level features and the classes it is trying to identify. The fully \nconnected layers are de signed to learn that noses and ears make up a face, and wheels and lights \nindicate cars. However, in this architecture, that extra learning step seems to be embedded within the \ntransformations between various \u201cfire modules.\u201dP a g e  5 | 15 \n \n \nThe squeeze -net can accomplish an accuracy nearly equal to AlexNet with 50X less number of \nparameters.", "mimetype": "text/plain", "start_char_idx": 310967, "end_char_idx": 315116, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8bbbf261-9544-439f-a918-4ec17020447c": {"__data__": {"id_": "8bbbf261-9544-439f-a918-4ec17020447c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0086a0b8-7a23-4d3c-9805-738e51efb9ed", "node_type": "1", "metadata": {}, "hash": "f82a458f905de3e6270548a792cbfde58f0722ce3e625e1e1f1eb9b643e83044", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2d057317-de9e-4c7a-b3f3-b6ed462c1149", "node_type": "1", "metadata": {}, "hash": "592fcf0c84bc01801690d2d003f5496d0188c04c60b0ba5306096684b28c539e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The most impressive part is that if we apply Deep compression to the already smaller \nmodel, then it can reduce the size of the squeeze-net model to 510x times that of AlexNet. \n \nQ3.ZFNet architecture \nAnswer: \n \nThe architecture of the network is an optimized version of the  last year\u2019s winner - AlexNet. The \nauthors spent some time to find out the bottlenecks of AlexNet and removing them, achieving \nsuperior performance. \n \n(a): First  layer ZFNET features without feature scale clipping. (b): the First  layer features fro m \nAlexNet. Note that there are lot of dead features - ones where the network did not learn any patterns. \n(c): the First layer features for ZFNet. Note that there are only a few dead features. (d): Second layer \nfeatures from AlexNet. The grid -like patterns are so -called aliasing artifacts. They appear whenP a g e  6 | 15 \n \nreceptive fields of convolutional neurons overlap, and neighboring neurons learn similar structures. \n(e): 2nd layer features for ZFNet. Note that there are no aliasing artifacts. Source: original paper. \nIn particular, they reduced the filter size in the 1 st convolutional layer from 11x11 to 7x7, which \nresulted in fewer dead features learned in the first layer (see the image below for an example of that). \nA dead feature is a situation where a convolutional kernel fails to learn any significant representation. \nVisually it looks like a monotonic single-color image, where all the values are close to each other. \nIn addition to changing the filter size, the authors of FZNet have doubled the number of filters in all \nconvolutional layers and the number of neurons in the fully connected layers as compared to the \nAlexNet. In the AlexNet, there were 48 -128-192-192-128-2048-2048 kern els/neurons, and in the \nZFNet, all these doubled to 96-256-384-384-256-4096-4096. This modification allowed the network \nto increase the complexity of internal representations and as a result, decrease the error rate from \n15.4% for last year\u2019s winner, to 14.8% to become the winner in 2013. \n \n \nQ4. What is NAS (Neural Architecture Search)? \nAnswer: \nDeveloping the neural network models often requires significa nt architecture engineering. We  can \nsometimes get by with transfer learning, but if we  want the best possible performance , it\u2019s usually \nbest to design your network. This requires speciali zed skills and is challenging in general; we may \nnot even know the limits of the current state-of-the-art(SOTA) techniques. Its a lot of trial and error, \nand experimentation itself is time-consuming and expensive. \nThis is the NAS(Neural Architecture Search)  comes in. NAS (Neural Architecture Search)  is an \nalgorithm that searches for the best neural network architecture. Most of the algorithms work in th e \nfollowing way. Start off by defining the  set of \u201cbuilding blocks\u201d that can be used for our network.  \nE.g., the state-of-the-art(SOTA) NASNet paper proposes these commonly used blocks for an image \nrecognition network-P a g e  7 | 15 \n \nIn the NAS algorithm, the controller Recurrent Neural Network (RNN) samples the building blocks, \nputting them together to create some end to end architecture.  Architecture generally combines the \nsame style as state -of-the-art(SOTA) networks, such as DenseNets or ResNets, but uses  a much \ndifferent combination and the configuration of blocks. \nThis new network architecture is then trained to convergence to obtain the least accuracy on the held-\nout validation set. The resulting efficiencies are used to update the controller so that the c ontroller \nwill generate better architectures over time, perhaps by selecting better blocks or making better \nconnections. The controller weights are updated with a policy gradient. The whole end-to-end setup \nis shown below. \n \nIt\u2019s a reasonably intuitive approach! In simple means : have an algorithm grab different blocks and \nput those blocks together to make the network. Train and test out that network. Based on our results, \nadjust the blocks we used to make the network and how you put them together! \n \nQ5. What is SENets? \nAnswer: \n \nSENets stands for Squeeze-and-Excitation Networks  introduces a building block for CNNs that \nimproves channel interdependencies at almost no computational cost. They have used in the 2017 \nImageNet competition and helped to improve the result from last year by 25%.", "mimetype": "text/plain", "start_char_idx": 315117, "end_char_idx": 319495, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2d057317-de9e-4c7a-b3f3-b6ed462c1149": {"__data__": {"id_": "2d057317-de9e-4c7a-b3f3-b6ed462c1149", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8bbbf261-9544-439f-a918-4ec17020447c", "node_type": "1", "metadata": {}, "hash": "c964cc9221a1926af9ca91f52033b3aa92b3e2a323592ea5d27b231030d866ea", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2ab1c494-338f-4cf5-aad1-5f9253332cdb", "node_type": "1", "metadata": {}, "hash": "4a6502fc8ae7c9cbc74fd2d364cec715ddbdf74dc56519f4f0092d3decec060b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Besides this large \nperformance boost, they can be easily added to existing architectures. The idea is this:P a g e  8 | 15 \n \nLet\u2019s add parameters to each channel of the  convolutional block so that the network can adaptively \nadjust the weighting of each feature map. \nAs simple as may it sound, this is it. So, let\u2019s take a closer look at why this works so well. \nWhy it works too well? \nCNN's uses its convolutional filters to extract hierarchal information from the images. Lower layers \nfind little pieces of context like high frequencies or edges, while upper layers can detect faces, text , \nor other complex geometrical shapes. They extract whatever is necessary to solve the task precisely. \nAll of this works by fusing spatial and channel information of an image. The different filters will first \nfind the spatial features in each input channel before adding the information across all available \noutput channels.  \nAll we need to understand for now is that  the network weights each of its ch annels equally when \ncreating output feature maps. It is all about changing this by adding a content -aware mechanism to \nweight each channel adaptively. In its too basic form, this could m ean adding a single parameter to \neach channel and giving it linear scalar how relevant each one is. \nHowever, the authors push it a little further. First, they get the global understanding of each channel \nby squeezing feature maps to a single numeric value.  This results in the vector of size n, where n is \nequal to the number of convolutional channels. Afterward, it is fed through a two -layer neural \nnetwork, which outputs a vector of the same size. These n values can now be used as weights on the \noriginal features maps, scaling each channel based on its importance. \n \nQ6. Feature Pyramid Network (FPN) \nAnswer:P a g e  9 | 15 \n \nThe Bottom-Up Pathway \nThe bottom -up pathway is feedforward computation of  backbone ConvNet. It is known as one  \npyramid level is for each stage. The output of last layer of each step will be used as the reference set \nof feature maps for enriching the top-down pathway by lateral connection. \nTop-Down Pathway and Lateral Connection \n\uf0b7 The higher resolution features are upsampled spatially coarser, but semantically stronger, \nfeature maps from higher pyramid levels. More particularly, the spatial resolution \nis upsampled by a factor of 2 using nearest neighbor for simplicity. \n\uf0b7 Each lateral connection adds feature maps of the sa me spatial size from  the bottom-up \npathway and top-down pathway. \n\uf0b7 Specifically, the feature maps from the bottom-up pathway undergo  1\u00d71 \nconvolutions to reduce channel dimensions. \n\uf0b7 And feature maps from the bottom-up pathway and top-down pathway are merged \nby element-wise addition. \nPrediction in FPN \n\uf0b7 Finally, the 3\u00d73 convolution is appended on each merged map to generate a final feature \nmap, which is to reduce the aliasing effect of upsampling. This last set of feature maps is \ncalled {P2, P3, P4, P5}, corresponding to {C2, C3, C4, C5} that are respecti vely of same \nspatial sizes. \n\uf0b7 Because all levels of  pyramid use shared classifiers/regressors as in a traditional featur ed \nimage pyramid,  feature dimension at output  d is fixed with  d = 256. Thus, all extr a \nconvolutional layers have 256 channel outputs. \n \n \nQ7. DeepID-Net( Def-Pooling Layer) \nAnswer: \nA new def-pooling (deformable constrained pooling) layer is used to model the deformation of the \nobject parts with geometric constraints and penalties. That means, except detecting the whole object \ndirectly, it is also important to identify object parts, which can then assist in detecting the whole \nobject.P a g e  10 | 15 \n \n \nThe steps in  black color are the  old stuff that existed in R -CNN. The st ages in red color do not \nappear in R-CNN. \n1.  Selective Search \n \n\uf0b7 First, color similarities, texture similarities, regions size, and region filling are used as non-\nobject-based segmentation. Therefore you obtain many small segmented areas as shown \nat the bottom left of the image above. \n\uf0b7 Then, the bottom-up approach is used that small segmented areas are merged to form the \nlarger segment areas. \n\uf0b7 Thus, about 2K regions, proposals (bounding box candidates) are generated , as shown \nin the above image. \n \n2.", "mimetype": "text/plain", "start_char_idx": 319496, "end_char_idx": 323788, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2ab1c494-338f-4cf5-aad1-5f9253332cdb": {"__data__": {"id_": "2ab1c494-338f-4cf5-aad1-5f9253332cdb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2d057317-de9e-4c7a-b3f3-b6ed462c1149", "node_type": "1", "metadata": {}, "hash": "592fcf0c84bc01801690d2d003f5496d0188c04c60b0ba5306096684b28c539e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f92d2480-e358-4a68-a3cf-5d16bbdaa9e3", "node_type": "1", "metadata": {}, "hash": "24d5d88c58c2b88a52f29257db9904bdb8a060f4572a4553a753c5e607293068", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2. Box Rejection \nR-CNN is used to reject bounding boxes that are most likely to be the background.P a g e  11 | 15 \n \n3. Pre train Using Object-Level Annotations \n \nUsually, pretraining is on image-level annotation. It is not good when an object is too small within \nthe image because the object should occupy a large area within the bounding box created by the \nselective search. \nThus, pretraining is on object -level annotation. And the deep learning (DL) model can be any \nmodels such as ZFNet, VGGNet, and GoogLeNet. \n4. Def-Pooling LayerP a g e  12 | 15 \n \n \n \nFor the def-pooling path, output from conv5, goes through the Conv layer, then goes through the def-\npooling layer, and then has a max-pooling layer. \nIn simple terms, the summation of ac multiplied by dc,n, is the 5\u00d75 deformation penalty in the figure \nabove. The penalty of placing object part from assumed the central position. \nBy training the DeepID-Net, object parts of the object to be detected will give a high activation value \nafter the def-pooling layer if they are closed to their anchor places. And this output will connect to \n200-class scores for improvement. \n5. Context Modeling \nIn object detection task s in ILSVRC, there are  200 classes . And there is also the  classification \ncompetition task in ILSVRC for classifying and localizing 1000-class objects. The contents are more \ndiverse compared with the object detection task. Hence,  1000-class scores, obtained by \nclassification network, are used to refine 200-class scores. \n \n6. The Model Averaging- \nMultiple models are used to increase the accuracy, and the results from all models are averaged. \nThis technique has been used since AlexNet, LeNet, and so on.P a g e  13 | 15 \n \n \n7. Bounding Box Regression \nBounding box regression is to fine-tune the bounding box location, which has been used in R-CNN. \nQ8. What is FractalNet Architecture? \nAnswer: \nIn2015, after the invention of ResNet, with numerous champion won, there are plenty of researchers \nworking on how to improve the ResNet, such as Pre-Activation ResNet, RiR, RoR, Stochastic Depth, \nand WRN. In this story, conversely, a non -residual-network approach,  FractalNet, is shortly \nreviewed. When VGGNet is starting to degrade when it goes from 16 layers (VGG -16) to 19 layers \n(VGG-19), FractalNet can go up to 40 layers or even 80 layers. \nArchitecture \n \nIn the above picture : A Simple Fractal Expansion ( on Left), Recursively Stacking of Fractal \nExpansion as One Block (in the Middle), 5 Blocks Cascaded as FractalNet (on the Right) \nFor the base case, f1(z) is the convolutional layer: \n                         \nAfter that, recursive fractals are:P a g e  14 | 15 \n \nWhere C is a  number of columns as in the middle of the  above figure. The number  of the \nconvolutional layers at the deepest path within the block will have 2^(C-1). In this case, C=4, thereby, \na number of convolutional layers are 2\u00b3=8 layers. \nFor the join layer (green), the element-wise mean is computed. It is not concatenation or addition. \nWith five blocks ( B=5) cascaded as FractalNet at the  right of the figure, then the number of \nconvolutional layers at the most profound path within the whole network is B\u00d72^(C-1), i.e., 5\u00d72\u00b3=40 \nlayers. \nIn between 2 blocks, 2\u00d72 max pooling is done to reduce the size of feature maps. Batch Norm and \nReLU are used after each convolution. \n \nQ9. What is the SSPNet architecture? \nAnswer: \nSPPNet has introduced the  new technique in CNN called  Spatial Pyramid Pooling (SPP)  at the \ntransition of the convolutional layer and fully connected layer. This is a work from Microsoft. \n \nConventionally, at the trans formation of the Conv layer and FC layer, there is one single pooling \nlayer or even no pooling layer. In SPPNet, it suggests having multiple pooling layers with different \nscales. \nIn the figure, 3-level SPP is used. Suppose conv5 layer has 256 feature maps.", "mimetype": "text/plain", "start_char_idx": 323786, "end_char_idx": 327696, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f92d2480-e358-4a68-a3cf-5d16bbdaa9e3": {"__data__": {"id_": "f92d2480-e358-4a68-a3cf-5d16bbdaa9e3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2ab1c494-338f-4cf5-aad1-5f9253332cdb", "node_type": "1", "metadata": {}, "hash": "4a6502fc8ae7c9cbc74fd2d364cec715ddbdf74dc56519f4f0092d3decec060b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f586e01e-8c96-4521-bd66-ab7d03a7f88a", "node_type": "1", "metadata": {}, "hash": "fb8b453e10206de5046cebc0d48f15e686f0791793c2155488210c626e0ade0b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Suppose conv5 layer has 256 feature maps. Then at the SPP layer,P a g e  15 | 15 \n \n1. first, each feature map is  pooled to become one value ( which is grey). Thus 256-d vector \nis formed. \n2. Then, each feature map is pooled to have four values (which is green), and form the 4\u00d7256-\nd vector. \n3. Similarly, each feature map is  pooled to have 16 values ( in blue), and form the  16\u00d7256-d \nvector. \n4. The above three vectors are concatenated to form a 1-d vector. \n5. Finally, this 1-d vector is going into FC layers as usual. \nWith SPP, you don\u2019t need to crop the image to a fixed size, like AlexNet, before going into CNN. Any \nimage sizes can be inputted.Data Science \nInterview Questions \n(30 days of Interview Preparation)INEURON.AI \n \n Page 2 \n \n \nQ1.  What is the difference between AI, Data Science, ML, and DL? \n \nAns 1 :  \n         \n  \n \nArtificial Intelligence: AI is purely math and scientific exercise, but when it became computational, it \nstarted to solve human problems formalized into a subset of computer science. Artificial intelligence has \nchanged the original computational statistics paradigm to the modern idea that machines could mimic \nactual human capabilities, such as decision making and performing more \u201chuman\u201d tasks. Modern AI into \ntwo categories \n1. General AI - Planning, decision making, identifying objects, recognizing sounds, social & \nbusiness transactions \n2. Applied AI - driverless/ Autonomous car or machine smartly trade stocks \n \nMachine Learning: Instead of engineers \u201cteaching\u201d or programming computers to have what they need \nto carry out tasks, that perhaps computers could teach themselves \u2013 learn something without being \nexplicitly programmed to do so. ML is a form of AI where based on more data, and they can change \nactions and response, which will make more efficient, adaptable and scalable. e.g., navigation apps and \nrecommendation engines. Classified into:- \n1. Supervised \n2. Unsupervised \n3. Reinforcement learning \n \nData Science: Data science has many tools, techniques, and algorithms called from these fields, plus \nothers \u2013to handle big data \nThe goal of data science, somewhat similar to machine learning, is to make accurate predictions and to \nautomate and perform transactions in real-time, such as purchasing internet traffic or automatically \ngenerating content.INEURON.AI \n \n Page 3 \n \nData science relies less on math and coding and more on data and building new systems to process the \ndata. Relying on the fields of data integration, distributed architecture, automated machine learning, data \nvisualization, data engineering, and automated data-driven decisions, data science can cover an entire \nspectrum of data processing, not only the algorithms or statistics related to data.  \n \nDeep Learning: It is a technique for implementing ML. \nML provides the desired output from a given input, but DL reads the input and applies it to another data.  \nIn ML, we can easily classify the flower based upon the features. Suppose you want a machine to look at \nan image and determine what it represents to the human eye, whether a face, flower, landscape, truck, \nbuilding, etc. \nMachine learning is not sufficient for this task because machine learning can only produce an output from \na data set \u2013 whether according to a known algorithm or based on the inherent structure of the data. Y ou \nmight be able to use machine learning to determine whether an image was of an \u201cX\u201d \u2013 a flower, say \u2013 and \nit would learn and get more accurate. But that output is binary (yes/no) and is dependent on the \nalgorithm, not the data. In the image recognition case, the outcome is not binary and not dependent on \nthe algorithm. \nThe neural network performs MICRO calculations with computational on many layers . Neural networks \nalso support weighting data for \u2018confidence. These results in a probabilistic system, vs. deterministic, and \ncan handle tasks that we think of as requiring more \u2018human-like\u2019 judgment. \n \n \nQ2. What is the difference between Supervised learning, Unsupervised learning and \nReinforcement learning? \n \nAns 2:  \nMachine Learning \nMachine learning is the scientific study of algorithms and statistical models that computer systems use to \neffectively perform a specific task without using explicit instructions, relying on patterns and inference \ninstead. \nBuilding a model by learning the patterns of historical data with some relationship between data to make \na data-driven prediction.", "mimetype": "text/plain", "start_char_idx": 327655, "end_char_idx": 332128, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f586e01e-8c96-4521-bd66-ab7d03a7f88a": {"__data__": {"id_": "f586e01e-8c96-4521-bd66-ab7d03a7f88a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f92d2480-e358-4a68-a3cf-5d16bbdaa9e3", "node_type": "1", "metadata": {}, "hash": "24d5d88c58c2b88a52f29257db9904bdb8a060f4572a4553a753c5e607293068", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c444de1f-f91d-4553-9f5e-8d36c83f4cad", "node_type": "1", "metadata": {}, "hash": "33aabe74cede4a39ff056d77f51ad2ed40b6f45fe82855d514eab84465f282bb", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Types of Machine Learning \n\u2022 Supervised Learning \n\u2022 Unsupervised Learning \n\u2022 Reinforcement Learning \n \nSupervised learning \nIn a supervised learning model, the algorithm learns on a labeled dataset, to generate reasonable \npredictions for the response to new data. (Forecasting outcome of new data) \n\u2022 Regression \n\u2022 ClassificationINEURON.AI \n \n Page 4 \n \n \nUnsupervised learning \nAn unsupervised model, in contrast, provides unlabelled data that the algorithm tries to make sense of by \nextracting features, co-occurrence and underlying patterns on its own. We use unsupervised learning for  \n\u2022 Clustering \n\u2022 Anomaly detection \n\u2022 Association \n\u2022 Autoencoders \nReinforcement Learning \nReinforcement learning is less supervised and depends on the learning agent in determining the output \nsolutions by arriving at different possible ways to achieve the best possible solution. \n \nQ3. Describe the general architecture of Machine learning. \n \n          \n  \n \n \nBusiness understanding: Understand the give use case, and also, it's good to know more about the \ndomain for which the use cases are built. \n \nData Acquisition and Understanding: Data gathering from different sources and understanding the \ndata. Cleaning the data, handling the missing data if any, data wrangling, and EDA( Exploratory data \nanalysis).INEURON.AI \n \n Page 5 \n \nModeling: Feature Engineering - scaling the data, feature selection - not all features are important. We \nuse the backward elimination method, correlation factors, PCA and domain knowledge to select the \nfeatures. \nModel Training based on trial and error method or by experience, we select the algorithm and train with \nthe selected features. \nModel evaluation Accuracy of the model , confusion matrix and cross-validation. \nIf accuracy is not high, to achieve higher accuracy, we tune the model...either by changing the algorithm \nused or by feature selection or by gathering more data, etc. \nDeployment - Once the model has good accuracy, we deploy the model either in the cloud or Rasberry \npy or any other place. Once we deploy, we monitor the performance of the model.if its good...we go live \nwith the model or reiterate the all process until our model performance is good. \nIt's not done yet!!! \nWhat if, after a few days, our model performs badly because of new data. In that case, we do all the \nprocess again by collecting new data and redeploy the model. \n \nQ4. What is Linear Regression? \n \nAns 4: \nLinear Regression tends to establish a relationship between a dependent variable(Y) and one or more \nindependent variable(X) by finding the best fit of the straight line. \nThe equation for the Linear model is Y = mX+c, where m is the slope and c is the intercept \n \n \nIn the above diagram, the blue dots we see are the distribution of 'y' w.r.t 'x .' There is no straight line that \nruns through all the data points. So, the objective here is to fit the best fit of a straight line that will try to \nminimize the error between the expected and actual value.INEURON.AI \n \n Page 6 \n \n \nQ5. OLS Stats Model (Ordinary Least Square) \n \nAns 5: \nOLS is a stats model, which will help us in identifying the more significant features that can has an \ninfluence on the output. OLS model in python is executed as: \nlm = smf.ols(formula = 'Sales ~ am+constant', data = data).fit() lm.conf_int() lm.summary()  \nAnd we get the output as below, \n \n \nThe higher the t-value for the feature, the more significant the feature is to the output variable. And \nalso, the p-value plays a rule in rejecting the Null hypothesis(Null hypothesis stating the features has zero \nsignificance on the target variable.). If the p-value is less than 0.05(95% confidence interval) for a \nfeature, then we can consider the feature to be significant. \n \n \nQ6. What is L1 Regularization (L1 = lasso) ? \n \nAns 6: \nThe main objective of creating a model(training data) is making sure it fits the data properly and reduce \nthe loss. Sometimes the model that is trained which will fit the data but it may fail and give a poor \nperformance during analyzing of data (test data). This leads to overfitting. Regularization came to \novercome overfitting. \nLasso Regression (Least Absolute Shrinkage and Selection Operator) adds \u201cAbsolute value of \nmagnitude\u201d of coefficient, as penalty term to the loss function.INEURON.AI \n \n Page 7 \n \nLasso shrinks the less important feature\u2019s coefficient to zero; thus, removing some feature altogether.", "mimetype": "text/plain", "start_char_idx": 332132, "end_char_idx": 336572, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c444de1f-f91d-4553-9f5e-8d36c83f4cad": {"__data__": {"id_": "c444de1f-f91d-4553-9f5e-8d36c83f4cad", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f586e01e-8c96-4521-bd66-ab7d03a7f88a", "node_type": "1", "metadata": {}, "hash": "fb8b453e10206de5046cebc0d48f15e686f0791793c2155488210c626e0ade0b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e6391154-f38e-41b3-bcf3-54e2ef40c2d8", "node_type": "1", "metadata": {}, "hash": "e974c40662e926a6ae6c3f6d2d8cffcae0ed20f419628fafde9ab081ac35589f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "So, \nthis works well for feature selection in case we have a huge number of features.  \n \n \n \nMethods like Cross-validation, Stepwise Regression are there to handle overfitting and perform feature \nselection work well with a small set of features. These techniques are good when we are dealing with a \nlarge set of features. \nAlong with shrinking coefficients, the lasso performs feature selection, as well. (Remember the \n\u2018selection\u2018 in the lasso full-form?) Because some of the coefficients become exactly zero, which is \nequivalent to the particular feature being excluded from the model. \n \nQ7. L2 Regularization(L2 = Ridge Regression) \n \nAns 7: \n \n \nOverfitting happens when the model learns signal as well as noise in the training data and wouldn\u2019t \nperform well on new/unseen data on which model wasn\u2019t trained on. \nTo avoid overfitting your model on training data like cross-validation sampling, reducing the number \nof features, pruning, regularization, etc. \nSo to avoid overfitting, we perform Regularization.INEURON.AI \n \n Page 8 \n \n \n \nThe Regression model that uses L2 regularization is called Ridge Regression. \nThe formula for Ridge Regression:-  \n \n \nRegularization adds the penalty as model complexity increases. The regularization parameter \n(lambda) penalizes all the parameters except intercept so that the model generalizes the data and \nwon\u2019t overfit. \nRidge regression adds \u201csquared magnitude of the coefficient\" as penalty term to the loss \nfunction. Here the box part in the above image represents the L2 regularization element/term. \n \n \nLambda is a hyperparameter.INEURON.AI \n \n Page 9 \n \nIf lambda is zero, then it is equivalent to OLS. But if lambda is very large, then it will add too much \nweight, and it will lead to under-fitting. \nRidge regularization forces the weights to be small but does not make them zero  and does not give \nthe sparse solution. \nRidge is not robust to outliers as square terms blow up the error differences of the outliers, and the \nregularization term tries to fix it by penalizing the weights \nRidge regression performs better when all the input features influence the output , and all with weights \nare of roughly equal size. \nL2 regularization can learn complex data patterns. \n \nQ8. What is R square(where to use and where not)? \nAns 8. \nR-squared is a statistical measure of how close the data are to the fitted regression line. It is also \nknown as the coefficient of determination, or the coefficient of multiple determination for multiple \nregression. \nThe definition of R-squared is the percentage of the response variable variation that is explained by a \nlinear model. \nR-squared = Explained variation / Total variation \nR-squared is always between 0 and 100%. \n0% indicates that the model explains none of the variability of the response data around its mean. \n100% indicates that the model explains all the variability of the response data around its mean.  \nIn general, the higher the R-squared, the better the model fits your data.INEURON.AI \n \n Page 10 \n \nThere is a problem with the R-Square. The problem arises when we ask this question to ourselves.** Is it \ngood to help as many independent variables as possible?** \nThe answer is No because we understood that each independent variable should have a meaningful \nimpact. But, even** if we add independent variables which are not meaningful**, will it improve R -Square \nvalue? \nYes, this is the basic problem with R-Square. How many junk independent variables or important \nindependent variable or impactful independent variable you add to your model, the R-Squared value will \nalways increase. It will never decrease with the addition of a newly independent variable, whether it could \nbe an impactful, non-impactful, or bad variable, so we need another way to measure equivalent R-\nSquare, which penalizes our model with any junk independent variable.  \nSo, we calculate the Adjusted R-Square with a better adjustment in the formula of generic R-square. \n \n \nQ9. What is Mean Square Error? \nThe mean squared error tells you how close a regression line is to a set of points. It does this by \ntaking the distances from the points to the regression line (these distances are the \u201cerrors\u201d) and \nsquaring them. \n \nGiving an intuition \n \n \n \nThe line equation is y=Mx+B. We want to find M (slope) and B (y-intercept) that minimizes the \nsquared error.INEURON.AI \n \n Page 11 \n \n \n \n \n \nQ10. Why Support Vector Regression? Difference between SVR and a simple regression \nmodel? \n \nAns 10: \nIn simple linear regression, try to minimize the error rate.", "mimetype": "text/plain", "start_char_idx": 336573, "end_char_idx": 341148, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e6391154-f38e-41b3-bcf3-54e2ef40c2d8": {"__data__": {"id_": "e6391154-f38e-41b3-bcf3-54e2ef40c2d8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c444de1f-f91d-4553-9f5e-8d36c83f4cad", "node_type": "1", "metadata": {}, "hash": "33aabe74cede4a39ff056d77f51ad2ed40b6f45fe82855d514eab84465f282bb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a44724e1-44dd-4dc4-9a07-f500a1ae805b", "node_type": "1", "metadata": {}, "hash": "b7cbc6ef0a35c882760d94ac5c6e6e59e8f3c86befff511265009cb5bf56260b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Ans 10: \nIn simple linear regression, try to minimize the error rate. But in SVR, we try to fit the error within \na certain threshold. \n \nMain Concepts:- \n1. Boundary \n2. Kernel \n3. Support Vector \n4. Hyper Plane \n \n \n \n \nBlueline: Hyper Plane; Red Line: Boundary-LineINEURON.AI \n \n Page 12 \n \nOur best fit line is the one where the hyperplane has the maximum number of points. \nWe are trying to do here is trying to decide a decision boundary at \u2018e\u2019 distance from the original \nhyperplane such that data points closest to the hyperplane or the support vectors are within that \nboundary lineP a g e  1 | 11 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 12P a g e  2 | 11 \n \nQ1. Where is the confusion matrix used? Which module would you \nuse to show it? \nAnswer: \nIn machine learning, confusion matrix is one of the easiest ways to summarize the performance of \nyour algorithm. \nAt times, it is difficult to judge the accuracy of a model by just looking at the accuracy because of \nproblems like unequal distribution. So, a better way to check how good your model is, is to use a \nconfusion matrix. \nFirst, let\u2019s look at some key terms. \nClassification accuracy \u2013 This is the ratio of the number of correct predictions to the number of \npredictions made \nTrue positives \u2013 Correct predictions of true events \nFalse positives \u2013 Incorrect predictions of true events \nTrue negatives \u2013 Correct predictions of false events \nFalse negatives \u2013 Incorrect predictions of false events. \nThe confusion matrix is now simply a matrix containing true positives, false positives, true \nnegatives, false negatives.P a g e  3 | 11 \n \nQ2: What is Accuracy? \nAnswer: \nIt is the most intuitive performance measure and it simply a ratio of correctly predicted to the total \nobservations. We can say as, if we have high accuracy, then our model is best. Yes, we could say that \naccuracy is a great measure but only when you have symmetric datasets where false positives and \nfalse negatives are almost same. \n \nAccuracy = True Positive + True Negative / (True Positive +False Positive + False                                         \nNegative + True Negative) \n \nQ3: What is Precision? \nAnswer: \nIt is also called as the positive predictive value. Number  of correct positives in your model that \npredicts compared to the total number of positives it predicts. \n \nPrecision = True Positives / (True Positives + False Positives) \nPrecision = True Positives / Total predicted positive \n \nIt is the number of positive elements predicted properly divided by the total number of positive \nelements predicted. \nWe can say Precision is a measure of exactness, quality, or accuracy. High precision  \nMeans that more or all of the positive results you predicted are correct.P a g e  4 | 11 \n \nQ4: What is Recall? \nAnswer: \nRecall we can also called as sensitivity or true positive rate. \nIt is several positives that our model predicts compared to the actual number of positives in our data. \nRecall = True Positives / (True Positives + False Positives) \nRecall = True Positives / Total Actual Positive \n \nRecall is a measure of completeness. High recall which means that our model classified most or all \nof the possible positive elements as positive. \n \nQ5: What is F1 Score? \nAnswer: \nWe use Precision and recall together because they complement each other in how they describe the \neffectiveness of a model. The F1 score that combines these two as the weighted harmonic mean of \nprecision and recall. \n \nF1 Score = 2 * (Precision * Recall) / (Precision + Recall)P a g e  5 | 11 \n \nQ6: What is Bias and Variance trade-off? \nAnswer: \nBias \nBias means it\u2019s how far are the predict values from the actual values. If the average predicted values \nare far off from the actual values, then we called as this one have high bias. \nWhen our model has a high bias, then it means that our model is too simple and does not capture the \ncomplexity of data, thus underfitting the data.   \n \nVariance \nIt occurs when our model performs good on the trained dataset but does not do well on a dataset that \nit is not trained on, like a test dataset or validation dataset. It tells us that actual value is how much \nscattered from the predicted value. \n \nBecause of High variance it cause overfitting that implies that the algorithm models random noise \npresent in the training data.", "mimetype": "text/plain", "start_char_idx": 341079, "end_char_idx": 345462, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a44724e1-44dd-4dc4-9a07-f500a1ae805b": {"__data__": {"id_": "a44724e1-44dd-4dc4-9a07-f500a1ae805b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e6391154-f38e-41b3-bcf3-54e2ef40c2d8", "node_type": "1", "metadata": {}, "hash": "e974c40662e926a6ae6c3f6d2d8cffcae0ed20f419628fafde9ab081ac35589f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d3a0c950-8cb5-4290-937a-66495246d14f", "node_type": "1", "metadata": {}, "hash": "134d6b4d039044d1b6fc6136bde81216d504234b386a18c28a22f3c08f00845e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "When model have high variance, then model becomes very flexible and tune itself to the data points \nof the training set.P a g e  6 | 11 \n \nBias-variance: It decomposition essentially decomposes the learning error from any algorithm by \nadding bias, the variance and a bit of irreducible error due to noise in the underly ing dataset. \nEssentially, if we make the model more com plex and add more variables, We \u2019ll lose bias but gain \nsome variance \u2014to get the optimally reduced amount of error, you\u2019ll h ave to  tradeoff bias and \nvariance. We don\u2019t want either high bias or high variance in your model. \n \n                            Bias and variance using bulls-eye diagram \n \n \nQ7. What is data wrangling? Mention three points to consider in the \nprocess. \nAnswer: \nData wrangling is a process by which we convert and map data. This changes data from its raw \nform to a format that is a lot more valuable. \nData wrangling is the first step for machine learning and deep learning. The end goal is to provide \ndata that is actionable and to provide it as fast as possible.P a g e  7 | 11 \n \nThere are three major things to focus on while talking about data wrangling \u2013 \n1. Acquiring data \nThe first and probably the most important step in data science is the acquiring, sorting and cleaning \nof data. This is an extremely tedious process and requires the most amount of time. \nOne needs to: \n\uf0b7 Check if the data is valid and up-to-date. \n\uf0b7 Check if the data acquired is relevant for the problem at hand. \nSources for data collection Data is publicly available on various websites like \nkaggle.com, data.gov ,World Bank, Five Thirty Eight Datasets, AWS Datasets, Google \nDatasets. \n2. Data cleaning \nData cleaning is an essential component of data wrangling and requires a lot of patience. To make \nthe job easier it is first essential to format the data make the data readable for humans at first. \nThe essentials involved are: \n\uf0b7 Format the data to make it more readable \n\uf0b7 Find outliers (data points that do not match the rest of the dataset) in data \n\uf0b7 Find missing values and remove them from the data set (without this, any model being \ntrained becomes incomplete and useless) \n3. Data Computation \nAt times, your machine not have enough resources to run your algorithm e.g. you might not have a \nGPU. In these cases, you can use publicly available APIs to run your algorithm. These are standard \nend points found on the web which allow you to use computing power over the web and process \ndata without having to rely on your own system. An example would be the Google Colab Platform.P a g e  8 | 11 \n \nQ8. Why is normalization required before applying any machine \nlearning model? What module can you use to perform normalization? \nAnswer: \nNormalization is a process that is required when an algorithm uses something like distance \nmeasures. Examples would be clustering data, finding cosine similarities, creating recommender \nsystems. \nNormalization is not always required and is done to prevent variables that are on higher scale from \naffecting outcomes that are on lower levels. For example, consider a dataset of employees\u2019 income. \nThis data won\u2019t be on the same scale if you try to cluster it. Hence, we would have to normalize the \ndata to prevent incorrect clustering. \nA key point to note is that normalization does not distort the differences in the range of values. \nA problem we might face if we don\u2019t normalize data is that gradients would take a very long time \nto descend and reach the global maxima/ minima. \nFor numerical data, normalization is generally done between the range of 0 to 1. \nThe general formula is: \nXnew = (x-xmin)/(xmax-xmin)P a g e  9 | 11 \n \nQ9. What is the difference between feature selection and feature \nextraction? \nFeature selection and feature extraction are two major ways of fixing the curse of dimensionality \n1. Feature selection: \nFeature selection is used to filter a subset of input variables on which the attention should focus. \nEvery other variable is ignored. This is something which we, as humans, tend to do subconsciously. \nMany domains have tens of thousands of variables out of which most are irrelevant and redundant. \nFeature selection limits the training data and reduces the amount of computational resources used. \nIt can significantly improve a learning algorithms performance. \nIn summary, we can say that the goal of feature selection is to find out an optimal feature subset. \nThis might not be entirely accurate, however, methods of understanding the importance of features \nalso exist.", "mimetype": "text/plain", "start_char_idx": 345464, "end_char_idx": 350030, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d3a0c950-8cb5-4290-937a-66495246d14f": {"__data__": {"id_": "d3a0c950-8cb5-4290-937a-66495246d14f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a44724e1-44dd-4dc4-9a07-f500a1ae805b", "node_type": "1", "metadata": {}, "hash": "b7cbc6ef0a35c882760d94ac5c6e6e59e8f3c86befff511265009cb5bf56260b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "df8777e6-9a03-45b4-9e9a-940f6ae289f5", "node_type": "1", "metadata": {}, "hash": "367c593275cf28082941f422e2c9accc34e59f4e41f71700931205f9579b5bd3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Some modules in python such as Xgboost help achieve the same. \n2. Feature extraction \nFeature extraction involves transformation of features so that we can extract features to improve the \nprocess of feature selection. For example, in an unsupervised learning problem, the extraction of \nbigrams from a text, or the extraction of contours from an image are examples of feature extraction. \nThe general workflow involves applying feature extraction on given data to extract features and \nthen apply feature selection with respect to the target variable to select a subset of data. In effect, \nthis helps improve the accuracy of a model.P a g e  10 | 11 \n \nQ10. Why is polarity and subjectivity an issue? \nPolarity and subjectivity are terms which are generally used in sentiment analysis. \nPolarity is the variation of emotions in a sentence. Since sentiment analysis is widely dependent on \nemotions and their intensity, polarity turns out to be an extremely important factor. \nIn most cases, opinions and sentiment analysis are evaluations. They fall under the categories of \nemotional and rational evaluations. \nRational evaluations, as the name suggests, are based on facts and rationality while emotional \nevaluations are based on non-tangible responses, which are not always easy to detect. \nSubjectivity in sentiment analysis, is a matter of personal feelings and beliefs which may or may \nnot be based on any fact. When there is a lot of subjectivity in a text, it must be explained and \nanalysed in context. On the contrary, if there was a lot of polarity in the text, it could be expressed \nas a positive, negative or neutral emotion. \nQ11. When would you use ARIMA? \nAnswer: \nARIMA is a widely used statistical method which stands for Auto Regressive Integrated Moving \nAverage. It is generally used for analyzing time series data and time series forecasting. Let\u2019s take a \nquick look at the terms involved. \nAuto Regression is a model that uses the relationship between the observation and some numbers of \nlagging observations.P a g e  11 | 11 \n \nIntegrated means use of differences in raw observations which help make the time series stationary. \nMoving Averages is a model that uses the relationship and dependency between the observation \nand residual error from the models being applied to the lagging observations. \nNote that each of these components are used as parameters. After the construction of the model, a \nlinear regression model is constructed. \nData is prepared by: \n\uf0b7 Finding out the differences \n\uf0b7 Removing trends and structures that will negatively affect the model \n\uf0b7 Finally, making the model stationary.P a g e  1 | 10 \n \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n# Day13P a g e  2 | 10 \n \nQ1. What is Autoregression? \nAnswer: \nThe autoregressive (AR) model is commonly used to model time-varying processes and solve \nproblems in the fields of natural science, economics and finance, and others. The models have always \nbeen discussed in the context of random process and are often perceived as statistical tools for time \nseries data. \nA regre ssion model, like linear regression, models an output value which are based on a linear \ncombination of input values. \nExample: y^ = b0 + b1*X1 \nWhere y^ is the prediction, b0 and b1 are coefficients found by optimi sing the model on training \ndata, and X is an input value. \nThis model technique can be used on the time series where input variables are taken as observations \nat previous time steps, called lag variables. \nFor example, we can predict the value for the next time step (t+1) given the observations at the  last \ntwo time steps (t-1 and t-2). As a regression model, this would look as follows: \nX(t+1) = b0 + b1*X(t-1) + b2*X(t-2)- \nBecause the regression model uses the data from the same input variable at previous time steps, it is \nreferred to as an autoregression. \nThe notation AR(p) refers to the autoregressive model of order p. The AR(p) model is writtenP a g e  3 | 10 \n \nQ2. What is Moving Average? \nAnswer: \nMoving average : From a dataset , we will get an overall idea of trends by this technique; it is \nan average of any subset of numbers. For  forecasting long -term trends , the moving average is \nextremely useful for it . We can calculate it for any period .", "mimetype": "text/plain", "start_char_idx": 350031, "end_char_idx": 354345, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "df8777e6-9a03-45b4-9e9a-940f6ae289f5": {"__data__": {"id_": "df8777e6-9a03-45b4-9e9a-940f6ae289f5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d3a0c950-8cb5-4290-937a-66495246d14f", "node_type": "1", "metadata": {}, "hash": "134d6b4d039044d1b6fc6136bde81216d504234b386a18c28a22f3c08f00845e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6705304c-622e-4201-9e8c-4cdf5a33b542", "node_type": "1", "metadata": {}, "hash": "56a1669dc8195344ba7aeaa2637e7dc2ce921f8f84c0258d54b365601f694820", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We can calculate it for any period . For example:  if we have sales data for \ntwenty years, we can calculate the five-year moving average, a four -year moving average, a three -\nyear moving average and so on. Stock market analysts will often use a 50 or 200-day moving average \nto help them see trends in the stock market and (hopefully) forecast where the stocks are headed.  \n \n \nThe notation MA(q) refers to the moving average model of order q: \n \nQ3. What is Autoregressive Moving Average (ARMA)? \nAnswer: \nARMA: It  is a model of  forecasting in which the methods of  autoregression (AR) analysis and \nmoving average (MA) are both applied to time -series data that is well behaved. In ARMA it is \nassumed that the time series is stationary and when it fluctuates, it does so uniformly around a \nparticular time.  \nAR (Autoregression model)- \nAutoregression (AR) model is commonly used in current spectrum estimation.P a g e  4 | 10 \n \nThe following is the procedure for using ARMA. \n\uf0b7 Selecting the AR model and t hen equalizing the output to equal the signal being studied if \nthe input is an impulse function or the white noise. It should at least be good approximation \nof signal. \n\uf0b7 Finding a model\u2019s parameters number using the known autocorrelation function or the data . \n\uf0b7 Using the derived model parameters to estimate the power spectrum of the signal. \nMoving Average (MA) model- \nIt is a commonly used model in  the modern spectrum estimation and is also one of the methods of  \nthe model parametric spectrum analysis. The procedure for estimating MA model\u2019s signal spectrum \nis as follows. \n\uf0b7 Selecting the MA model and then equalising the output to equal the signal understudy in the \ncase where the input is an impulse function or white noise. It should be at least a good \napproximation of the signal. \n\uf0b7 Finding the model\u2019s parameters using the known autocorrelation function. \n\uf0b7 Estimating the signal\u2019s power spectrum using the derived model parameters. \nIn the estimation of the ARMA parameter spectrum, the AR parameters are first estimated, and then \nthe MA parameters are estimated based on these AR parameters. The spectral estimates of the ARMA \nmodel are then obtained. The parameter estimation of the MA model is, therefore often calculated as \na process of ARMA parameter spectrum association. \nThe notation ARMA( p, q) refers to the model with  p autoregressive terms and  q moving-average \nterms. This model contains the AR(p) and MA(q) models,P a g e  5 | 10 \n \nQ4. What is Autoregressive Integrated Moving Average (ARIMA)? \nAnswer: \nARIMA: It is a statistical analysis model that uses time-series data to either better understand the data \nset or to predict future trends.  \nAn ARIMA model can be understood by the outlining each of its components as follows- \n\uf0b7 Autoregression (AR): It refers to a model that shows a changing variable that regresses on \nits own lagged, or prior, values. \n\uf0b7 Integrated (I): It represents the differencing of raw observations to allow  for the time series \nto become stationary, i.e., data values are replaced by the difference between the data values \nand the previous values. \n\uf0b7 Moving average (MA) : It  incorporates the dependency between an observation and the \nresidual error from the moving average model applied to the lagged observations. \nEach component functions as the  parameter with a standa rd notation. For ARIMA models, the  \nstandard notation would be  the ARIMA with p, d, and q, where integer values substitute for the \nparameters to indicate the type of the ARIMA model used. The parameters can be defined as- \n\uf0b7 p: It the number of lag observations in the model; also known as the lag order. \n\uf0b7 d: It the number of times that the raw observations are differenced; also known as the degree \nof differencing. \n\uf0b7 q: It the size of the moving average window; also known as the order of the moving average.P a g e  6 | 10 \n \nQ5.What is SARIMA (Seasonal Autoregressive Integrated Moving-\nAverage)? \nAnswer: \nSeasonal ARIMA: It  is an extension of ARIMA that explicitly supports the univariate time series \ndata with the seasonal component. \nIt adds three new hyper -parameters to specify the autoregression (AR), differencing (I) and the \nmoving average (MA) for the seasonal component of the series, as well as an additional parameter \nfor the period of the seasonality.", "mimetype": "text/plain", "start_char_idx": 354309, "end_char_idx": 358664, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6705304c-622e-4201-9e8c-4cdf5a33b542": {"__data__": {"id_": "6705304c-622e-4201-9e8c-4cdf5a33b542", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "df8777e6-9a03-45b4-9e9a-940f6ae289f5", "node_type": "1", "metadata": {}, "hash": "367c593275cf28082941f422e2c9accc34e59f4e41f71700931205f9579b5bd3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f2f6e694-2f58-4dcc-950a-e4a1ca0dc6e0", "node_type": "1", "metadata": {}, "hash": "bedf5e80199f7dcb443ff4a740e287f0bf4fd623d24e0345212b139ec39f5055", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Configuring the  SARIMA requires selecting hyperparameters for both the trend and seasonal \nelements of the series. \n \nTrend Elements \nThree trend elements requires the configuration. \nThey are same as the ARIMA model, specifically- \n \np: It is Trend autoregression order. \nd: It is Trend difference order. \nq: It is Trend moving average order. \n \nSeasonal Elements- \n \nFour seasonal elements are not the part of the ARIMA that must be configured, they are- \nP: It is Seasonal autoregressive order. \nD: It is Seasonal difference order. \nQ: It is Seasonal moving average order. \nm: It is the number of time steps for the single seasonal period. \n \nTogether, the notation for the SARIMA model is specified as- \n \nSARIMA(p,d,q)(P,D,Q)m- \n \nThe elements can be chosen through careful analysis of the ACF and PACF plots looking at the \ncorrelations of recent time steps.P a g e  7 | 10 \n \n \n \n \nQ6. What is Seasonal Autoregressive Integrated Moving-Average  \n with Exogenous Regressors (SARIMAX) ? \nAnswer: \nSARIMAX: It is an extension of the SARIMA model that also includes the modelling of the \nexogenous variables. \nExogenous variables are also called the covariates and can be thought of as parallel input sequences \nthat have observations at the same time steps as the original series. The primary series may be \nreferred as endogenous data to contrast it from exogenous sequence(s). The observations for \nexogenous variables are included in the model directly at each time step and are not modeled in the \nsame way as the primary endogenous sequence (e.g. as an AR, MA, etc. process). \n \nThe SARIMAX method can also be used to model the subsumed models with exogenous variables, \nsuch as ARX, MAX, ARMAX, and ARIMAX. \nThe method is suitable for univariate time series with trend and/or seasonal components and \nexogenous variables.P a g e  8 | 10 \n \nQ7. What is Vector autoregression (VAR)? \nAnswer: \nVAR: It is a  stochastic process  model used to capture the linear  interdependencies among \nmultiple time series . VAR models generali se the univariate  autoregressive model  (AR model ) by \nallowing for more than one evolving variable. All variables in the VAR enter the model in the same \nway: each variable has an equation explaining its evolution based on its own lagged values, the lagged \nvalues of the other model variables, and an  error term. VAR mode lling does not require s as much \nknowledge about the forces influencing the  variable as do  structural models  with simultaneous \nequations: The only prior knowle dge required is a list of variables which can be hypothesi sed to \naffect each other intertemporally. \nA VAR model des cribes the evolution of the  set of k variables over the same  sample period (t = 1, \n..., T) as the  linear function of only their past values. The variables are coll ected in the k-\nvector ((k \u00d7 1)-matrix) yt, , which has as the  (i th )element, yi,t, the observation at time  t of \nthe (i th )variable. Example: if the (i th )variable is the GDP, then yi,t is the value of GDP at time \u201ct\u201d. \n- \nwhere the observation yt\u2212i is called the (i-th) lag of y, c is the k-vector of constants (intercepts), Ai is \na time-invariant (k \u00d7 k)-matrix, and et is a k-vector of error terms satisfying. \n \nQ8. What is Vector Autoregression Moving-Average (VARMA)? \nAnswer: \nVARMA: It is  method models the next step in each time series using an ARMA model. It is the \ngeneralisation of ARMA to multiple parallel time series, Example- multivariate time series.P a g e  9 | 10 \n \nThe notation for a  model involves specifying the order for the AR(p) and the MA(q) models as \nparameters to the VARMA function, e.g. VARMA (p, q).  The VARMA model can also be used to \ndevelop VAR or VMA models. \nThis method is suitable for multivariate time series without trend and seasonal components. \n \n \nQ9. What is Vector Autoregression Moving-Average with Exogenous \n Regressors (VARMAX)? \nAnswer: \nVARMAX: It is an extension of the VARMA model that also includes the mode lling of the \nexogenous variables.", "mimetype": "text/plain", "start_char_idx": 358668, "end_char_idx": 362696, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f2f6e694-2f58-4dcc-950a-e4a1ca0dc6e0": {"__data__": {"id_": "f2f6e694-2f58-4dcc-950a-e4a1ca0dc6e0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6705304c-622e-4201-9e8c-4cdf5a33b542", "node_type": "1", "metadata": {}, "hash": "56a1669dc8195344ba7aeaa2637e7dc2ce921f8f84c0258d54b365601f694820", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "950be4a2-a43d-4b84-a984-430d561cf74a", "node_type": "1", "metadata": {}, "hash": "4ebcddea08280fa81af737be09fc314f13f679fed425030bb6bcae200c1332ba", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is the multivariate version of the ARMAX method. \nExogenous variables are also called the covariates and can be thought of as parallel input sequences \nthat have observations at the same time steps as the original series. The primary series(es) are referred \nas the endogenous data to contrast it from the exogenous sequence(s). The observations for  the \nexogenous variables are included in the model directly at each time step and are not modeled in the \nsame way as the primary endogenous sequence (Example- as an AR, MA, etc.). \nThis method can also be used to model subsumed models with exogenous variables, such as VARX \nand the  VMAX. \nThis method is suitable for multivariate time series without trend and seasonal components and \nexogenous variables.P a g e  10 | 10 \n \nQ10. What is Simple Exponential Smoothing (SES)? \nAnswer: \nSES: It method models the next time step as an exponentially weighted linear function of observations \nat prior time steps. \nThis method is suitable for univariate time series without trend and seasonal components. \nExponential smoothing  is the rule of thumb  technique for smoothing  time series  data using the \nexponential window function . Whereas in the  simple moving average , the past observations are \nweighted equally, exponential functions are used to assign exponentially decreas ing weights over \ntime. It is easily learned and easily applied procedure for making some determination based on prior \nassumptions by the user, such as seasonality. Exponential smoothing is often  used for analysis of \ntime-series data. \nExponential smoothing is one of many window functions commonly applied to smooth data in signal \nprocessing, acting as low-pass filters to remove high-frequency noise.  \nThe raw data sequence is often represented by {xt} beginning at time  t = 0, and the output of the \nexponential smoothing algorithm is commonly written as {st} which may be regarded as a best \nestimate of what the next value of x  will be. When the sequence of observations begins at time   t= \n0, the simplest form of exponential smoothing is given by the formulas:Page 1 of 12 \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 15Page 2 of 12 \n \nQ1. What is Autoencoder? \nAnswer: \nAutoencoder neural network : It  is an unsupervised Machine learning algorithm that applies \nbackpropagation, setting the target values to be equal to the inputs. It is trained to attempt to copy its \ninput to its output. Internally, it has the hidden layer that describes a code used to represent the input. \n \n It is trying to learn the approximation to the identity function, to output x\u0302 x^ that is similar to the xx. \nAutoencoders belongs to the neural network family, but they are also closely related to PCA \n(principal components analysis). \nAuto encoders, although it is quite similar to PCA, but its Autoencoders are much more flexible than \nPCA. Autoencoders can represent both liners and non -linear transformation in encoding , but PCA \ncan perform linear transformation. Autoencoders can be layered to form deep learning network due \nto its Network representation. \nTypes of Autoencoders: \n1.  Denoising autoencoder \nAutoencoders are Neural Networks which are used for feature selection and extraction. \nHowever, when there are more nodes in hidden layer than there are inputs, th e Network is \nrisking to learn  so-called \u201cIdentity Function\u201d, also called \u201cNull Function\u201d, meaning that \noutput equals the input, marking the Autoencoder useless.Page 3 of 12 \n \n Denoising Autoencoders solve this problem by corrupting the data on purpose by randomly \nturning some of the input values to zero. In general, the percentage of input nodes which \nare being set to zero is about 50%. Other sources suggest a lower count, such as 30%. It \ndepends on the amount of data and input nodes you have. \n                      \n2.  Sparse autoencoder \nAn autoencoder takes the input image or vector and learns code dictionary that changes the  \nraw input from one representation to another. Where in sparse autoencoders with a sparsity \nenforcer that directs a single-layer network to learn code dictionary which in turn minimizes \nthe error in reproducing the input while restricting number of code words for reconstruction. \nThe sparse autoencoder consists a single hidden layer, which is connected to the input vector \nby a weight matrix forming the encoding step. The hidden layer then outputs to a \nreconstruction vector, using a tied weight matrix to form the decoder. \n \nQ2. What Is Text Similarity?", "mimetype": "text/plain", "start_char_idx": 362697, "end_char_idx": 367269, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "950be4a2-a43d-4b84-a984-430d561cf74a": {"__data__": {"id_": "950be4a2-a43d-4b84-a984-430d561cf74a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f2f6e694-2f58-4dcc-950a-e4a1ca0dc6e0", "node_type": "1", "metadata": {}, "hash": "bedf5e80199f7dcb443ff4a740e287f0bf4fd623d24e0345212b139ec39f5055", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ac151282-3067-4f6d-9c24-3dfbbad239bd", "node_type": "1", "metadata": {}, "hash": "1bfc54472552a6c7d2a536cb385e0d8311c564780aaaa859a33c28c51cf6e5d0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q2. What Is Text Similarity? \nAnswer: \nWhen talking about text similarity, different people have a slightly different notion on what  text \nsimilarity means. In essence, the goal is to compute how \u2018close\u2019 two pieces of text are in (1) meaning \nor (2) surface closeness. The first is referred to as  semantic similarity, and the latter is  referred to \nas lexical similarity. Although the methods for  lexical similarity are often used to achieve  semantic \nsimilarity (to a certain extent), achieving true semantic similarity is often much more involved.Page 4 of 12 \n \nLexical or Word Level Similarity \nWhen referring to text similarity, people refer to how similar the two pieces of text are at the surface \nlevel. Example - how similar are the phrases  \u201cthe cat ate the mo use\u201d with \u201cthe mouse ate the cat \nfood\u201d by just looking at the words?  On the surface, if you consider only word-level similarity, these \ntwo phrases (with determiners disregarded) appear very similar as 3 of the 4 unique words are an \nexact overlap. \n \n \n \nSemantic Similarity: \nAnother notion of similarity mostly explored by NLP research community is how similar in meaning \nare any two phrases? If we look at the phrases, \u201c the cat ate the mouse \u201d and \u201c the mouse ate the cat \nfood\u201d. As we know that while the words significantly overlap s, these two phrases have different \nmeaning. Meaning out of the phrases is often the  more difficult task as it requires deeper level of  \nanalysis.Example, we can actually look at the simple aspects like order of \nwords: \u201ccat==>ate==>mouse\u201d and \u201cmouse==>ate==>cat food\u201d . Words overlap in this case, the \norder of the occurrence is different, and we can tell that, these two phrases have different meaning. \nThis is just the one example. Most people use  the syntactic parsing to help with the semantic \nsimilarity. Let\u2019s have a look at the parse trees for these two phrases. What can you get from it?Page 5 of 12 \n \n \n \nQ3. What is dropout in neural networks? \nAnswer: \nWhen we training our neural network (or model) by updating each of its weights, it might become \ntoo dependent on the dataset we are using. Therefore, when this model has to make a prediction or \nclassification, it will not give satisfactory results. This is known as over-fitting. We might understand \nthis problem through a real-world example: If a student of science learns only one chapter of a book \nand then takes a test on the whole syllabus, he will probably fail. \nTo overcome this problem, we use a technique that was introduced by Geoffrey Hinton in 2012. This \ntechnique is known as dropout. \nDropout refers to ignoring units (i.e. , neurons) during the training phase of certain set of neurons , \nwhich is chosen at random. By \u201cignoring\u201d, I mean these units are not considered during a particular \nforward or backward pass. \nAt each training stage, individual nodes are either dropped out of the net with probability 1-p or kept \nwith probability p, so that a reduced network is left; incoming and outgoing edges to a dropped -out \nnode are also removed.Page 6 of 12 \n \nQ4. What is Forward Propagation? \nAnswer: \nInput X provides the information that then propagates to hidden units at each layer and then finally \nproduce the output y . The architecture of  network entails determining its depth, width, and the \nactivation functions used on each layer.  Depth is the number of  the hidden layers.  Width is the \nnumber of units (nodes) on each hidden layer since we don\u2019t control neither input layer nor output \nlayer dimensions. There are quite a few set of activation functions such  Rectified Linear Unit, \nSigmoid, Hyperbolic tangent, et c. Research has proven that deeper networks outperform networks \nwith more hidden units. Therefore, it\u2019s always better and won\u2019t hurt to train a deeper network. \n \nQ5. What is Text Mining? \nAnswer: \nText mining: It is also referred as text data mining, roughly equivalent to text analytics, is the process \nof deriving high-quality information from text. High-quality information is typically derived through \nthe devising of patterns and trends through means such as  statistical pattern learning. Text mining \nusually involves the process of structuring the input text (usually parsing, along with the addition of \nsome derived linguistic features and the removal of others, and subsequent insertion into a database), \nderiving patterns within the  structured data, and finally evaluation and interpretation of the output.", "mimetype": "text/plain", "start_char_idx": 367241, "end_char_idx": 371713, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ac151282-3067-4f6d-9c24-3dfbbad239bd": {"__data__": {"id_": "ac151282-3067-4f6d-9c24-3dfbbad239bd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "950be4a2-a43d-4b84-a984-430d561cf74a", "node_type": "1", "metadata": {}, "hash": "4ebcddea08280fa81af737be09fc314f13f679fed425030bb6bcae200c1332ba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "afcc9754-0f7d-445b-8adc-46f40fbc30c7", "node_type": "1", "metadata": {}, "hash": "749d97b8d30e4ef8dd42e9d035277da345020fcb09565b84904c91387a8b03c7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "'High quality' in text mining usually refers to some combination of  relevance, novelty, and interest. \nTypical text mining tasks  include text categorization , text clustering , concept/entity extraction, \nproduction of granular taxonomies, sentiment analysis, document summarization, and entity relation \nmodeling (i.e., learning relations between named entities).Page 7 of 12 \n \n \nQ6. What is Information Extraction? \nAnswer: \nInformation extraction (IE): It is the task of automatically extracting structured information from the \nunstructured and/or semi-structured machine-readable documents. In most of the cases, this activity \nconcerns processing human language texts using natural language processing (NLP). \nInformation extraction depends on named entity recognition (NER), a sub-tool used to find targeted \ninformation to extract. NER recognizes entities first as one of several categories, such as location \n(LOC), persons (PER) , or organizations (ORG). Once the information category is recognized, an \ninformation extraction utility extracts the named entity\u2019s related information and constructs a \nmachine-readable document fro m it, which algorithms can further process to extract meaning. IE \nfinds meaning by way of other subtasks , including co-reference resolution, relationship extraction, \nlanguage, and vocabulary analysis, and sometimes audio extraction.Page 8 of 12 \n \nQ7. What is Text Generation? \nAnswer: \nText Generation: It is a type of the Language Modelling problem. Language Modelling is the core \nproblem for several of natural language processing tasks such as speech to text, conversational \nsystem, and the text summarization. The trained language model learns the likelihood of occurrence \nof the  word based on the previous sequence of words used in the text.  Language models can be \noperated at the character level, n-gram level, sentence level or even paragraph level. \nA language model is at the core of many NLP tasks, and is simply a probability distribution over a \nsequence of words: \n                               \n \n \nIt can also be used to estimate the conditional probability of the next word in a sequence:Page 9 of 12 \n \nQ8. What is Text Summarization? \nAnswer: \nWe all interact with the applications which uses the text summarization. Many of the applications are \nfor the platform which publishes articles on the daily news, entertainment, sports. With our busy \nschedule, we like to read the summary of those articles before we decide to jump in for reading entire \narticle. Reading a summary helps us to identify the interest area, gives a brief context of the story. \nText summarization is a subdomain of Natural Language Processing (NLP) that deals with extracting \nsummaries from huge chunks of texts. There are two main types of techniques used for text \nsummarization: NLP-based techniques and deep learning-based techniques. \nText summarization: It refers to the technique of shortening long pieces of te xt. The intention is to \ncreate the coherent and fluent summary having only the main points outlined in the document. \nHow text summarization works: \nThe two types of summarization, abstractive and the extractive summarization. \n1. Abstractive Summarization: It select words based on the semantic understanding; even those \nwords did not appear in the source documents. It aims at producing important material in the \nnew way. They interprets and examines the text using advanced natural language techniques \nto generate the new shorter text that conveys the most critical information from the original \ntext. \nIt can be correlated in the way human reads the text article or blog post and then summarizes in \ntheir word. \n \n2.  Extractive Summarization: It attempt to summarize articles by selecting the subset of words \nthat retain the most important points. \n \nThis approach weights the  most important part of sentences and uses the same to form the \nsummary. Different algorithm and the techniques are used to define  the weights for the \nsentences and further rank them based on importance and similarity among each other.Page 10 of 12 \n \n \nQ9. What is Topic Modelling? \nAnswer: \nTopic Modelling is the task of using unsupervised learning to extract the main topics (represented as \na set of words) that occur in a collection of documents. \nTopic modeling, in the context of Natural Language Processing, is described as a method of \nuncovering hidden structure in a collection of texts.  \n \nDimensionality Reduction: \nTopic modeling is the  form of dimensionality reduc tion. Rather than repr esenting the text T in its \nfeature space as {Word_i: count(Word_i, T) for Word_i in V}, we can represent the text in its topic \nspace as ( Topic_i: weight(Topic_i, T) for Topic_i in Topics ).", "mimetype": "text/plain", "start_char_idx": 371715, "end_char_idx": 376474, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "afcc9754-0f7d-445b-8adc-46f40fbc30c7": {"__data__": {"id_": "afcc9754-0f7d-445b-8adc-46f40fbc30c7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ac151282-3067-4f6d-9c24-3dfbbad239bd", "node_type": "1", "metadata": {}, "hash": "1bfc54472552a6c7d2a536cb385e0d8311c564780aaaa859a33c28c51cf6e5d0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bbb5f82b-4ebf-48de-9b0d-1b49aefe13b8", "node_type": "1", "metadata": {}, "hash": "31ebafa88d829647910f718a5bffb10f48dcecffd4e37d5f985126205e68e590", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Unsupervised learning: \nTopic modeling can be compared to the clustering. As in the case of clustering, the number of topics, \nlike the number of clusters, is the hyperparameter. By doing the topic modeling, we build clusters of \nwords rather than clusters of texts. A text is thus a mixture of all the topics, each having a certain \nweight. \n \nA Form of Tagging \nIf document classification is assigning a single category to a text, topic modeling is assigning multiple \ntags to a text. A human expert can label the resulting topics with human -readable labels and use \ndifferent heuristics to convert the weighted topics to a set of tags.Page 11 of 12 \n \nQ10.What is Hidden Markov Models? \nAnswer: \nHidden Markov Models (HMMs) are the  class of probabilistic graphical model that allow us to \npredict the sequence of unknown (hidden) variables from the set of observed variables. The  simple \nexample of an HMM is predicting the weather (hidden variable) based on the type of clothes that \nsomeone wears (obse rved). An HMM can be viewed as the  Bayes Net unrolled through time with \nobservations made at the sequence of time steps being used to predict the best sequence of the hidden \nstates. \n \nThe below diagram from Wikipedia shows that  HMM and its transitions. The scenario is the  room \nthat contains urns X1, X2, and X3, each of which contains a known mix of balls, each ball labeled y1, \ny2, y3, and y4. The sequence of four balls is randomly drawn. In this particular case, the user observes \nthe sequence of balls y1,y2,y3, and y4 and is attempting to discern the hidden state, which is the right \nsequence of three urns that these four balls were pulled from. \n \n \n  \nWhy Hidden, Markov Model? \nThe reason it is called the Hidden Markov Model is because we are constructing an inference model \nbased on the assumptions of a Markov process. The Markov process assumption is simply that the \n\u201cfuture is independent of the past given the present\u201d.  \n \nTo make this point clear, let us consider the scenario below where the weather, the hidden variable, \ncan be hot, mild or cold , and the observed variables are the type of clothing worn. The arrows \nrepresent transitions from a hidden state to another hidden state or from a hidden state to an observed \nvariable.Page 12 of 12 \n \n \n \n \n-----------------------------------------------------------------------------------------------------------------P a g e  1 | 11 \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 17P a g e  2 | 11 \n \nQ1. What is ERM (Empirical Risk Minimization)? \nAnswer:  \nEmpirical risk minimi zation (ERM): It is a principle in statistical learning theory which defines a \nfamily of learning algorithms and is used to give theoretical bounds on their performance. The idea \nis that we don\u2019t know exactly how well an algorithm will work in practice (the true \"risk\") because \nwe don't know the true distribution of data that the algorithm will work on, but as an alternative we \ncan measure its performance on a known set of training data. \nWe assumed that our samples come from this distribution and use our dataset as an approximation. \nIf we compute the loss using the data points in our dataset, it\u2019s called empirical risk. It is \u201cempirical\u201d \nand not \u201ctrue\u201d because we are using a dataset that\u2019s a subset of the whole population. \nWhen our learning model is built, we have to pick a function that minimizes the empirical risk that \nis the delta between predicted output and actual output for data points in the dataset. This process of \nfinding this function is called empirical risk minimization (ERM). We want to minimize the true risk. \nWe don\u2019t hav e information that allows us to achieve that, so we hope that this empirical risk will \nalmost be the same as the true empirical risk. \nLet\u2019s get a better understanding by Example \nWe would want to build a model that can differentiate between a male and a female based on specific \nfeatures. If we select 150 random people where women are really short, and men are really tall, then \nthe model might incorrectly assume that height is  the differentiating feature. For  building a truly \naccurate model, we have  to gather all the women and men in the world to extract  differentiating \nfeatures. Unfortunately, that is not possible! So we select a small number of people and hope that this \nsample is representative of the whole population.P a g e  3 | 11 \n \nQ2. What is PAC (Probably Approximately Correct)?", "mimetype": "text/plain", "start_char_idx": 376477, "end_char_idx": 380969, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bbb5f82b-4ebf-48de-9b0d-1b49aefe13b8": {"__data__": {"id_": "bbb5f82b-4ebf-48de-9b0d-1b49aefe13b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "afcc9754-0f7d-445b-8adc-46f40fbc30c7", "node_type": "1", "metadata": {}, "hash": "749d97b8d30e4ef8dd42e9d035277da345020fcb09565b84904c91387a8b03c7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "80ac7d83-369c-480c-a643-7ca6f1a37acc", "node_type": "1", "metadata": {}, "hash": "1563c9f31c5873b5e3ba580a9fe73367c4a9e0a7024d3ba1a69c0cb7823bee5b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "What is PAC (Probably Approximately Correct)? \nAnswer:  \nPAC: In computational learning theory , probably approximately correct  (PAC) learning is a \nframework for mathematical analysis of machine learning. \nThe learner receives samples and must have to pick a generalization function (called the hypothesis) \nfrom a specific class of possible functions. Our goal is that, with high p robability, the selected \nfunction will have low generalization error. The learner must be able to learn the concept given any \narbitrary approximation ratio, probability of success, or distribution of the samples. \nHypothesis class is PAC(Probably Approximately Correct ) learnable if there exists a function  m_H and \nalgorithm that for any labeling function  f, distribution D over the domain of inputs  X, \ndelta and epsilon that with  m \u2265 m_H produces a hypothesis  h like that with probability 1 -delta it \nreturns a true error lower than epsilon. Labeling function is nothing other than saying that we have a \nspecific function f that labels the data in the domain.P a g e  4 | 11 \n \nQ3. What is ELMo? \nAnswer:  \nELMo is a novel way to represent words in vectors or embeddings. These word embeddings help \nachieve state-of-the-art (SOTA) results in several NLP tasks: \n \nIt is a deep contextualized word representation that models both complex characteristics of word use \n(e.g., syntax and semantics), and how these uses vary across linguistic contexts. These word vectors \nare learned functions of internal states of a deep biLM(bidirectional language model), which is pre-\ntrained on large text corpus. They could be easily added to existing models and significantly improve \nstate of the art across a broad range of challenging NLP problems, including question answering, \ntextual entailment and sentiment analysis.P a g e  5 | 11 \n \nQ4. What is Pragmatic Analysis in NLP? \nAnswer:  \nPragmatic Analysis (PA): It deals with outside word knowledge, which means understanding i.e \nexternal to documents and queries. PA that focuses on what was described is reinterpreted by what it \nactually meant, deriving the various aspects of language that require real-world knowledge. \nIt deals with  overall communicative and  social content and its effect on interpretation. It means \nabstracting the meaningful use of language  in situations. In this analysis, the main focus always on \nwhat was said in reinterpreted on what is intended. \nIt helps users to discover this intended effect by applying a set of rules that characterize cooperative \ndialogues. \nE.g., \"close the window?\" should be interpreted as a request instead of an order. \n \n \nQ5. What is Syntactic Parsing? \nAnswer:  \nSyntactic Parsing  or Dependency Parsing : It is a task of recogniz ing a sentence and assigning a \nsyntactic structure to it.  Most Widely we used syntactic structure is the parse tree which can be \ngenerated using some parsing algorithms. Th ese parse trees are useful in various applic ations like \ngrammar checking or more importantly, it plays a critical role in the semantic analysis stage. For \nexample to answer the question \u201cWho is the point guard for the LA Laker in the next game ? \u201d we \nneed to figure out its subject, objects, attributes to help us figure out that the user wants the point \nguard of the LA Lakers specifically for the next game. \nExample:P a g e  6 | 11 \n \n \n \nQ6. What is ULMFit? \nAnswer:  \nTransfer Learning in NLP(Natural language Processing)  is an area that had not been explored with \ngreat success. But, in May 2018 , Jeremy Howard  and Sebastian Ruder  came up with the paper \n\u2013 Universal Language Model Fine -tuning for Text Classification (ULMFit)  which explores  the \nbenefits of using a pre trained model on text classification. It proposes ULMFiT(Universal Language \nModel Fine-tuning for Text Classification ), a transfer learning method that could be applied to any \ntask in NLP.  In this method outperforms the state-of-the-art on six text classification tasks. \nULMFiT uses a  regular LSTMwhich is the state -of-the-art language model architecture  (AWD-\nLSTM). The LSTM network has three layers. Single architecture is used throughout \u2013 for pre-training \nas well as for fine-tuning.", "mimetype": "text/plain", "start_char_idx": 380924, "end_char_idx": 385128, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "80ac7d83-369c-480c-a643-7ca6f1a37acc": {"__data__": {"id_": "80ac7d83-369c-480c-a643-7ca6f1a37acc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bbb5f82b-4ebf-48de-9b0d-1b49aefe13b8", "node_type": "1", "metadata": {}, "hash": "31ebafa88d829647910f718a5bffb10f48dcecffd4e37d5f985126205e68e590", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "314a4b5a-5952-4da1-9218-17074321c302", "node_type": "1", "metadata": {}, "hash": "e5f3106ef891db60251d3f2c02793c876d547129c3e2ec5fc21360e47db7566d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Single architecture is used throughout \u2013 for pre-training \nas well as for fine-tuning. \nULMFiT achieves the state-of-the-art result using novel techniques like: \n\uf0b7 Discriminative fine-tuning \n\uf0b7 Slanted triangular learning rates \n\uf0b7 Gradual unfreezing \nDiscriminative Fine-TuningP a g e  7 | 11 \n \nDifferent layers of a neural network capture different types of information so they should be fine -\ntuned to varying extents. Instead of using the same learning rates for all layers of the model, \ndiscriminative fine-tuning allows us to tune each layer with different learning rates. \nSlanted triangular learning \n       \nThe model should quickly converge to a suitable region of the parameter space in the beginning of \ntraining and then later refine its parameters. Using a constant learning rate throughout training is not \nthe best way to achieve this behaviour. Instead Slanted Triangular Learning Rates (STLR) linearly \nincreases the learning rate at first and then linearly decays it. \nGradual Unfreezing \nGradual unfreezing is the concept of unfreezing the layers gradually, which avoids the catastrophic \nloss of knowledge possessed by the model. It first unfreezes the top layer and fine -tunes all the \nunfrozen layers for 1 epoch. It then unfreezes the next lower frozen layer and repeats until all the  \nlayers have been fine-tuned until convergence at the last iteration. \nQ7. What is BERT? \nAnswer:  \nBERT (Bidirectional Encoder Representations from Transformers)  is an open -sourced NLP pre -\ntraining model developed by researchers at Google in 2018. A direct descendant to GPT (Generalized \nLanguage Models), BERT has outperformed several models in NLP and provided top  results in \nQuestion Answering, Natural Language Inference (MNLI), and other frameworks. \nWhat makes it\u2019s unique from the  rest of the model is that it is the first deeply bidirectional, \nunsupervised language representation, pre -trained using only a plain text corpus. Since it\u2019s open -\nsourced, anyone with machine learning knowledge can easily build an NLP model without the need \nfor sourcing massive datasets for t raining the model , thus saving time, energy, knowledge and \nresources.P a g e  8 | 11 \n \nHow does it work? \nTraditional context -free models (like word2vec or GloVe) generate a single word embedding \nrepresentation for each word in the vocabulary which means the word \u201cright\u201d would have the same \ncontext-free representation in \u201cI\u2019m sure I\u2019m right\u201d and \u201cTake a right turn.\u201d However, BERT would \nrepresent based on both previous and next context , making it bidirectional. While the concept of \nbidirectional was around for a long time, B ERT was first on its kind to successfully pre -train \nbidirectional in a deep neural network. \n \nQ8.What is XLNet? \nAnswer:  \nXLNet is a BERT-like model instead of a totally different one. But it is a n auspicious and potential \none. In one word, XLNet is a generalized autoregressive pretraining method. \nAutoregressive (AR) language model: It is a kind of model that using the context word to predict the \nnext word. But here the context word is constrained to two directions, either forward or backwards. \n \n \nThe advantages of AR language model are good at generative Natural language Process(NLP) tasks. \nBecause when generating context, usually is the forward direction. AR language model naturally \nworks well on such NLP tasks.P a g e  9 | 11 \n \nBut Autoregressive language model has some disadvantages, and it only can use forward context or \nbackward context, which means it can't use forward and backward context at the same time. \n \nQ9. What is the transformer? \nAnswer:  \nTransformer: It is a  deep machine learning  model introduced in 2017, used primarily in the field \nof natural language processing (NLP). Like recurrent neural networks(RNN), It is designed to handle \nordered sequences of data, such as natural language, for various tasks like machine \ntranslation and text summarization. However, Unlike recurrent neural networks(RNN), Transformers \ndo not require that the sequence be processed in the order. So, if the data in question is a natural \nlanguage, the Transformer does not need to process the beginning of a sentence before it processes \nthe end. Due to this feature, the Transformer allows for much more parallelization than RNNs during \ntraining. \nTransformers are developed to solve the problem of sequence transduction current neural networks. It \nmeans any task that transforms an input  sequence to an output sequence.", "mimetype": "text/plain", "start_char_idx": 385042, "end_char_idx": 389546, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "314a4b5a-5952-4da1-9218-17074321c302": {"__data__": {"id_": "314a4b5a-5952-4da1-9218-17074321c302", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "80ac7d83-369c-480c-a643-7ca6f1a37acc", "node_type": "1", "metadata": {}, "hash": "1563c9f31c5873b5e3ba580a9fe73367c4a9e0a7024d3ba1a69c0cb7823bee5b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50ba301a-e6df-4641-b025-c565c6088b16", "node_type": "1", "metadata": {}, "hash": "c058610557d50ba19bc82bd92b10042cc0f50ee682112ac0337a593e877453ae", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It \nmeans any task that transforms an input  sequence to an output sequence. This includes speech \nrecognition, text-to-speech transformation, etc. \nFor models to perform  a sequence transduction , it is necessary to have some sort of memory.  \nexample, let us say that we are translating the following sentence to another language (French):P a g e  10 | 11 \n \n\u201cThe Transformers\u201d is a Japanese band. That band was formed in 1968, d uring the height of the \nJapanese music history.\u201d \nIn the a bove example, the word \u201cthe band\u201d in the second sentence refers to the band \u201cThe \nTransformers\u201d introduced in the first sentence. When you read about the band in the second sentence, \nyou know that it is referencing to the \u201cThe Transformers\u201d band. That may be important for translation.  \nFor translating other sentences like that, a model needs to figure out these  sort of dependencies and \nconnections. Recurrent Neural Networks (RNNs) and Convolutional Neural Networks (CNNs) have \nbeen used to deal with this problem because of their properties. \n \n \nQ10. What is Text summarization? \nAnswer:  \nText summarization : It is the process of shortening a text document, to create a  summary of the \nsignificant points of the original document. \nTypes of Text Summarization Methods : \nText summarization methods can be classified into different types.P a g e  11 | 11 \n \n     \nExample: \n \n \n \n-------------------------------------------------------------------------------------------------------------P a g e  1 | 12 \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 19P a g e  2 | 12 \n \nQ1. What is LSI(Latent Semantic Indexing)? \nAnswer: \nLatent Semantic Indexing (LSI) : It is an indexing and retrieval method that uses a mathematical \ntechnique called SVD(Singular value decomposition) to find patterns in relationships between terms \nand concepts contained in an unst ructured collection of text. It  is based on the principle that words \nthat are used in the same contexts tend to have similar meanings. \nFor example, Tiger and Woods  are associated with men instead of an animal, and a Wood, Parris , \nand Hilton are associated with the singer. \nExample: \nIf you use LSI to index a collection of  articles and the words \u201cfan\u201d and \u201cregulator\u201d appear together \nfrequently enough, the search algorithm would notice that the two terms are semantica lly close. A \nsearch for \u201cfan\u201d will, therefore, return a set of items containing that phrase, but also items that contain \njust the word \u201cregulator\u201d. It doesn't understand word distance, but by examining a sufficient number \nof documents, it only knows the two terms are interrelated. It then uses that information to provide \nan expanded set of results with better recall than an understandable keyword search. \nThe diagram below describes the effect between LSI and keyword searches. W stands for a document.P a g e  3 | 12 \n \n \nQ2. What is Named Entity Recognition? And tell some use cases of \nNER? \nAnswer: \nNamed-entity recognition (NER): It is also known as entity extraction, and entity identification is a \nsubtask of  information extraction  that explore to locate and classify atomic elements in \ntext into predefined categories  like the names of  persons, organizations, places, expressions of \ntimes, quantities, monetary values, percentages and more. \nIn each text document, particular terms represent specific entities that are more informative and have \na different context. These entities are called named entities, which more accurately refer to conditions \nthat represent real-world objects like people, places, orga nizations or institutions, and so on, which \nare often expressed by proper names. The naive approach could be to find these by having a look at \nthe noun phrases in text documents. It also is known as entity chunking/extraction, which is a popular \ntechnique used in in formation extraction to analyze and segment the named enti ties and categorize \nor classify them under various predefined classes. \n \nNamed Entity Recognition use-case \n\uf0b7 Classifying content for news providers- \nNER can automatically scan entire articles and reveal which are the significant people, \norganizations, and places discussed in them. Knowing the relevant tags for each item helps \nin automatically categorizing the articles in defined hierarchies and enable smooth content \ndiscovery. \n\uf0b7 Customer Support: \nLet\u2019s say we  are handling  the customer support departm ent of an electronic s store with \nmultiple branches worldwide; we go through a number mentions in our customers\u2019 feedback.", "mimetype": "text/plain", "start_char_idx": 389470, "end_char_idx": 394055, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "50ba301a-e6df-4641-b025-c565c6088b16": {"__data__": {"id_": "50ba301a-e6df-4641-b025-c565c6088b16", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "314a4b5a-5952-4da1-9218-17074321c302", "node_type": "1", "metadata": {}, "hash": "e5f3106ef891db60251d3f2c02793c876d547129c3e2ec5fc21360e47db7566d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6aa18799-fa30-41d3-bd1f-440824be6e22", "node_type": "1", "metadata": {}, "hash": "d0e670b7c52056f0e3eafeaebde573528d9fd470a9ffab113761a21ca4d64ce7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Such as this for instance.P a g e  4 | 12 \n \nNow, if we  pass it through the Named Entity Recognition API, it pulls ou t the entities Bangalore  \n(location) and Fitbit (Product). This can be then used to categorize the complaint and assign it to the \nrelevant department within the organization that should be handling this. \n \n \nQ3. What is perplexity? \nAnswer: \nPerplexity: It is a measurement of how well a probability model predicts a sample. In the context of \nNLP, perplexity(Confusion) is one way to evaluate language models. \n The term perplexity has three clos ely related meanings. It  is a measure of how easy a probability \ndistribution is to predict. It is a measure of how variable a pre diction model is. And It is a measure \nof prediction error. The third meaning of perplexity is calculated slightly differently , but all three \nhave the same fundamental idea.P a g e  5 | 12 \n \nQ4. What is the language model? \nAnswer: \nLanguage Modelling (LM): It is one of the essential parts of modern NLP. There are many sorts of \napplications for Language Modelling, like  Machine Translation, Spell Correction Speech \nRecognition, Summarization, Question Ans wering, Sentiment analysis , etc. Each of those tasks \nrequires the use of the language model. The language model is needed to represent the text to a form \nunderstandable from the machine point of view. \nThe statistical language model is a probability distribution over a series of words. Given such a series, \nsay of length m, it assigns a probability to the whole series. \nIt provides context to distinguish between phrases and words that sounds are similar. For example, \nin American English, the phrases \" wreck a nice beach \" and \"recognize speech\" sound alike but mean \ndifferent things. \nData sparsity is a significant problem in building language models. Most possible  word sequences \nare not noticed in training. One solution is to make the inference that the probability of a word only \ndepends on the previous n words. This is called as an n-gram model or unigram model when  n = 1. \nThe unigram model is also known as the bag of words model. \nHow does this Language Model help in NLP Tasks? \nThe probabilities restoration  by a language model is most useful to compare  the likelihood that \ndifferent sentences are \"good sentences.\" This was useful in many practical tasks, for example: \nSpell checking: You observe a word that is not identified as a k nown word as part of a senten ce. \nUsing the edit distance algorithm, we find the closest known words to the unknown words. These are \nthe candidate corrections. For example, we observe the word \"wurd\" in the context of the s entence, \n\"I like to write this wu rd.\" The candidate corrections are [\"word\", \"weird\", \"wind\"]. How can we \nselect among these candidates the most likely correction for the suspected error \"weird\"? \nAutomatic Speech Recognition: we receive as input a string of phonemes; a first model predicts for \nsub-sequences of the stream of phonemes candidate words; the language model helps in ranking the \nmost likely sequence of words compatible with the candidate words produced by the acoustic model. \nMachine Translation: each word from the source language is mapped to multiple candidate words \nin the target language; the language model in the target language can rank the most likely sequence \nof candidate target words.P a g e  6 | 12 \n \nQ5. What is Word Embedding? \nAnswer: \nA word embedding is a learned representation for text where words that have the same meaning have \na similar observation. \nIt is basically a form of word representation that bridges the human understanding of language to that \nof a machine. Word embeddings divide representations of text in an n-dimensional space. These are \nessential for solving most NLP problems. \nAnd the other point worth considering is how we obtai n word embeddings as no two sets of word \nembeddings are similar. Word embeddings aren't random; they're developed  by training the neural \nnetwork. A recent powerful word embedding usage comes from Google named Word2Vec, which is \ntrained by predicting several words that appear next to other words in a language . For example, the \nword \"cat\", the neural network would predict the words like \"kitten\" and \"feline.\" This intuition of \nwords comes out \"near\" each other allows us to place them in vector space. \n \n \nQ6. Do you have an idea about fastText?", "mimetype": "text/plain", "start_char_idx": 394057, "end_char_idx": 398469, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6aa18799-fa30-41d3-bd1f-440824be6e22": {"__data__": {"id_": "6aa18799-fa30-41d3-bd1f-440824be6e22", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50ba301a-e6df-4641-b025-c565c6088b16", "node_type": "1", "metadata": {}, "hash": "c058610557d50ba19bc82bd92b10042cc0f50ee682112ac0337a593e877453ae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "baaa615a-af4a-45ba-bbf1-cfa67a4da6df", "node_type": "1", "metadata": {}, "hash": "26242a15125e422b3f055f9e642a9b4ab01c9f8cb1077162cdd1f50ebebfbf15", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q6. Do you have an idea about fastText? \nAnswer: \nfastText: It is another word  embedding method that is an extension  of the word2vec \nmodel. Alternatively, learning vectors for words directly . It represents each word as an n -gram of \ncharacters. So, for example, take the word, \u201c artificial\u201d with n=3, the  fastText representation of this \nword is <ar, art, rti, tif, ifi, fic, ici, ial, al>, where the angular brackets indicate the beginning and end \nof the word.    \nThis helps to capture the meaning of shorter words and grant the embeddings to understand prefixes \nand suffixes. Once the word has been showed using character skip-grams, a n-gram model is trained \nto learn the embeddings. This model is acknowledged to be a bag of words model with a slidingP a g e  7 | 12 \n \nwindow over a word because no internal structure of the word is taken into account.  As long as the \ncharacters are within this window, the order of the n-grams doesn\u2019t matter.   \nfastText works well with rare words. So even if a word wasn\u2019t seen during training, it can be broken \ndown into n-grams to get its embeddings. \nWord2vec and GloVe both fail to provide any vector representation for words  that are not in the \nmodel dictionary. This is a huge advantage of this method.   \n \n \n \nQ7. What is GloVe? \nAnswer: \nGloVe(global vectors ) is for word representation. GloV e is an unsupervised learning algorithm \ndeveloped by Stanford for achieving word embeddings by aggregating a global word -word co -\noccurrence matrix from a corpus. The resulting embeddings show interesting linear substructures of \nthe word in vector space. \nThe GloVe  model produces a vector space with meaningful substructure, as evidenced by its \nperformance of 75% on a new word analogy task. It also outperforms related models on similarity \ntasks and named entity recognition. \nHow GloVe find meaning in statistics? \n Produces a vector space with meaningful substructure, as evidenced by its performance of 75% on \na new word analogy task. It also outperforms related models on similarity tasks and named entity \nrecognition.P a g e  8 | 12 \n \nGloVe aims to achieve two goals: \n\uf0b7 (1) Create word vectors that capture meaning in vector space \n\uf0b7 (2) Takes advantage of global count statistics instead of only local information \n Unlike word2vec \u2013 which learns by streaming sentences \u2013 GloVe determines based on a  co-\noccurrence matrix and trains word vectors, so their differences predict co-occurrence ratios \nGloVe weights the loss based on word frequency. \nSomewhat surprisingly, word2vec and GloVe turn out to be remarkably similar, despite starting off \nfrom entirely different starting points. \n \n \n \nQ8. Explain Gensim? \nAnswer: \nGensim: It is billed as a Natural Language Processing package that does \u2018Topic Modeling for \nHumans\u2019. But its practically much more than that. \nIf you are unfamiliar with topic modeling, it is a technique to extract the underlying topics from \nlarge volumes of text. Gensim provides algorithms like LDA and LSI (which we already seen in \nprevious interview questions) and the necessary sophistication to built high-quality topic models.P a g e  9 | 12 \n \nIt is an excellent library package for processing texts, working with word vector models (such as \nFastText, Word2Vec, etc) and for building the topic models. Another significant advantage with \ngensim is: it lets us handle large text files without having to load the entire file in memory. \nWe can also tell as It is an open-source library for unsupervised topic modeling and natural \nlanguage processing, using modern statistical machine learning. \n \nGensim is implemented in Python and Cython. Gensim is designed to handle extensive text \ncollections using data streaming and incremental online algorithms, which differentiates it from \nmost other machine learning software packages that target only in-memory processing.P a g e  10 | 12 \n \nQ9. What is Encoder-Decoder Architecture? \nAnswer: \n \n \nThe encoder-decoder architecture consists of two main parts : \n\uf0b7 Encoder: \nEncoder simply takes the input data, and trains on it, then it passes the final state of its \nrecurrent layer as an initial state to the first recurrent layer of the decoder part. \n \n\uf0b7  Decoder : \nThe decoder takes the final state of encoder\u2019s final recurrent layer and uses it as an initial \nstate to its initial, recurrent layer, the input of the decoder is sequences that we want to get \nFrench sentences.", "mimetype": "text/plain", "start_char_idx": 398430, "end_char_idx": 402871, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "baaa615a-af4a-45ba-bbf1-cfa67a4da6df": {"__data__": {"id_": "baaa615a-af4a-45ba-bbf1-cfa67a4da6df", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6aa18799-fa30-41d3-bd1f-440824be6e22", "node_type": "1", "metadata": {}, "hash": "d0e670b7c52056f0e3eafeaebde573528d9fd470a9ffab113761a21ca4d64ce7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e907cdcf-5dcb-4b4f-94fd-3c5842eaf70a", "node_type": "1", "metadata": {}, "hash": "162daf551e6074c2d047a371e00630f08e7a7e62833b19f264bef49ba967cf81", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Some more example for better understanding:P a g e  11 | 12 \n \n \n \nQ10. What is Context2Vec? \n \nAnswer: \nAssume a case where you have a sentence like. I can\u2019t find May. Word May maybe refers to a month's \nname or a person's name. You use the words surround it (context) to help yourself to determine the \nbest suitable option. Actually, this problem refers to the Word Sense Disambiguation task, on which \nyou investigate the actual semantics of the word based on several semantic and linguistic techniques. \nThe Context2Vec idea is taken from the original CBOW Word2Vec model, but instead of relying on \naveraging the embedding of the words, it relies on a much more complex parametric model that is  \nbased on one layer of Bi-LSTM. Figure1 shows the architecture of the CBOW model. \nFigure1P a g e  12 | 12 \n \nContext2Vec applied the same concept of windowing, but instead of using a simple average \nfunction, it uses 3 stages to learn complex parametric networks. \n\uf0b7 A Bi-LSTM layer that takes left-to-right and right-to-left representations \n\uf0b7 A feedforward network that takes the concatenated hidden representation and produces a \nhidden representation through learning the network parameters. \n\uf0b7 Finally, we apply the objective function to the network output. \n \nWe used the Word2Vec negative sampling idea to get better performance while calculating \nthe loss value. \nThe following are some samples of the closest words to a given context.DATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 20P a g e  1 | 12 \n \nQ1. Do you have any idea about Event2Mind in NLP? \nAnswer: \nYes, it is based on NLP research paper to understand the common-sense inference from sentences. \n              Event2Mind: Common-sense Inference on Events, Intents, and Reactions \nThe study of \u201cCommonsense Reasoning\u201d in NLP deals with teaching computers how to gain and \nemploy common sense knowledge. NLP systems require common sense to adapt quickly and \nunderstand humans as we talk to each other in a natural environment. \nThis paper proposes a new task to teach systems commonsense reasoning: given an event described \nin a short \u201cevent phrase\u201d (e.g. \u201cPersonX drinks coffee in the morning\u201d), the researchers teach a system \nto reason about the likely intents (\u201cPersonX wants to stay awake\u201d) and reactions (\u201cPersonX feels \nalert\u201d) of the event\u2019s participants. \n \nUnderstanding a narrative requires common -sense reasoning about the mental states of people in \nrelation to events. For example, if \u201cRobert is dragging his feet at work,\u201d pragmatic implications about \nRobert\u2019s intent are that \u201cRobert wants to avoid doing things\u201d ( Above Fig). You can also infer that \nRobert\u2019s emotional reaction might be feeling \u201cbored\u201d or \u201clazy.\u201d  Furthermore, while not explicitly \nmentioned, you can assume that people other than Robert are affected by the situation, and these \npeople are likely to feel \u201cimpatient\u201d or \u201cfrustrated.\u201dP a g e  2 | 12 \n \nThis type of pragmatic inference can likely be useful for a wide range of NLP applications that require \naccurate anticipation of people\u2019s intents and emotional react ions, even when they are not express ly \nmentioned. For example, an ideal dialogue system should react in empathetic ways by reasoning \nabout the human user\u2019s mental state based on the ev ents the user has experienced, without the user \nexplicitly stating how they are feeling. Furthermore, advertisement systems on social media should \nbe able to reason about the emotional reactions of people after events such as mass shootings and \nremove ads for guns , which might increase social distress.  Also, the pragmatic inference is a \nnecessary step toward automatic narrative understanding and generation . However, this type of \ncommonsense social reasoning goes far beyond the widely studied entailment task s and thus falls \noutside the scope of existing benchmarks. \n \nQ2. What is SWAG in NLP? \nAnswer: \nSWAG stands for Situations with Adversarial Generations is a dataset consisting of 113k multiple -\nchoice questions about a rich spectrum of grounded situations. \n      Swag: A Large Scale Adversarial Dataset for Grounded Commonsense Inference \nAccording to NLP research paper on SWAG is \u201cGiven a partial description like \u201che opened the hood \nof the car,\u201d humans can reason about the situation and anticipat e what might come next ( \u201cthen, he \nexamined the engine\u201d). In this paper, you  introduce the task of grounded commonsense inference, \nunifying natural language inference(NLI), and common-sense reasoning.", "mimetype": "text/plain", "start_char_idx": 402875, "end_char_idx": 407412, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e907cdcf-5dcb-4b4f-94fd-3c5842eaf70a": {"__data__": {"id_": "e907cdcf-5dcb-4b4f-94fd-3c5842eaf70a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "baaa615a-af4a-45ba-bbf1-cfa67a4da6df", "node_type": "1", "metadata": {}, "hash": "26242a15125e422b3f055f9e642a9b4ab01c9f8cb1077162cdd1f50ebebfbf15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d71e50de-da67-41dd-8340-d754324987c8", "node_type": "1", "metadata": {}, "hash": "2b8727e63e03da32c63ba63d80dc1e3ef68e631421c2a85e4d979a584f02ed5a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We present S WAG, a dataset with 113k multiple -choice questions about the rich sp ectrum of \ngrounded positions. To address recurring challenges of annotation artifacts and human biases found \nin many existing datasets, we propose AF(Adversarial Filtering), a novel procedure that constructs a \nde-biased dataset by iteratively training an e nsemble of stylistic classifiers, and using them to filter \nthe data. To account for the aggressive adversarial filtering, we use state-of-the-art language models \nto oversample a diverse set of potential counterfactuals massively . Empirical results present that \nwhile humans can solve the resulting inference problems with high accuracy (88%), various \ncompetitive models make an effort on our task. We provide a comprehensive analysis that indicates \nsignificant opportunities for future research. \nWhen we read a tale, we bring to it a large body of implied knowledge about the physical world. For \ninstance, given the context \u201con stage, a man takes a seat at the piano,\u201d we can easily infer what the \nsituation might look like: a man is giving a piano performance, with a crowd watching him. We can \nfurthermore infer him likely next action: he will most likely set his fingers on the piano key and start \nplaying.P a g e  3 | 12 \n \nThis type of natural language inference (NLI) requires common -sense reasoni ng, substantially \nbroadening the scope of prior work that focused primarily on linguistic entailment. Whereas the  \ndominant entailment paradigm asks if 2  natural language sentences (the \u2018premise\u2019 and the \n\u2018hypothesis\u2019) describe the same set of possible worlds,  here we focus on whether a (multiple-choice) \nending represents a possible ( future) world that can a  from the situation described in the premise, \neven when it is not strictly entailed. Making such inference necessitates a rich understanding of \neveryday physical conditions, including object affordances and frame semantics.P a g e  4 | 12 \n \nQ3. What is the Pix2Pix network? \nAnswer: \nPix2Pix network: It is a Conditional GANs (cGAN) that learn the mapping from an input image to \noutput an image. \n \nImage-To-Image Translation  is the  process for trans lating one representation of the image into \nanother representation. \nThe image -to-image translation is another example of a task that GANs (Generative Adversarial \nNetworks) are ideally suited for. These are tasks in which it is nearly impossible to hard-code a loss \nfunction. Studies on GANs are concerned with novel image synthesis, translating from a random \nvector z into an image. Image -to-Image translation converts one image to another like the edges of \nthe bag below to the photo image. Another exciting example of this is shown below: \n \nIn Pix2Pix Dual Objective Function with an Adversarial and L1 Loss \nA naive way to do Image -to-Image tran slation would be to discard the adversarial framework \naltogether. A source image would just be passed through a parametric function, and the difference in \nthe resulting image and the  ground truth output would be used to update the weights of the \nnetwork. However, designing this loss function with standard distance measures s uch as L1 and L2 \nwill fail to capture many of the essential distinctive characteristics between these images. However,P a g e  5 | 12 \n \nauthors do find some value to the L1 loss function as a weighted sidekick to the adversarial loss \nfunction. \nThe Conditional-Adversarial Loss (Generator versus Discriminator) is very popularly formatted as \nfollows: \n \nThe L1 loss function previously mentioned is shown below: \n \n \n \nCombining these functions results in: \n \nIn the experiments, the authors report that they found the most success wit h the lambda parameter \nequal to 100. \n \n \nQ4. Explain UNet Architecture? \nAnswer: \nU-Net architecture: It is built upon the Fully Convolutional Network and modified in a way that it \nyields better segmentation in medical imaging. Compared to FCN-8, the two main differences are (a) \nU-net is symmetric and (b ) the skip connections betwe en the downsampling path and  upsampling \npath apply a concatenation operator instead of a sum. These skip connections intend to provide local \ninformation to the global information while upsampling. Because of its symmetry, the network has a \nlarge number of feature maps in the upsampling path, which allows t ransferring information.", "mimetype": "text/plain", "start_char_idx": 407414, "end_char_idx": 411802, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d71e50de-da67-41dd-8340-d754324987c8": {"__data__": {"id_": "d71e50de-da67-41dd-8340-d754324987c8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e907cdcf-5dcb-4b4f-94fd-3c5842eaf70a", "node_type": "1", "metadata": {}, "hash": "162daf551e6074c2d047a371e00630f08e7a7e62833b19f264bef49ba967cf81", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bbe816f8-8a7f-4e26-bf41-dd1102129f7f", "node_type": "1", "metadata": {}, "hash": "cc02c642d59c1fa13eebebfa724ac5d3c016785326a37a5ef94f02cf5900cacf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "By \ncomparison, the underlying FCN architecture only had  the number of classes  feature maps in  its \nupsampling way.P a g e  6 | 12 \n \n How does it work? \n \nThe UNet architecture looks like a \u2018U,\u2019 which justifies its name. This UNet architecture consists of \n3 sections: The contraction, the bottleneck, and the expansion section. The contraction section is \nmade of many contraction blocks. Each block takes an input that applies two 3X3 convolution layers, \nfollowed by a 2X2 max pooling. The number of features or kernel maps after each block doubles so \nthat UNet architecture can learn complex structures. B ottommost layer mediates between  the \ncontraction layer and the  expansion layer. It uses two 3X3 CNN layers followed by 2X2 up \nconvolution layer. \nBut the heart of this architecture lies in the expansion section. Similar to the contraction layer, it also \nhas several expansion blocks. Each block passes  input to two 3X3 CNN layers , followed by a 2X2 \nupsampling layer. After each block number of feature maps used by the convolutional layer, get half \nto maintain s ymmetry. However, every time  input is also get appended by feature maps of the \ncorresponding contraction layer. This action would e nsure that features that are  learned while \ncontracting the image will be used to re construct it. The number of expansion blocks is as same as \nthe number of contraction blocks. After that, the resultant mapping passes through another 3X3 CNN \nlayer, with the number of feature maps equal to the number of segments desired.P a g e  7 | 12 \n \n \n \n \nQ5. What is pair2vec? \nAnswer: \n This paper pre  trains word pair representations  by maximizing pointwise mutual information of \npairs of words with their context. This encourages a model to learn more meaningful representations \nof word pairs than with more general objectives, like modeling. The pre-trained representations are \nuseful in tasks like SQuAD and MultiNLI that requi re cross-sentence inference. You can expect to \nsee more pretraining tasks that capture properties particularly suited to specific downstream tasks and \nare complementary to more general-purpose tasks like language modeling. \nReasoning about implied relationships between pairs of words is crucial for cross sentences inference \nproblems like question answering (QA) and natural language i nference (NLI). In NLI, e.g., given a \npremise such as \u201c golf is prohibitively expensive ,\u201d inferring that the hypothesis \u201c golf is a cheap \npastime\u201d is a contradiction requires one to know that  expensive and cheap are antonyms. Recent \nwork has shown that current models, which rely heavily on unsupervised single -word embeddings, \nstruggle to grasp such relationships. In this pair2vec paper, w e show that they can be learned with \nword pair2vec(pair vector), which are trained, unsupervised, at a huge scale, and which significantly \nimprove performance when added to existing cross-sentence attention mechanisms.P a g e  8 | 12 \n \n \nUnlike single word representations, which are typically trained by modeling the co -occurrence of a \ntarget word x with its context c, our word-pair representations are learned by modeling the three-way \nco-occurrence between two words  (x,y) and the context  c that ties them together, as illustrated in \nabove Table . While similar training signal  has been used to learn models for ontology \nconstruction and knowledge base completion, this paper shows, for the first time, that considerable \nscale learning of pairwise embeddings can be used to improve the performance of neural cross -\nsentence inference models directly. \n \n \nQ6. What is Meta-Learning? \nAnswer: \nMeta-learning: It is an exciting area of research that tackles the problem of learning to learn. The goal \nis to design models that  can learn new skills or fastly  to adapt to new environments with minimum \ntraining examples. Not only does this dramatically speed up and improve the design of ML(Machine \nLearning) pipelines or neural architectures, but it also allows us to replace hand -engineered \nalgorithms with novel approaches learned in a data-driven way.P a g e  9 | 12 \n \nThe goal of meta-learning is to train the  model on a variety of learnin g tasks, such that it can solve \nnew learning tasks with only a small number of training samples. It tends to focus on finding model \nagnostic solutions, whereas multi-task learning remains deeply tied to model architecture.", "mimetype": "text/plain", "start_char_idx": 411803, "end_char_idx": 416236, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bbe816f8-8a7f-4e26-bf41-dd1102129f7f": {"__data__": {"id_": "bbe816f8-8a7f-4e26-bf41-dd1102129f7f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d71e50de-da67-41dd-8340-d754324987c8", "node_type": "1", "metadata": {}, "hash": "2b8727e63e03da32c63ba63d80dc1e3ef68e631421c2a85e4d979a584f02ed5a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c2c634d1-50f4-4a42-9e5f-600ecd38ec0d", "node_type": "1", "metadata": {}, "hash": "281f7cbc2c6383190408018df6873245d117ac14ca6d8b4fd0f5c6c06b42d923", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Thus, meta-level AI algorithms make AI systems: \n\u00b7 Learn faster \n\u00b7 Generalizable to many tasks \n\u00b7 Adaptable to environmental changes like in Reinforcement Learning \nOne can solve any problem with a single model, but meta-learning should not be confused with one-\nshot learning. \n \n \nQ7. What is ALiPy(Active Learning in Python)? \nAnswer: \nSupervised ML methods usually require a large set of labeled examples for model training. \nHowever, in many real applications, there are ample unlabeled data but limited labeled data; and \nacquisition of labels is costly. Active learning (AL) reduces labeling costs by iteratively selecting \nthe most valuable data to query their labels from the annotator. \nActive learning is the leading approach to learning with limited labeled data. It tries to reduce \nhuman efforts on data annotation by actively querying the most prominent examples. \nALiPy is a Python toolbox for active learning(AL), which is suitable for various users. On the one \nhand, the entire process of active learning has been well implemented. Users can efficiently \nperform experiments by many lines of codes to finish the entire process from data pre-processes toP a g e  10 | 12 \n \nresult in visualization. More than 20 commonly used active learning(AL) methods have been \nimplemented in the toolbox, providing users many choices. \n \nQ8.What is the Lingvo model? \nAnswer: \nLingvo: It is a Tensorflow framework offering a complete solution for collaborative deep learning \nresearch, with a particular focus towards sequence-to-sequence models. These models are composed \nof modular building blocks that are flexible and easily extensible, and experiment configurations are \ncentralized and highly customizable. Distributed training and quantized inference are supported \ndirectly within a framework, and it contains existing implementations of an ample number of utilities, \nhelper functions, and newest research ideas. This model has been used in collaboration by dozens of \nresearchers in more than 20 papers over the last two years. \nWhy does this Lingvo research matter? \nThe process of establishing a new deep learning (DL) system is quite complicated. It involves \nexploring an ample space of design choices involving training data,  data processing logic, the size , \nand type of model components, the opti mization procedures, and the path  to deploy ment. This \ncomplexity requires the framework that quickly facilitates the production of new combinations and \nthe modifications from existing documents and experiment s and shares these new results. It is a \nworkspace ready to be u sed by deep learning researchers or developers . Nguyen Says: \u201cWe ha ve \nresearchers working on state -of-the-art(SOTA) products and research algorithms, basing their \nresearch off of the same codebase. This ensures that code is battle-tested. Our collective experience \nis encoded in means of good defaults and primitives that we have found useful over these tasks.\u201dP a g e  11 | 12 \n \n \n \nQ9. What is Dropout Neural Networks? \nAnswer: \nThe term \u201cdropout\u201d refers to dropping out units (both hidden and visible) in a neural network. \nAt each training stage, individual nodes are either dropped out of the net with probability 1-p or kept \nwith probability p, so that a reduced network is left; incoming and outgoing edges to a dropped -out \nnode are also removed. \nWhy do we need Dropout? \nThe answer to these questions is \u201cto prevent over-fitting.\u201d \nA fully connected layer occupies most of the parameters, and hence, neurons develop co-dependency \namongst each other during training, which curbs the individual power of each neuron leading to over-\nfitting of training data.P a g e  12 | 12 \n \nQ10. What is GAN? \nAnswer: \nA generative adversarial network (GAN): It is a class of machine learning systems invented by Ian \nGoodfellow and his colleagues  in 2014. Two neural networks are contesting with each other in a \ngame (in the idea of game theory, often but not always in  the form of a  zero-sum game). Given a \ntraining set, this technique lear ns to generate new data with  the same statistics as the training set. \nE.g., a GAN trained on photographs can produce original pictures that look at least superficially \nauthentic to human observers, having many realistic characteristics. Though initially proposed as a \nform of  a generative model  for unsupervised learning , GANs have also proven useful for  semi-\nsupervised learning,[2] fully supervised learning, and reinforcement learning. \nExample of GAN \n \n\uf0b7 Given an image of a face, the network can construct an image that represents how that person \ncould look when they are old.", "mimetype": "text/plain", "start_char_idx": 416238, "end_char_idx": 420884, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c2c634d1-50f4-4a42-9e5f-600ecd38ec0d": {"__data__": {"id_": "c2c634d1-50f4-4a42-9e5f-600ecd38ec0d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bbe816f8-8a7f-4e26-bf41-dd1102129f7f", "node_type": "1", "metadata": {}, "hash": "cc02c642d59c1fa13eebebfa724ac5d3c016785326a37a5ef94f02cf5900cacf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9fea6d73-ba39-4916-8889-e3e6d0ca947a", "node_type": "1", "metadata": {}, "hash": "4c9bc9caf150e03fb129504b0167a944e213e47d7e57c8dc85927d96833aaaa4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Generative Adversarial Networks takes up a game -theoretic approach, unlike a conventional neural \nnetwork. The network learns to generate from a train ing distribution through a 2 -player game. The \ntwo entities are Generator and Discriminator. These two adversaries are in constant battle throughout \nthe training process.Page 1 of 15 \n \n \n \n \n \n \nDATA SCIENCE \nINTERVIEW PREPARATION \n(30 Days of Interview \nPreparation) \n# Day-25Page 2 of 15 \n \nQ1. What is WRN? \nAnswer: \nWRN: It stands for Wide Residual Networks is presented. By widening Residual Network (ResNet), the \nnetwork can be more superficial or shallow with  same accuracy or improved accuracy.  More external \nnetwork means: \n\uf0b7  the number of layers can be reduced. \n\uf0b7 Training time can be shorter, as well. \n \nProblems on Residual Network (ResNet) \nCircuit Complexity Theory \nThe authors of residual networks (ResNet) tried to make them as thin as possible in favor of increasing \ntheir depth and having less parameters and even introduced a \u00abbottleneck\u00bb block, which makes ResNet \nblocks even thinner. \nDiminishing Feature Reuse \nHowever, As gradient flows through  network, there is nothing to force it to go through residual block \nweights, and it can avoid learning anything during training, so there may be either only few blocks that \nlearn useful representations or many blocks share very little information with a small contribution to the \nfinal goal. This problem was formulated as a diminishing feature reuse. \nWRNs (Wide Residual Networks) \nIn WRNs, plenty of parameters are tested like the design of  ResNet block, how deep (deepening factor l), \nand how extensive (widening factor k ) within the ResNet block.Page 3 of 15 \n \nWhen k=1, it has the same width as the ResNet. While k>1, it is k time wider than ResNet. \nWRN-d-k: means the WRN has a depth of d and with widening factor k. \n\uf0b7 Pre-Activation ResNet is used in CIFAR-10, CIFAR-100, and SVHN datasets. Original ResNet is \nused in the ImageNet dataset. \n\uf0b7 The significant difference is that  Pre-Activation ResNet has the structure of performing batch \nnorm and ReLU before convolution (i.e. , BN-ReLU-Conv) while original  ResNet has the  \nstructure of Conv-BN-ReLU. And Pre-Activation ResNet is generally better than the original one, \nbut it has no visible improvement in ImageNet when layers are only around 100. \nThe design of the ResNet block \n \n\uf0b7  \n\uf0b7 B(3;3): Original \u00abbasic\u00bb block, in the above figure a. \n\uf0b7 B(3;1;3): With one extra ( 1\u00d71 ) layer in between the two 3\u00d73 layers \n\uf0b7 B(1;3;1): With  the  same dimensionality of all convolutions, bottleneck \n\uf0b7 B(1;3): The network has the alternating (1\u00d71, 3\u00d73) convolutions. \n\uf0b7 B(3;1): The network has the alternating( 3\u00d73, 1\u00d71) convolutions. \n\uf0b7 B(3;1;1): This is Network in Network style block. \nB(3;3) has the smallest error rate (5.73%).Page 4 of 15 \n \nNote: The Number of depths (layers) is different is to keep the number of parameters close to each \nother. \nQ2.What is SIMCO: SIMilarity-based object Counting? \nAnswer: \nMost approaches for counting similar objects in images assume a single object class; when is not, ad-hoc \nlearning is necessary. None of them are genuinely agnostic and multi-class, i.e., able to capture repeated \npatterns of different types without any tuning. Counting appr oaches are based on density or regression \nestimation; here, we focus on counting by detection, so the counted objects are individually detected first. \nResearch on agnostic counting is vital in many fields. It serve s for obvious question answering, where \ncounting questions could be made on too -specific entities outside the semanti c span of the available \nclasses (e.g., \u201cWhat is the most occurrent thing?\u201d in below Fig.). In representation learning, unsupervised \ncounting of visual primitives (i.e., vis ible \u201cthings\u201d) is crucial to obt ain a rich image representation .", "mimetype": "text/plain", "start_char_idx": 420888, "end_char_idx": 424760, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9fea6d73-ba39-4916-8889-e3e6d0ca947a": {"__data__": {"id_": "9fea6d73-ba39-4916-8889-e3e6d0ca947a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c2c634d1-50f4-4a42-9e5f-600ecd38ec0d", "node_type": "1", "metadata": {}, "hash": "281f7cbc2c6383190408018df6873245d117ac14ca6d8b4fd0f5c6c06b42d923", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "750889aa-8c7f-4f64-a702-59b5978021a5", "node_type": "1", "metadata": {}, "hash": "ae152a98ecca3f23b3c6437bb616d150740cb3874f81553a1b99b043e4bb17a8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Counting is a hot topic in cognitive robotics, where autonomous agents learn by separating sensory input \ninto the finite number of classes (without a precise semantics), building the  classification system that \ncounts on each of them.  \nApplication-wise, agnostic counting may help the manual tagging of training images, providing a starting \nguess for the annotator on single - or multi-spectral images. Inpainting filters may benefit from a magic \nwand capturing repeated instances to remove.  \n \nFigure: SIMCO on obvious question answering: the most occurrent  object? SIMCO finds 47 LEGO \nheads.Page 5 of 15 \n \nIn this paper, we present the SIMCO (SIMilarity-based object COunting) approach, which is entirely \nagnostic, i.e. , with no need for any ad-hoc class-specific fine -tuning, and multi -class, i.e. , finding \ndifferent types of repeated patterns. Two main ideas characterize SIMCO. \nFirst, every object to be counted is considered as a specialization of a basic 2D shape: this is particularly \ntrue with many and small objects  (see in above Fig : LEGO heads c an be approximated as circles). \nSIMCO incorporates this idea building upon the novel Mask-RCNN-based classifier, fine-tuned just once \non a novel synthetic shape dataset, InShape. \nThe second idea is that leveraging on the 2D shape approximation of objects; one can naturally perform \nunsupervised grouping of the detected objects (grouping circles with circles , etc.), \ndiscovering different types of repeated entities (without resorting to a particular set of classes). SIMCO \nrealizes this with a head branch in the network architecture implementing triplet losses, which provides \na 64-dim embedding that maps objects close if they share the same shape class plus some appearance \nattributes. Affinity propagation clustering finds groups over this embedding. \nQ3. What is Voice-Face Cross-modal Matching and Retrieval? \nAnswer: \nStudies in biology and neuroscience have shown that human\u2019s appearances a re associated with their \nvoices. Both the facial features and voice-controlling organs of individuals are affected by hormones and \ngenetic information. Human beings can recognize this association. For example: when hearing from the \nphone call, we can guess the gender, the approximate age of the person on the other end of the line. When \nwatching an unvoiced TV show. We can imagine an approximate voice by observing the face movement \nof the protagonist. With the recent advances of deep le arning, face recognition models , and speaker \nrecognition models have achieved exceptionally high precision. Can the associations between voices and \nfaces be discovered algorithmically by machines? The research on this problem can benefit a lot of \napplications such as synchronizing video faces and talking sound, generating faces according to voices. \nIn recent years, much research attention  has been paid  on the voice -face cross-modal learning tasks, \nwhich have shown the feasibility of recognizing voice -face associations. This problem is generally \nformulated as a voice-face matching task and the voice-face retrieval task, as shown in Figure 1. Given \na set of voice audios and faces, voice-face matching is to tell which look makes the voice when machine \nhearing voice audio. Voice -face retrieval is to present a sorted sequence of faces in the order of  thePage 6 of 15 \n \nestimated match from a query of voice recording.\n \nSVHF is the prior of voice-face cross-modal learning, which studies the performance of CNN-based deep \nnetwork on this problem. The human\u2019s baseline for the voice-face matching task is also proposed in the \npaper. Both the \u201cvoice to face\u201d and the \u201cface to voice\u201d matching tasks are studied in the Pins and \nHoriguchi\u2019s work, which exhibits similar performance on these two tasks. The c urriculum learning \nschedule is introduced in Pins for hard negative mining. Various visualizations of the embedding vectors \nare presented to show the learned audio-visual associations in Kim\u2019s work. DIMNet learns the common \nrepresentations for faces and voices by leveraging their relationship with some covariates such as gender \nand nationality. DIMNet obtains an accuracy of 84.12% on the 1:2 matching, which exceeds the human \nlevel. \nResearch on this problem is still in the early stage. Datasets used by previous research are always tiny, \nwhich can\u2019t evaluate the generalization ability of models sufficiently. Traditional test schemes based on \nrandom tuple minin g tend to have low confidence. The  benchmark for this problem needs to be \nestablished. This paper presents the voice-face cross-modal matching and retrieval framework, a dataset \nfrom Chinese speakers and a data collection tool.", "mimetype": "text/plain", "start_char_idx": 424762, "end_char_idx": 429478, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "750889aa-8c7f-4f64-a702-59b5978021a5": {"__data__": {"id_": "750889aa-8c7f-4f64-a702-59b5978021a5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9fea6d73-ba39-4916-8889-e3e6d0ca947a", "node_type": "1", "metadata": {}, "hash": "4c9bc9caf150e03fb129504b0167a944e213e47d7e57c8dc85927d96833aaaa4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4d26a338-2094-415b-b90a-e4d55fb27348", "node_type": "1", "metadata": {}, "hash": "6eae498f4008a8f0e7fb5d060ab631a826206e9affbda37e9c31a93a3fda1415", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In the frame, cross-modal embeddings are learned with \nCNN-based networks, and triplet loss in a voice anchored metric space with L2 -Norm constraint. An \nidentity-based example sampling method is adopted to improve the model efficiency. The proposed \nframework achieves state -of-the-art performanc e on multiple tasks. For example, the result of 1:2 \nmatching tested on 10 million triplets (thousands of people) reached 84.48%, which is also higher than \nDIMNet tested on 189 people. We have evaluated the various modules of the CNN -based framework \nand provided our recommendations. Even matching and retrieval based on the average of multiple voices \nand multiple faces are also attempted, which can  further improve the performance. This task is the \nsimplest way of analyzing video data. Large -scale datasets are  used in this problem to ensure the \ngeneralization ability required in a real application. The cross-language transfer capability of the model \nis studied on the voice -face dataset of Ch inese speakers we constructed. The  series of performancePage 7 of 15 \n \nmetrics are presented on the tasks by extensive experiments. The source code of the paper and the dataset \ncollection tool will be published along with the article. \nQ4. What is CenterNet: Object Detection with Keypoint Triplets? \nAnswer: \nObject detection has been significantly improved and advanced with the help of deep learning, especially \nconvolutional neural networks (CNNs). In the current era, one of the most popular flowcharts is anchor-\nbased, which placed the set of rectangles with pre-defined sizes, and regressed them to the desired place \nwith the help of  the ground-truth objects. These approaches often need a large number of anchors to \nensure the sufficiently high IoU (intersection over union) rate with the ground-truth objects, and the size \nand aspect ratio of each anchor box needs to be manually designed. Also, anchors are usually not aligned \nwith the ground-truth boxes, which is not conducive to bounding box classification tasks. \nTo overcome the drawbacks of anchor based approaches, a keypoint -based object detection p ipeline \nnamed CornerNet was proposed. It represented each object by a pair of corner key points, which bypassed \nthe need for anchor boxes and achieved the state -of-the-art one -stage object dete ction accuracy. \nNevertheless, the performance of CornerNet is still restricted by its relatively weak ability to refer to the \nglobal information of an object. That is to say since a pair of corners construct each object, the algorithm \nis sensitive to detect the boundary of objects, meanwhile not being aware of which pairs of critical points \nshould be grouped into the objects. Consequently, as shown in Figure a, it often generates some incorrect \nbounding boxes, most of w hich could be easily filtered out with complementary information,  e.g., the \naspect ratio. \n \nTo address this issue, we equip CornerNet with an ability to perceive the visual patterns within each \nproposed region, so that it can identify the correctness of each bounding box by itself. In this paper, we \npresent the  low-cost yet effective solution named  CenterNet, which explores the central part of the  \nproposal, i.e., the region that is close to the geometric center, with one extra keypo int. Our intuition is \nthat, if the predicted bounding box has a high IoU with the ground -truth box, then the probability that \nthe center key  point in its central region is predicted as the same class is high, and vice versa.  Thus, \nduring inference, after the proposal is generated as a pair of corner keypoints, we determine if the p lan \nis indeed an object by checking if there is a crucial central point of the same class falling within its centralPage 8 of 15 \n \nregion. The idea, as shown in Figure a, is to use a triplet instead of a pair of key points to represent each \nobject. \nAccordingly, for better detecting the center keypoints and corners, we propose two strategies to enrich \ncenter and corner information, respectively. The first strategy is named as center pooling, which is used \nin the branch for predicting the center keypoints. Center pooling helps the center keypoints obtain more \nrecognizable visual patterns within objects, w hich makes the central part of the  proposal be better \nperceived. We achieve this by getting out the max summed response in both horizontal and vertical \ndirections of the center key point on a feature map for predicting center keypoints. The second strategy \nis named cascade corner pooling , which equips the  original corner pooling module  with the ability to \nperceive internal information. We achieve this by getting out the max summed response in both boundary \nand inner directions of objects on a feature map for predicting corners.", "mimetype": "text/plain", "start_char_idx": 429479, "end_char_idx": 434293, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4d26a338-2094-415b-b90a-e4d55fb27348": {"__data__": {"id_": "4d26a338-2094-415b-b90a-e4d55fb27348", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "750889aa-8c7f-4f64-a702-59b5978021a5", "node_type": "1", "metadata": {}, "hash": "ae152a98ecca3f23b3c6437bb616d150740cb3874f81553a1b99b043e4bb17a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aef1a3a4-c638-477e-b9b3-64d2e035ce76", "node_type": "1", "metadata": {}, "hash": "0ffffbbca5a8bfd4f0b3b0a830961b5cbaddd36e7ac62a8a31df4e0306ea8de7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Empirically, we verify that such \nthe two-directional pooling method is more stable,  i.e., being more robust to the feature-level noises, \nwhich contributes to the improvement of both precision and recall. \nWe evaluate the proposed CenterNet on the MS-COCO dataset, one of the most popular benchmarks for \nlarge scale object detection. CenterNet, with both center pooling and  the cascade corner pooling \nincorporated, reports an AP of  47.0% on the test -dev set, which outperforms all e xisting one -stage \ndetectors by the extensive margin. With an average inference time of 270ms using a 52-layer hourglass \nbackbone and 340ms using a 104-layer hourglass backbone per image, CenterNet is quite efficient yet \nclosely matches the state-of-the-art performance of the other two-stage detectors. \nQ5. What is Task2Vec: Task Embedding for Meta-Learning? \nAnswer: \nThe success of Deep Learning hinges in part on the fact that models learned for one task can be used on \nthe other related tasks. Yet, no general framework exists to describe and learn relations between tasks. \nWe introduce task2vec embedding, the technique to represent tasks as elements of the  vector space is \nbased on the Fisher Information Matrix. The norms of the embedding correlates with the complexity of \nthe task, while the distance between embeddings captures  the semantic similarities between tasks \n(Fig. 1). When other natural dist ances are available, such as  taxonomical distance in  the biological \nclassification, we find that the embedding distance correlates positively with it (Fig.  2). Moreover, we \nintroduce an asymmetric distance on tasks that correlates with the transferability between tasks. \nComputation of the embedding leverages the duality between network parameters (weights) and outputs \n(activations) in a deep neural network (DNN): Just as the activations of a DNN trained on the complex \nvisual recognition task are the rich representation of the input images, we show that the gradients of the \nweights relative to a task-specific loss are the rich representation of the task itself. Specifically, given a \ntask defined by the dataset D={(xi,yi)}Ni=1 of labeled samples, we feed the data through a pre -trainedPage 9 of 15 \n \nreference convolutional neural network which we call \u201cprobe network\u201d, and compute the diagonal Fisher \nInformation Matrix (FIM) of the network filter parameters ,  to capture the structure of task. Since the \narchitecture and  weights of the probe network are fixed, t he FIM provides the  fixed-dimensional \nrepresentation of the tasks. We show this embedding encodes the \u201cdifficulty\u201d of the tasks, characteristics \nof the input domain, and features of the probe network are useful to solve it. \nOur task embedding can be used to reason about the space of  the tasks and solve meta -tasks. As a \nmotivating example, we study the problem of selecting the best pre -trained feature extractor to solve a \nnew task. This can be particularly valuable when there is insufficient data to train or fine-tune a generic \nmodel, and the transfer of knowledge is essential.  task2vec depends solely on the task and ignores \ninteractions with the model, which may, however, play an essential role. To address this, we learn about \nthe joint task and model embedding, called  model2vec, in such a way that models whose embeddings \nare close to a task exhibit excellent performance on the task. We use  this to select an expert from the  \ngiven collection, improving performance rela tive to fine -tuning a generic model trained on ImageNet \nand obtaining close to the ground-truth optimal selection. \n \n \n \nQ6. What is GLMNet: Graph Learning-Matching Networks for Feature  \n Matching? \nAnswer: \nMany problems of interest in computer vision and pattern recognition area can be formulated as a \nproblem of finding consistent correspondences between two sets of features, which are known as feature \nmatching problem. Feature set that incorporates the pairwise constraint can be represented via an attributePage 10 of 15 \n \ngraph whose nodes represent the unary descriptors of feature points , and edges encode the pairwise \nrelationships among different feature points. Based on this graph representation, feature matching can \nthen be reformulated as a graph node matching problem. \nGraph matching generally first operates with both node and edge affinities that encode similarities \nbetween the node and edge descriptors in two graphs. Then, it can be formulated mathematically as an \nIntegral Quadratic Programming (IQP) problem with p ermutation constraint on related solution s to \nencode the one-to-one matching constraints . It is known to be NP -hard.", "mimetype": "text/plain", "start_char_idx": 434294, "end_char_idx": 438971, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "aef1a3a4-c638-477e-b9b3-64d2e035ce76": {"__data__": {"id_": "aef1a3a4-c638-477e-b9b3-64d2e035ce76", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4d26a338-2094-415b-b90a-e4d55fb27348", "node_type": "1", "metadata": {}, "hash": "6eae498f4008a8f0e7fb5d060ab631a826206e9affbda37e9c31a93a3fda1415", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b68aa1f7-767a-4429-8f99-7f64db0c7186", "node_type": "1", "metadata": {}, "hash": "76aacf4c9ac74307d6bac21d73f84c58859c5a0fd35857221b938a8fb7d4b3b8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is known to be NP -hard. Thus, many methods usually \nsolve it approximately by relaxing the discrete permutation constraint and finding local ly optimal \nsolutions. Also, to obtain better node/edge affinities, learning methods have been investigated to \ndetermine the more optimal parameters in  node/edge affinity computation . Recently, deep learning \nmethods have also been developed for matching problems. The main benefit of deep learning matching \nmethods is that they can conduct visual feature representation, node/edge affinity learning, and matching \noptimization together in an en d-to-end manner. Zanfir et al.  propose an end -to-end graph matching \nmodel, which makes it po ssible to learn all the parameters of the graph  matching process. Wang et al.  \nrecently aim to explore graph convolutional networks (GCNs) for graph matching which conducts graph \nnode embedding and matching simultaneously in a unified system. \nInspired by re cent deep graph matching methods, in this paper, we propose a novel Graph Learning -\nMatching Network (GLMNet) for graph matching problems. Overall, the main contributions of this paper \nare three aspects. \nFirst, a critical aspect of (feature) graph matching is the construction of two matching graphs. Exis ting \ndeep graph matching models generally use fixed structure graphs, such as k -NN, Delaunay graph, etc., \nwhich thus are not guaranteed to serve the parallel task best . To address this issue, we propose to \nadaptively learn a pair of optimal graphs for the matching task and integrate  graph learning and graph \nmatching simultaneously in a unified end-to-end network architecture. \nSecond, the existing GCN based graph matching model  adopts the general smoothing ba sed graph \nconvolution operation for graph node embedding, which may encourage the feature embedding of each \nnode becoming more similar to those of its neighboring nodes. This is desirable for graph node labeling \nor classification tasks, but undesirable for the matching task because extensive smoothing convolution \nmay dilute the discriminatory information. To alleviate this effect, we propose to incorporate a Laplacian \nsharpening based graph convolution operation for graph node embedding and matching tasks. Laplacian \nsharpening process can be regarded as the counterpart of Laplacian smoothing which encourages the \nembedding of each node farther away from its neighbors. \nThird, existing deep graph matching methods generally utilize a doubly stochastic normalization for the \nfinal matching prediction. This usually ignores the discrete one-to-one matching constraints in matchingPage 11 of 15 \n \noptimization/prediction. To overcome this issue, we develop a novel constraint regularized loss to further \nincorporate the one-to-one matching constraints in matching prediction. \nExperimental results , including ablation studies , demonstrate the effectiveness of our GLMNet and \nadvantages of devised components , including graph learning -matching architecture, Laplacian \nsharpening convolution for discriminative embedding, and constraint regularized loss to encode one-to-\none matching constraints. \n \nQ7. What is SSAP: Single-Shot Instance Segmentation With Affinity  \n Pyramid? \nAnswer: \nThe rapid development of Convolutional networks has revolutionized various vision tasks, enabling us \nto move towards a more fine-grained understanding of images. Instead of classic boun ding-box level \nobject detection  or cl ass-level semantic segmentation , instance segmentation provides in -depth \nknowledge by segmenting all the objects and distinguish  different object instances. Researchers are \nshowing increasing interests in instance segmentation recently. \nCurrent state -of-the-art solutions to this challenging problem can be classified into the  proposal-\nbased and proposal-free approaches. The proposal-based methods regard it as an extension to the classic \nobject detection task. After localizing each object with a bounding box, the foreground mask is predicted \nwithin each bounding box proposal. However, the performances of the scheme based methods are highly \nlimited by the quality of the bounding box predictions, and the two-stage pipeline also limits the speed \nof systems. By contrast, the proposal-free approach has the advantage of its efficient and straightforward \ndesign. This work also focuses on the proposal-free paradigm.Page 12 of 15 \n \n \nThe proposal-free methods mostly start by producing instance-agnostic pixel-level semantic class labels, \nfollowed by clustering them into the different object instances with particularly designed instance-aware \nfeatures. However, previous methods mainly treat the two sub -processes as the two separate stages and \nemploy multiple modules, which is suboptimal. The mutual benefits between the two sub -tasks can be \nexploited, which w ill further improve the performance of  the instance, segmentation. Moreover, \nemploying multiple modules may result in additional computational costs for real-world applications.", "mimetype": "text/plain", "start_char_idx": 438944, "end_char_idx": 443980, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b68aa1f7-767a-4429-8f99-7f64db0c7186": {"__data__": {"id_": "b68aa1f7-767a-4429-8f99-7f64db0c7186", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aef1a3a4-c638-477e-b9b3-64d2e035ce76", "node_type": "1", "metadata": {}, "hash": "0ffffbbca5a8bfd4f0b3b0a830961b5cbaddd36e7ac62a8a31df4e0306ea8de7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "46e73ea5-a864-4ee0-95b1-f43a302154a5", "node_type": "1", "metadata": {}, "hash": "6fc45ce40648b1716bac55536c308434e54d79af8801eb57d4985d9d73b3c058", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Moreover, \nemploying multiple modules may result in additional computational costs for real-world applications. \nTo cope with the above issues, this work proposes a single -shot proposal-free instance segmentation \nmethod, which jointly learns the pixel -level semantic class segmentation and object instance \ndifferentiating in a unified model with a single backbone network, as shown in Fig.  1. Specifically, for \ndistinguishing different object instances, an affinity pyramid is proposed , which can be jointly learned \nwith the labeling of semantic classes. The pixel -pair affinity computes the probability that two pixels \nbelong to the same instance. In this work, the short-range relationships for pixels close to each other are \nderived with dense small learning windows. Simultaneously, the long -range connections for pixels \ndistant from each other are also required to group objects with large scales or nonadjacent parts. Instead \nof enlarging the windows, the multi -range relationships are decoupled, and long-range connections are \nsparsely derived from the instance maps with lower resolutions. After that, we propose learning the \naffinity pyramid at multiple scales along the hierarchy of a U-shape network, where the short-range and \nlong-range affinities are effectively learned from the feature levels with the higher and lower resolutions \nrespectively. Experiments in Table 3 show that the pixel-level semantic segmentation and the pixel-pair \naffinity pyramid based grouping are indeed mutually benefited from the proposed joint learning scheme. \nThe overall instance of segmentation is thus further improved. \nThen, to utilize the cues about global context reasoning, this work e mploys a graph partition method to \nderive instances from the learned affinities. Unlike previous time -consuming methods, the cascaded \ngraph partition module is presented to incorporate the graph partition process with the hierarchical \nmanner of the affinity pyramid and finally provides both acceleration and performance improvements. \nConcretely, with the learned pixel-pair affinity pyramid, the graph is constructed by regarding each pixelPage 13 of 15 \n \nas the  node and transforming affinities into the edge scores. Graph partition is then employed from \nhigher-level lower-resolution layers to the lower-level higher-resolution layers progressively. Instance \nsegmentation predictions from the lower resolutions produce confident proposals, which significantly \nreduce node numbers at higher resolutions. Thus the whole process is accelerated. \nQ8. What is TENER: Adapting Transformer Encoder for Name Entity  \nRecognition? \nAnswer: \nThe named entity recognition (NER) is the task of finding the  start and end of an entity in the  sentence \nand assigning a class for this entity. NER has been widely studied in the field of natural language \nprocessing (NLP) because of its potential assistance in question generation  Zhou et al. (2017), relation \nextraction Miwa and Bansal ( 2016), and co reference resolution Fragkou (2017). Since Collobert et al. \n(2011), various neural models have been introduced to avoid the hand-crafted features  Huang et  al. \n(2015); Ma and Hovy (2016); Lample et al.  \nNER is usually viewed as a sequence labeling task, the neural models typically contain three components: \nword embedding layer, context encoder layer, and decoder layer  Huang et al. ( 2015); Ma and Hovy \n(2016); Lample et  al. ( 2016); Chiu and Nichols ( 2016); C hen et  al.  Zhang et  al. ( 2018); Gui et  al. \n(2019b). The difference between various NER models mainly lies in the variance in these components. \nRecurrent Neural Networks (RNNs) are widely employed in NLP tasks due to its sequential \ncharacteristic, which is aligned well with the language. Specifically, bidirectional extended short-term \nmemory networks (BiLSTM) Hochreiter and Schmidhuber (1997) is one of the most widely used RNN \nstructures. (Huang et  al., 2015) was the first one to apply the BiLSTM and  the Conditional Random \nFields (CRF) Lafferty et al. (2001) to sequence the labeling tasks. Owing to BiLSTM\u2019s  high power to \nlearn the contextual representation of words, it has been adopted by the majority of  the NER models as \nthe encoder Ma and Hovy (2016); Lample et al. (2016); Zhang et al. (2018); Gui et al. \nRecently, Transformer Vaswani et al. (2017) began to prevail in the various NLP tasks, like machine \ntranslation Vaswani et  al. ( 2017), language modeling  Radford et  al.", "mimetype": "text/plain", "start_char_idx": 443869, "end_char_idx": 448360, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "46e73ea5-a864-4ee0-95b1-f43a302154a5": {"__data__": {"id_": "46e73ea5-a864-4ee0-95b1-f43a302154a5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b68aa1f7-767a-4429-8f99-7f64db0c7186", "node_type": "1", "metadata": {}, "hash": "76aacf4c9ac74307d6bac21d73f84c58859c5a0fd35857221b938a8fb7d4b3b8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8febec41-e86f-44d8-8ab6-7e53506d7de3", "node_type": "1", "metadata": {}, "hash": "cde665b54bf466ad94d5797bddc43439f0f42b5f338864ffd792b94230551482", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "( 2017), language modeling  Radford et  al. ( 2018), and pretraining \nmodels Devlin et al. (2018). The Transformer encoder adopts the fully-connected self-attention structure \nto model the long-range context, which is the weakness of RNNs. Moreover, the Transformer has better \nparallelism ability than RNNs. However, in the NER task, Transformer encoder has been reported to \nperform poorly Guo et al. (2019), our experiments also confirm this result. Therefore, it is intriguing to \nexplore the reason why the Transformer does not work well in the NER task.Page 14 of 15 \n \n \nThe first is that the sinusoidal position embeddi ng used in the vanilla Transformer is relative distance \nsensitive and direction -agnostic, but this property will lose when used in the vanilla Transformer. \nHowever, both the direction and relative distance information are essential in the NER task. For example, \nwords after \u201cin\u201d are more likely to be a location or time than words before it, and words before \u201cInc.\u201d is \nmost likely to be of the entity type \u201cORG.\u201d Besides, an entity is a continuous span of words. Therefore, \nthe awareness of relative distance mig ht help the word better recognizes its neighbor. To endow the \nTransformer with the ability of directionality and relative distance awareness, we adopt direction-aware \nattention with the relative positional encoding Shaw et al. (2018); Huang et al. (2019); Dai et al. (2019). \nWe propose a revised relative positional encoding that uses fewer parameters and performs better. \nThe second is an empirical finding. The attention distribution of the vanilla Transformer is scaled and \nsmooth. But for NER, sparse attention is suitable since not all words are necessary to be attended. Given \nthe current word, a few contextual words are enough to jud ge its label. The smooth attention could \ninclude some noisy information. Therefore, we abandon the scale factor of dot-production consideration \nand the use of un-scaled and sharp attention. \nWith the above improvements, we can significantly boost the performance of the Transformer encoder \nfor NER. \nQ9. What is Subword ELMo? \nAnswer: \nRecently, pre-trained language representation has shown to be useful for improving many NLP tasks . \nEmbeddings from Language Models is one of the most outstanding works, which uses the character-\naware language model to augment word representation. \nAn essential challenge in training word-based language models is how to control the vocabulary size for \nbetter rare word representation. No matter how large the vocabulary is, unique words are always \ninsufficiently trained. Besides, an extensive vocabulary takes too much time and computational resources \nfor the model to converge. Whereas, if the dictionary is too small, the out -of-vocabulary (OOV) issue \nwill har m the model performance slowly . To obtain  effective word representation,  Jozefowicz et \nal. (2016) introduce character-driven word embedding using the convolutional neural network (CNN).Page 15 of 15 \n \nHowever, potential insufficiency when modeling word from characters which hold little linguistic sense, \nespecially, the morphological source. Only 86 roles are adopted in English writing, making the input too \ncoarse for embedding learning. As we argue that for the better representation from a refined granularity, \nthe word is too large, and character is too small, it is natural for us to consider subword unit s between \ncharacter and the word levels. \nSplitting the word into subwords and using them to augment the word representation may recover the \nlatent syntactic or semantic information . For example,  uselessness could be divided into the following \nsubwords: Previous work usually considers linguistic knowledge-based methods to tokenize each word \ninto the subwords (namely, morphemes). However, such treatment may encounter the three main \ninconveniences. First, the subwords from linguistic knowledge, typically i ncluding the morphological \nsuffix, prefix, and stem, may not be suitable for the  targeted NLP task Banerjee and Bhattacharyya or \nmislead the representation of some words, like the meaning of  understanding cannot be formed \nby under and stand. Second, linguistic knowledge, including related annotated lexicons or corpora, may \nnot even be available for the  specific low-resource language. Due to these limitations, we focus on the \ncomputationally motivated subword tokenization approaches in this work. \nIn this paper, we propose Embedding from Subword -aware Language Models (ESuLMo), which takes \nsubword as input to augment word representation and release a sizeable pre -trained language model \nresearch communities.", "mimetype": "text/plain", "start_char_idx": 448317, "end_char_idx": 452987, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8febec41-e86f-44d8-8ab6-7e53506d7de3": {"__data__": {"id_": "8febec41-e86f-44d8-8ab6-7e53506d7de3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "46e73ea5-a864-4ee0-95b1-f43a302154a5", "node_type": "1", "metadata": {}, "hash": "6fc45ce40648b1716bac55536c308434e54d79af8801eb57d4985d9d73b3c058", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36eeb847-6299-4dda-a0d4-073813419d88", "node_type": "1", "metadata": {}, "hash": "628e28f4026f2d849047f8c774e73b0321c9c17e04bb4774a22cb0a3d6f0b866", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Evaluations show that the pre -trained language models of ESuLMo outperform \nall RNN-based language models, including ELMo, in terms of PPL and ESuLMo beats state-of-the-art \nresults in three of four downstream NLP tasks. \n \n \n \n \n \n \n  \n \n \n------------------------------------------------------------------------------------------------------------------------------P a g e  1 | 16 \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview Preparation) \n \n# Day26P a g e  2 | 16 \n \nQ1.What is DCGANs ( Deep Convolutional Generative Advers arial \nNetworks)? \nAnswer: \nGANs stands for Generative adversarial networks, which is introduced by Ian Goodfellow in 2014.  GANs \nis entirely new way of teaching computers how they do complex tasks through a generative process.  \nGANs have two components. \n\uf0b7 A Generator (An artist) neural network. \n\uf0b7 A Discriminator (An art critic) neural network. \nGenerator (An artist) generates an image. Generator does not know anything about the real images and \nlearns by interacting with the  Discriminator. The Discriminator (An art critic) determines whether an \nobject is \u201creal\u201d and \u201cfake\u201d (usually represented by a value close to 1 or 0). \nHigh-Level DCGAN Architecture Diagram \n \nOriginal DCGAN architecture ( Unsupervised Representation Learning with Deep Convolutional \nGenerative Adversarial Networks ) have four convolutional layers for  Discriminator and \u201cfour \nfractionally-strided convolutions\u201d layers for  Generator.P a g e  3 | 16 \n \n \nThe Discriminator Network \nThe Discriminator is a \u201cart critic\u201d who tries to distinguish between \u201creal\u201d and \u201cfake\u201d images. This is a \nconvolutional neural network(CNN) for image classification. \nThe Discriminator is 4 layers strided convolutions with batch normalization (except its input layer) and \nleaky ReLU activations. Leaky ReLU helps the gradients flow easier through the architecture. \n \nThe Generator Network \nThe Generator is\u201cAn artist \u201d who tries to create an image  that looks as \u201c real\u201d as possible, to \nfool Discriminator. \nThe Generator is four layers fractional-strided convolutions with batch normalization (except its input \nlayer) and use Hyperbolic Tangent (tanh)activation in the final output layer and Leaky ReLU in rest of \nthe layers. \nTraining of DCGANs \nThe following steps are repeated in training \n\uf0b7 First Generator creates some new examples. \n\uf0b7 And the Discriminator is trained using real data and generated data.P a g e  4 | 16 \n \n\uf0b7 After Discriminator has been trained, models are trained together. \n\uf0b7 The Discriminator\u2019s weights are frozen, bu t its gradients are used in Generator model so \nthat  Generator can update it\u2019s weights. \n \nQ2. Explain EnAET. \nAnswer: \nEnAET: Self-Trained Ensemble AutoEncoding Transformations for Semi -Supervised Learning \nDeep neural network has shown its sweeping successes in learning from large-scale labeled datasets like \nImageNet. However, such successe s hinge on the availability of  large amount of labeled examples that \nare expensive to collect. Moreover, deep  neural networks usually have large number of parameters that \nare prone to over -fitting. Thus, we hope that semi-supervised learning can not only deal with  limited \nlabels but also alleviate the over -fitting problem by exploring unlabeled data. In this paper, we \nsuccessfully prove that both goals can be achieved by training the semi-supervised model built upon self-\nsupervised representations. \nSemi-Supervised Learning (SSL)  has been extensively studied due to its great potential for addressing \nthe challenge with limited labels. Most state -of-the-art approaches can be divided into two categories. \nOne is confident pr edictions, which improves a model\u2019s confidence by encouraging low entropy \nprediction on unlabeled data. The other category imposes consistency regularization  by minimizing \ndiscrepancy among the predictions by different models. The two approaches employ rea sonable \nobjectives since good models should make confident predictions that are consistent with each other.  \nOn the other hand, a goo d model should also recognize the  object even if it is transformed in different \nways. With deep networks, this is usually ac hieved by training a  model with augmented labeled data. \nHowever, unsupervised data augmentat ion is preferred to explore effect of various transformations on \nunlabeled data.", "mimetype": "text/plain", "start_char_idx": 452988, "end_char_idx": 457351, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "36eeb847-6299-4dda-a0d4-073813419d88": {"__data__": {"id_": "36eeb847-6299-4dda-a0d4-073813419d88", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8febec41-e86f-44d8-8ab6-7e53506d7de3", "node_type": "1", "metadata": {}, "hash": "cde665b54bf466ad94d5797bddc43439f0f42b5f338864ffd792b94230551482", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c8fea01d-a524-4b90-8512-a76e2be893ee", "node_type": "1", "metadata": {}, "hash": "6a77dd888de86e98c7deda609213fab3dcb70391b99915f11ca485ed7c159a88", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "For this reason, we will show that self -supervised representations learned from aut o-\nending the  ensemble of spatial and non -spatial transformations can play a key role in significantly \nenhancing semi -supervised models. To this end, we will present an Ensemble of Auto -Encoding \nTransformations (AETs)  to self -train semi -supervised classifie rs with various transformations by \ncombining the advantages of both existing semi -supervised approaches and the newly developed self -\nsupervised representations. \nOur contributions are summarized as follows:P a g e  5 | 16 \n \n\uf0b7 We propose first method that employs  ensemble of both spatial and non-spatial transformations \nfrom both labeled and unlabeled data in the  self-supervised fashion to train a semi -supervised \nnetwork. \n\uf0b7 We apply an ensemble of AETs to learn robust features under various transformations, and \nimprove the consist ency of the predictions on transformed images by minimizing their KL \ndivergence. \n\uf0b7 We demonstrate EnAET outperforms the state -of-the-art models on all benchmark datasets in \nboth semi-supervised and fully-supervised tasks. \n\uf0b7 We show in the ablation study that exploring an ensemble of transformations plays a key role in \nachieving new record performances rather than simply applying AET as a regularize . \nQ3. What is Data Embedding Learning? \nAnswer: \nUnsupervised word embeddings have become  basis for word representation in NLP tasks. Models such \nas skip-gram and Glove capture statistics of large corpus and have good pr operties that corresponds to  \nsemantics of word . However there are certain problems with unsupervi sed word embeddings, such as  \ndifficulty in modeling some fine -grained word semantics. For e.g., words in the same category but with \ndifferent polarities are often confused because those words share common statistic s in the corpus. \nIn supervised NLP(Natural Language Processing) tasks, these unsupervised word embeddings are often \nused in one of 2 ways: keeping fixed or using as initialization (fine -tuning). The decision is made based \non amount of available training data in order to avoid overfitting. Nonetheless, underfitting with keeping \nfixed and certain degree  of overfitting with fine -tuning is  inevitable. Because this all are none \noptimization of  word embeddings lacks control over the learning process, embeddings are not trained to \nan optimal point, which can result in suboptimal task performance. \nIn this paper, we propose  delta embedding learning , the novel method that aims to address a  above \nproblems together: using regularization to find  optimal fine -tuning of word embeddings. Better task \nperformance can be reached with prop erly optimized e mbeddings. At the same time,  regularized fine-\ntuning effectively combines semantics from supervised learning and unsupervised learning, which \naddresses some limitations in unsupervised embeddings and improves quality of embeddings. \nUnlike retrofitting, which learns directly from lexical resources, our method provides the  way to learn \nword semantics from supervised NLP(Natural Language Processing) tasks. Embeddings usually become \ntask-specific and lose its gene rality when trained along with t he model to maximize a task objective. \nSome approach tried to learn reusable embeddings from NLP (Natural Language Processing)  tasks \ninclude multi-task learning, where one predict  context words and e xternal labels at the same time , andP a g e  6 | 16 \n \nspecially designed gradient descent algorithms for fine -tuning .Our method learns reusable supervised \nembeddings by fine-tuning unsupervised embeddings on supervised task with a simple modification. The \nmethod also makes it possible to examine and interpret the learned seman tics. \n \nThe aim of a method is to combine the benefits of unsupervised learning and supervised learning to learn \nbetter word embeddings. U nsupervised word embeddi ngs like skip-gram, trained on  large corpus (like \nWikipedia), gives good -quality word representations. We use such  embedding Wunsup as the starting \npoint and learn a delta embedding w\u0394 on top of it: \n \nThe unsupervised embedding  Wunsup is fixed to preserve good propertie s of the embedding space and  \nword semantics learned from large corpus. Delta embedding  w\u0394 is used to capture discriminative word \nsemantics from supervised NLP(Natural Language Processing) tasks and is trained together with  model \nfor the supervised task.", "mimetype": "text/plain", "start_char_idx": 457352, "end_char_idx": 461818, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c8fea01d-a524-4b90-8512-a76e2be893ee": {"__data__": {"id_": "c8fea01d-a524-4b90-8512-a76e2be893ee", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36eeb847-6299-4dda-a0d4-073813419d88", "node_type": "1", "metadata": {}, "hash": "628e28f4026f2d849047f8c774e73b0321c9c17e04bb4774a22cb0a3d6f0b866", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "89ca04f0-cb42-49a9-a293-245323c797de", "node_type": "1", "metadata": {}, "hash": "2a85477c24f14255e53d03c1a4054a8005d6e7077df326eaac4008e6cca9d7e1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In order to learn useful word semantics rather than task-specific peculiarities that \nresults from fitting (or overfitting) the  specific task, we impose  L21 loss, one kind of structured \nregularization on w\u0394:P a g e  7 | 16 \n \nThe regularization loss is added as extra term to loss of supervised task. \nThe effect of L21 loss on w\u0394 has straightforward interpretation: to minimize  total moving distance of \nword vectors in embedding space while reaching optimal task performance. The  L2part of  a \nregularization keeps  change of word vectors small, so that it does n ot lose its original semantics. \nThe L1 part of regularization induces sparsity on delta embeddings, that only small number of words get \nnon-zero delta embeddings, while majority of words are kept intact. The combined effect is selective \nfine-tuning with moderation: delta embedding capture only significant word semantics that is conta ined \nin the training data of a  task while absent in the unsupervised embedding. \nQ4. Do you have any idea about Rookie? \nAnswer: \nRookie: A unique approach for exploring news archives  \nNews archives offer the rich historical record. But if the reader or the journalist wants to learn about new \ntopic with a traditional search engine, they must enter query and begin reading or skimming old articles \none-by-one, slowly piecing together  intricate web of people, organizations, events, places, topics, \nconcepts and social forces that make up \u201cthe news.\u201d  \nWe propose Rookie, which began as attempt to build a useful tool for journalists. With Rookie, a user\u2019s \nquery generates an interactive timeline, a list of important related subjects, and summary of matching \narticles\u2014all displayed together as a collection of interactive linked views. Users click and drag along the \ntimeline to select certain date ranges, automatically regenerating the summary and subject list at \ninteractive speed. The cumulative effect: users can fluidly investigate complex news stories as they \nevolve across time. Quantitative user testing shows  how this system helps users better understand \ncomplex topics from documents and finish a historical sensemaking task 37% faster than with a \ntraditional interface. Qualitative studies with student journalists also validate the approach.  \nWe built the final version of Rookie following eighteen months of iterative design and development in \nconsultation with reporters and editors. Because the system aimed to help real -world journalists, the \nsoftware which emerged from the design process is dramatically different from similar academic efforts. \nSpecifically, Rookie was forced to cope with limitations in the speed, accuracy and interpretability of \ncurrent natural language processing techniques. We think that understanding and designing around such \nlimitations is vital to successfully using NLP in journalism applications; a topic which, to our knowledge, \nhas not been explored in prior work at the intersection of two fields.  \nHow it works? \nAt any given time, Rookie\u2019s state is defined with the user selection state, the triple (Q,F,T)  where:P a g e  8 | 16 \n \n\uf0b7 Q is the free text query string (e.g. \u201cBashar al-Assad\u201d) \n\uf0b7 F is related subject string (e.g. \u201c30 years\u201d) or is null \n\uf0b7 T is time-span (e.g. Mar. 2000\u2013Sep. 2000); by default, this is set to  span of publication dates in \nthe corpus. \nUsers first interact with Rookie by entering a query, Q into a search query bar using a web browser. For \nexample, in below figure, a user seeking to understand the roots of the Syrian civil war has entered  Q = \n\u201cBashar al -Assad\u201d. In response,  Rookie renders interactive time series visualization showing the \nfrequency of match ing documents from the corpus , a list of subje cts in the matching documents , \ncalled subjects-sum and a textual summary of those do cuments, called sentence-sum.1In this example, \nthe corpus is the collection of New York Times world news articles from 1987 to 2007 that contain the \nstring \u201cSyria\u201d. All of the country -specific examples in this study are subsets of the same  New York \nTimes LDC corpus. \nAfter entering Q, user might notice that \u201cBashar al-Assad\u201d is mainly mentioned from 1999 onwards. To \ninvestigate, they might adjust time series slider to a spike in early mentions of Bashar al-Assad, T =Mar. \n2000\u2013Sep. 2000. \nWhen user adjusts T to Mar. 2000\u2013Sep. 2000, sentence-sum and subjects-sum change to reflect the new \ntimespan below figure(c) . subjects-sum now shows subj ects like \u201cTRANSITION IN \nSYRIA\u201d,2Formatting from NYT section header style.", "mimetype": "text/plain", "start_char_idx": 461819, "end_char_idx": 466374, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "89ca04f0-cb42-49a9-a293-245323c797de": {"__data__": {"id_": "89ca04f0-cb42-49a9-a293-245323c797de", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c8fea01d-a524-4b90-8512-a76e2be893ee", "node_type": "1", "metadata": {}, "hash": "6a77dd888de86e98c7deda609213fab3dcb70391b99915f11ca485ed7c159a88", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b361279c-08c2-4c70-b3d4-8eab9098f2e2", "node_type": "1", "metadata": {}, "hash": "647534d0984fa0f2dc96eb532ac0625576a5c20f5ad6e85ebcfc3dd30725e356", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u201cPresident Assad\u201d, \u201celdest son\u201d and \u201c30 years\u201d \nwhich are important to Q during T. (Bashar al-Assad\u2019s father ruled for 30 years). \n \na) A user enters Q =\u201cBashar al-Assad\u201d in order to learn more about the Syrian civil war.P a g e  9 | 16 \n \nAt this point, user might explore further by investigating related subject, F =\u201cPresident Assad\u201d\u2014clicking \nto select. sentence-sum now attempts to summarize the relationship between  Q=\u201cBashar al -Assad\u201d \nand F =\u201cPresident Assad\u201d during  T =Mar. 2000\u2013Sep. 2000 figure(d). For instance,  sentence-sum now \nshows the sentence: \u201cBashar al -Assad was born on Sept. 11, 1965, in  Damascus, the third of President  \nAssad\u2019s five children.\u201d If a user wants to understand this sentence  in context, they can click sentence \u2014\nwhich opens underlying document in the modal dialog. \nF and Q are assigned re d and blue colors throughout interface, al lowing user  to quickly scan for \ninformation. Bolding  Q and F give additional clarity, and helps ensure that  Rookie still work  for \ncolorblind users. \nThis example demonstrates how Rookie\u2019s visualization and summarization techniques work together to \noffer linked views of the underlying corpus. Linked views (a.k.a.  multiple coordinated views) \ninterfaces are common tools for structured information: each view displays the same selected data in a \ndifferent dimension (e.g. a geographic map of a city which  also shows a histogram of housing costs \nwhen a user selects a neighborhood). In Rookie\u2019s case, linked views display different levels of \nresolution. The time series visualization offers a  temporal view of query-responsive \ndocuments, subjects-sum displays a medium-level lexical view of important subjects within the \ndocuments, and sentence-sum displays a low-level text view of parts of the underlying documents. The \ndocuments themselves, available by clicking extracted sentences, offer the most detailed level of zoom. \nThus Rookie supports the commonly advised visualization pathway: \u201coverview first, zoom and filter, \nand details on demand\u201d (Shneiderman1996). \nNote that we use  term summarization to mean selecting  short text, or sequence of short texts, to \nrepresent a body of text. By this definition, both  subjects-sum and sentence-sum are a form of \nsummarization, as each offers a textual representation of the corpus \u2014albeit at two different levels of \nresolution, phrases and sentences. \nQ5.SECRET: Semantically Enhanced  Classification of Real -world \nTasks \nAnswer: \nSignificant progress has been made in NLP(natural language processing ) and supervised machine \nlearning (ML) algorithms over the past 2 decades. NLP successes include machine translation, speech or \nemotion or sentiment recognition, machine re ading, and social media mining . Hence, NLP (Natural \nLanguage Processing) is beginning to become widely used in real -world applications that include either \ntext or speech . Supervised Machine Learning( ML) algorithms excel at m odeling the data -label \nrelationship while maximizing performance and minimizing energy consumption and latency.P a g e  10 | 16 \n \nSupervised ML algorithms train on feature -label pairs to model the application of interest and predict \nlabels. The label involves semantic i nformation. use this information through vector repr esentations of \nwords to find novel class within the dataset. Karpathy and Fei-Fei generate figure captions based on the \ncollective use of image datasets and word embeddings. Such stu dies indicate that data fe ature and \nsemantic relationship correlate well. However, current supervised (Machine Learning)ML algorithms do \nnot utilize such correlations in the decision-making (or prediction) process. Their decisions are based on \nthe feature -label relationship, while neglecting significant information hidden in  labels, i.e., meaning -\nbased (semantic) relationships among label. Thus, they are not able to exploit synergies between feature \nand semantic space. \nIn this article, we show above synergies can be exploited to improve prediction performance of Machine \nLearning(ML) algorithms. Our method, called SECRET, combines vector representations of label in  \nsemantic space with available data in  feature space within various operations (e.g., ML hyperpara meter \noptimization and confidence score computation) to make final decisions (assign labels to the datapoints). \nSince SECRET does not target any particular Machine Learning(ML) algorithm or data structure, it is \nwidely applicable. \nThe main contributions of this article are as follows: \n\uf0b7 We introduce the  dual-space Machine Learning( ML) decision proces s called SECRET.", "mimetype": "text/plain", "start_char_idx": 466376, "end_char_idx": 471009, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b361279c-08c2-4c70-b3d4-8eab9098f2e2": {"__data__": {"id_": "b361279c-08c2-4c70-b3d4-8eab9098f2e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "89ca04f0-cb42-49a9-a293-245323c797de", "node_type": "1", "metadata": {}, "hash": "2a85477c24f14255e53d03c1a4054a8005d6e7077df326eaac4008e6cca9d7e1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "15349f6a-4972-4fa3-9149-6337e2c01b66", "node_type": "1", "metadata": {}, "hash": "4c7a29bd0813e23a253b5e0c7e5fead1bb38f68816fffd95909fd7eabc6455ee", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It \ncombines new dimension (semantic space) with traditional (single-space) classifiers that operate \nin feature space. Thus, SECRET not only utilizes available data-label pairs, but also take  \nadvantage of meaning-based (semantic) relationships among labels  to perform classification for \nthe given real-world task. \n\uf0b7 We demonstrate the general applicability of S ECRET on various supervised Machine \nLearning(ML) algorithms and wide range of datasets for various real-world tasks. \n\uf0b7 We demonstrate  advantages of SECRET\u2019s new dimension (semantic space) through detailed \ncomparisons with traditional Machine Learning(ML) approaches that have same processing and \ninformation (except semantic) resources. \n\uf0b7 We compare the semantic space Machine Learning(ML) model with traditional approaches. We \nshed light on how SECRET builds  semantic space component and its impact on overall \nclassification performance. \nQ6. Semantic bottleneck for computer vision tasks  \nAnswer: \nImage-to-text tasks have made tremendous progress since the advent of deep learning (DL) approaches. \nThe work presented in this paper builds on these new types of image -to-text functions to evaluate  \ncapacity of textual representations to s emantically and fully encode  visual content of images forP a g e  11 | 16 \n \ndemanding applications, in order to allow prediction function to host semantic bottleneck somewhere in \nits processing pipeline. The mai n objective of  semantic bottleneck is to play role of  explanation of the \nprediction process since it offers  opportunity to examine meaningfully on what ground will further \npredictions be made, and potentially decide to reject them either using human common-sense knowledge \nand experience, or automatically through dedicated algorithms. Such the explainable semantic bottleneck \ninstantiates good tradeoff between prediction accuracy and interpretability.  \nReliably evaluating the quality of explanation is not straightforward. In this work, we propose to evaluate \nthe explainability power of the semantic bottleneck by measuring its capacity to detect the failure of the \nprediction function, either through an automated detector as , or through human judgment. Our proposal \nto generate  surrogate semantic representation is to associate the  global and generic textual im age \ndescription (caption) and visual quiz in the form of small list of questions and answers that are expected \nto refine contextually the generic caption. The production of this representation is adapted to vision task \nand learned from the annotated data. \n \nFigure : Semantic bottleneck approach: images are replaced by purely but rich textual representations, \nfor tasks such as multi-label classification or image retrieval. \n \nQ7. Gender Bias in Neural Natural Language Processing  \nAnswer: \nNatural language processing (NLP) with neural networks has grown in importance over  last few years. \nThey provide state -of-the-art(SOTA) models for tasks like coreference  resolution, language mo deling, \nand machine translation . However, since these models are tr ained on human language texts, natural \nquestion is whether they exhibit bias based on gender or other characteristics, and, if so, how should this \nbias be mitigated. This is a question that we address in this paper.P a g e  12 | 16 \n \nPrior work provides evidence of bias in autocomplete suggestions and differences in accuracy of speech \nrecognition based on gender and dialect  on popular online platforms. Word embeddings, initial pre -\nprocessors in many (Natural Language Processing)NLP tasks, embed words of a natural language into a \nvector space of limited dimension to use as  their semantic representation.  Observed that popular word \nembeddings including word exhibit gender bias  mirroring stereotypical gender ass ociations such as the \neponymous \"Man is to computer programmer as a Woman is to homemaker\u201d. \nYet the question of how to measure bias in general way for neural (Natural Language Processing)NLP \ntasks has not been studied. Our first contribution is general benchmark to quantify gender bias in variety \nof neural (Natural Language Processing)NLP tasks. Our definition of bias loosely follows idea of causal \ntesting: matched pairs of individuals that differ in only the targeted concept (like gender) are evaluated \nby the model and the difference in outcomes (or scores) is interpreted as causal influence of the concept \nin scrutinized model. The  definition is parametric in  scoring function and the target concept. Natural \nscoring functions exist for  number of neural natural language processing(NLP) tasks. \nWe instantiate  definition for two important tasks \u2014coreference resolution and language modelin g. \nCoreference resolution is a  task of finding words and expressions referring to the s ame e ntity in the  \nnatural language text. The goal of l anguage modeling is to model  distribution of word sequences.", "mimetype": "text/plain", "start_char_idx": 471010, "end_char_idx": 475946, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "15349f6a-4972-4fa3-9149-6337e2c01b66": {"__data__": {"id_": "15349f6a-4972-4fa3-9149-6337e2c01b66", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b361279c-08c2-4c70-b3d4-8eab9098f2e2", "node_type": "1", "metadata": {}, "hash": "647534d0984fa0f2dc96eb532ac0625576a5c20f5ad6e85ebcfc3dd30725e356", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "48c4dd2e-b382-4689-94cc-181761e99161", "node_type": "1", "metadata": {}, "hash": "c70652d9f75ba3cf024d604f933df87699db6f26a4b50ca53505f3779dca8768", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The goal of l anguage modeling is to model  distribution of word sequences. For \nneural coreference r esolution models, we measure  gender coreference score disparity between gender -\nneutral words and gendered words like the d isparity between \u201cdoctor\u201d and \u201che\u201d relative to \u201cdoctor\u201d and \n\u201cshe\u201d pictured as edge weights in below Fig. . For language models, we measure disparities of emission \nlog-likelihood of gender-neutral words conditioned on gendered sente nce prefixes as is shown i n below \nFig. Our empirical evaluation with state -of-the-art(SOTA) neural coreference resolution and tex tbook \nRNN-based language models trained on benchmark datasets finds gender bias in these models.Note that \nthese results have practical significance. Both coreference resolution and language modeling are core \nnatural language processing (NLP) tasks in that they form the basis of many practical systems for \ninformation extraction, text generation, speech recognition and machine translation. \nNext we turn our attention to mitigating the bias.  Bolukbasi et  al. ( 2016) introduced the technique \nfor debiasing word embeddings which has been shown to mitigate unwanted associations in an alogy \ntasks while preserving embedding\u2019s seman tic properties. Given their spread use, a natural question is \nwhether this technique is sufficient to eliminate bias from do wnstream tasks like coreference resolution \nand language modeling. As our 2nd contribution, we explore this question emp irically. We find that \nwhile technique does reduce bias,  residual bias is considerable. We further discover that debiasing \nmodels that make use of embeddings that are co-trained with their other parameters exhibit a significant \ndrop in accuracy.P a g e  13 | 16 \n \n \n \nQ8. DSReg: Using Distant Supervision as a Regularizer  \nAnswer: \nConsider the following sentences in a text classification task, in which we want to identify sentences \ncontaining revenue values:  \n\uf0b7 S1: The revenue of education sector is 1 million. (positive)  \n\uf0b7 S2: The revenue of education sector increased a lot. (hard -negative) \n\uf0b7 S3: Education is a fundamental driver of global development. (easy -negative) \nS1 is a positive example since it contains precise value for the revenue, while both S2 and S3 are negative \nbecause they do not have the concrete information of revenue value. However, since S2 is highly similar \nto S1, it is hard for a binary classifier to make a correct prediction on S2. As another example, in reading \ncomprehension tasks like NarrativeQA  (Ko\u010disk\u1ef3 et al., 2018) or MS-MARCO (Nguyen et  al., 2016), \ntruth answers are human -generated ones and might not have exact matches in the original corpus. A \ncommonly adopted strategy is to first locate similar sequences from the original corpus using a ROUGE-\nL threshold and then treat these sequences as a positive training examples. Sequences that are \nsemantically similar but right below this threshold will be treated as negative examples and thus \ninevitably introduce massive noise in training. \nThis problem is ubiquitous in a wide range of NLP tasks, i.e., when some of the negative examples are \nhighly similar to the positive examples. We refer to these negative examples  as hard-negative \nexamples for the rest of this paper. Also, we refer to those negative examples that are not similar to the \npositive examples as  easy-negative examples . If hard -negative examples significantly outnumber \npositive ones, features that they sh are in common will contribute significantly to the negative example \ncategory.P a g e  14 | 16 \n \nTo tackle this issue, we propose using the idea of distant supervision  to regulate the training. We first \nharvest hard-negative examples using distant supervisio n. This process c an be done by the  method as \nsimple as using word overlapping metrics (e.g., ROUGE, BLEU or whether a sentence contains a certain \nkeyword). With the harvested hard -negative examples, we transform the original binary classification \ntask to a multi -task learn ing task, in which we jointly optimize the original target objective of \ndistinguishing positive examples from negative examples along with an auxiliary objective of \ndistinguishing hard-negative examples plus positive examples from easy-negative examples. For a neural \nnetwork model, this goal can be easily achieved by using different softmax functions to readout the final-\nlayer representations. In this way, both the difference and the similarity between positive examples and \nhard-negative examples can be cap tured by the model.", "mimetype": "text/plain", "start_char_idx": 475871, "end_char_idx": 480434, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "48c4dd2e-b382-4689-94cc-181761e99161": {"__data__": {"id_": "48c4dd2e-b382-4689-94cc-181761e99161", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "15349f6a-4972-4fa3-9149-6337e2c01b66", "node_type": "1", "metadata": {}, "hash": "4c7a29bd0813e23a253b5e0c7e5fead1bb38f68816fffd95909fd7eabc6455ee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae298954-0179-4ebb-a91b-3c238cb39670", "node_type": "1", "metadata": {}, "hash": "09b3550bfb1219bb8eedfbc93945131dc2c91f52705a2d193a80b6a3a9201f55", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is worth noting that there are several key \ndifferences between this work and the mainstream works in distant supervision for relation extraction, at \nboth the setup level and the model level. In traditional work on distant supervision for relation extraction, \nthere is no training data initially and the distant supervision is used to get positive training data. In our \ncase, we do have a labeled dataset, from which we retrieve hard -negative examples using the distant \nsupervision.  \nQ9. What is Multimodal Emotion Classification? \nAnswer: \nEmotion is any  experience characterized by intense mental activity and  certain degree of pleasure or \ndispleasure. It primarily reflects all aspec ts of our daily lives, playing the  vital role in our decision -\nmaking and relationships. In recent years, there have been growing interest in a  development of \ntechnologies to recognize emotional states of individuals. Due to escalating use of social media, emotion-\nrich content is being generated at increasing rate, encouraging research on automatic emoji classification \ntechniques. Social media posts are mainly composed of ima ges and captions. Each of  modalities has \nvery distinct statistical properties and fusing these modalities helps us le arn useful representations of  \ndata. Emotion recognition is the  process that uses low -level signal cues to predict hig h-level emotion \nlabels. With  rapid increase in usage of emojis, researchers started using them as labels  to train \nclassification models.A survey conducted by secondary school students suggested that use of emoticons \ncan help reinf orce the meaning of the message . Researchers found that emoticons  when used in \nconjunction with written message, can help to increase the \u201cintensity\u201d of its intende d meaning.P a g e  15 | 16 \n \n \nEmojis are being used for  visual depictions o f human emotions . Em otions help us to determine \ninteractions among human beings. The context of emotions specifically brings out complex and bizarre \nsocial communication. These social comm unications are identified as  judgment of other person\u2019s mood \nbased on his emoji usage  (Rajhi, 2017). According to the  study made by Rajhi et al.  (Rajhi, 2017), the \nreal-time use of emojis can detect the human emotions in different scenes, lighting conditions as well as \nangles in real-time. Studies have shown that emojis when embedded with text to express emotion make \ntone and tenor of  message clearer. This further helps in reducing or eliminating the chances of \nmisunderstanding, often associated with plain text messages. A recent study proved that co -occurrence \nallows users to express their sentiment more effectively . \nPsychological studies conducted in the early \u201980s provide us strong evidence that human emotion is \nclosely related to the visual content. Images ca n both express and affect people\u2019s emotions. Hence it  is \nintriguing and important to understand how emotions are conveyed  and how they are implied by  visual \ncontent of images. With this as the reference, many computer scientists have been working to relate and \nlearn different visual features from images to c lassify emotional intent. Convolutional Neural Ne tworks \n(CNNs) have served as  baselines for major Image processing tasks. These deep Convolutional NeuralP a g e  16 | 16 \n \nNetworks(CNNs) combine the high and low -level features and classify images in an end -to-end multi \nlayer fashion. \nEarlier most researchers working in field of social Natural Language Processing(NLP) have used either \ntextual features or visual features, but there are hardly any instances where researchers have combined \nboth these features. Recent works by Barbieri et al.\u2019s, Illendula et al.\u2019s,  on multimodal emoji prediction \nand Apostolova et al. work on information extraction fusing visual and textual features have shown that \ncombining both modalities helps in improving the accuracies. While a hi gh percentage of social media \nposts are composed of both images and cap tion, researchers have not looked at  multimodal aspect for \nemotion classification. Consider  post in above Firgure where a user is sad and posts the  image when a \nperson close to him leaves him. The image represents the disturbed heart and has the  textual description \n\u201csometimes tough if your love leaves you #sad #hurting\u201d conveys a sad emotion. Similarly emoji used \nconveys emotion of being depressed. We hypothesiz e that all the modalities  from the social media post \nincluding visual, textual, and emoji features, contribute to predicting emotion of the user.", "mimetype": "text/plain", "start_char_idx": 480435, "end_char_idx": 485024, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ae298954-0179-4ebb-a91b-3c238cb39670": {"__data__": {"id_": "ae298954-0179-4ebb-a91b-3c238cb39670", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "48c4dd2e-b382-4689-94cc-181761e99161", "node_type": "1", "metadata": {}, "hash": "c70652d9f75ba3cf024d604f933df87699db6f26a4b50ca53505f3779dca8768", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e3a05eee-3e81-4991-87e8-27734709aa34", "node_type": "1", "metadata": {}, "hash": "7ec8044c26db560e91679ce96d7f5a85add6023c6a8a00b6fb483eb2a8645de4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Consequently, \nwe seek to learn importance of different modalities towards emotion prediction task.P a g e  1 | 18 \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n   (30 Days of Interview \nPreparation) \n \n                # Day27P a g e  2 | 18 \n \nQ1. Learning to Caption Images with Two-Stream Attention and  \nSentence Auto-Encoder \nAnswer: \nUnderstanding the world around us via visual representations , and communicating this extracted visual \ninformation via language is one of the fundamental skills of human intell igence. The goal of recreating \na similar level of intellectual ability in artificial intelligence(AI) has motivated researchers from \ncomputer vision and natural language communities to introduce the problem of automatic image \ncaptioning. Image captioning, which is to describe the content of an image in the natural language, has \nbeen an active area of research and widely applied to video and image understanding in multiple \ndomains. The ideal model for this challenging task must have two characteristics: understan ding of an \nimage content well and generating descriptive sentences which is coherent with the image content . \nMany image captioning methods propose various encoder-decoder models to satisfy these needs where \nencoder extracts the embedding from an image, and decoder generates the text based on the \nembedding. These two parts are typically built with a Convolutional Neural Network (CNN) and  a \nRecurrent Neural Network (RNN), respectively. \n \nFig.: This Image captioning decoder with two-stream attention and the Auxillary decoder \u201cfinds\u201d and \n\u201clocalizes\u201d relevant words better than general caption-attention baselines \nOne of the challenging question in encoder-decoder architectures is how to design interface that \ncontrols the information flow between a CNN and RNN. While early work employs static \nrepresentation for interface such that the CNN compresses an entire image into a fixed vector, and an \nRNN decodes representation into natural language sentences, this strategy is shown to perform poorly \nwhen target sentence is prolonged, and the image is reasonably cluttered. Inspired from, Xu et \nal. propose the powerful dynamic interface, namely attention mechanism, that identifies relevant parts \nof a image embedding to estimate the next word. RNN model then predicts the word based on the \ncontext vector associated with the related image regions and the previously generated words. The \nattentional interface is shown to obtain significant performance improvements over static one, andP a g e  3 | 18 \n \nsince then, it has become the key component in all state-of-the-art(SOTA) image captioning models. \nAlthough this interface is substantially effective and flexible, it comes with critical shortcoming. \nNevertheless, visual representations that are learned by Convolutional Neural Network(CNNs) have \nbeen rapidly improving the state-of-the-art(SOTA) recognition performance in various image \nrecognition tasks in past few years. They can still be inaccurate when applied to noisy images and \nperform poorly to describe their visual contents. Such noisy representations can lead to incorrect \nassociation between words and images regions and potentially drive the language model to poor textual \ndescriptions. To address these shortcomings, we propose two impr ovements that can be used in \nstandard encoder-decoder based image captioning framework. \nFirst, we propose the novel and powerful attention mechanism that can more accurately attend to \nrelevant image regions and better cope with ambiguities between words and image regions. It \nautomatically identifies latent categories that capture high-level semantic concepts based on visual and \ntextual cues, as illustrated in the second fig. The two-stream attention is modeled as a neural network \nwhere each stream specializes in orthogonal tasks: the first one soft-labels each image region with the \nlatent categories, and the second one finds the most relevant area for each group. Then their predictions \nare combined to obtain a context vector that is passed to a decoder.  \nSecond, inspired by sequence-to-sequence (seq2seq) machine translation methods, we introduce a new \nregularization technique that forces the image encoder coupled with the attention block to ge nerate a \nmore robust context vector for the following RNN model. In particular, we design and train an \nadditional seq2seq sentence auto-encoder model (\u201cSAE\u201d) that first reads in a whol e sentence as input, \ngenerates the fixed dimensional vector, then the vector is further used to reconstruct input sentence. \nSAE is trained to learn structure of the input (sentence) space in an offline manner, Once it is trained, \nwe freeze its parameters and incorporate only its decoder part (SAE-Dec) to our captioning model \n(\u201cIC\u201d) as the auxiliary decoder branch. SAE-Dec is employed along with the original image captioning \ndecoder (\u201cIC-Dec\u201d) to output target sentences during training and removed in test time.", "mimetype": "text/plain", "start_char_idx": 485025, "end_char_idx": 490026, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e3a05eee-3e81-4991-87e8-27734709aa34": {"__data__": {"id_": "e3a05eee-3e81-4991-87e8-27734709aa34", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae298954-0179-4ebb-a91b-3c238cb39670", "node_type": "1", "metadata": {}, "hash": "09b3550bfb1219bb8eedfbc93945131dc2c91f52705a2d193a80b6a3a9201f55", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c3732f34-173e-45d7-ba3d-f77a9c0d119a", "node_type": "1", "metadata": {}, "hash": "b5a080bbb4e32d98867df0bf4e266b8259287a88963252b737e206455278d8ab", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We show that \nthe proposed SAE-Dec regularizer improves the captioning performance for IC-Dec and does not bring \nany additional computation load in test time.P a g e  4 | 18 \n \n \n \nQ2.Explain PQ-NET. \nAnswer: \nPQ-NET: A Generative Part Seq2Seq Network for 3D Shapes.Learning generative models of 3D \nshapes is a crucial problem in both computer vision and computer graphics. While graphics are mainly \nconcerned with 3D shape modeling, in inverse graphics, a significant line of work in computer vision, \none aims to infer, often from a single image, a disentangled representat ion wrt 3D shape and scene \nstructures. Lately, there has been a steady stream of works on developing deep neural networks for 3D \nshape generation using different shape representations, e.g., voxel grids, point clouds, meshes , and, \nmost recently, implicit functions. However, most of these works produce  unstructured 3D shapes, even \nthough object perception is generally believed to be a process of  a structural understanding, i.e., to \ninfer shape parts, their compositions, and inter-part relations. \nIn this paper, we introduce a deep neural network that represents and generates 3D shapes \nvia sequential part assembly, as shown in both Fig. In a way, we regard assembly sequence as a \n\u201csentence,\u201d which organizes and describes the parts constituting the 3D shape. Our approach is \ninspired, in part, by the resemblance between speech and shape perception, as suggested b y the seminal \nwork of Biederman on recognition-by-components (RBC). Another related observation is that the \nphase structure rules for language parsing, first introduced by Noam Chomsky, take on the view that \nsentence is both a linear string of words and a hierarchical structure  with phrases nested in phrases. In \nthe context of shape structure presentations, our network adheres to linear  part orders, while other \nworks have opted for hierarchical part organizations.P a g e  5 | 18 \n \n \nFig 1: Our network, PQ-NET, learns 3D shape representation as a sequential part assembly. It can be \nadapted to generative tasks such as random 3D shape generation, single -view 3D reconstruction (from \nRGB or depth images), and shape completion. \n \nFig2: The architecture of PQ-NET: our part Seq2Seq generative network for 3D shapes.  \nThe input to our network is a 3D shape segmented into parts, where each part is first encoded into a \nfeature representation using a part autoencoder; see Fig2(a). The core component of our network is \na  Seq2Seq autoencoder, which encodes a sequence of part features into the latent vector of fixed size, \nand the decoder reconstructs the 3D shape, one part at the time, resulting in sequential assembly; see \nFig 2(b). With its part-wise Seq2Seq architecture, our network is coined  PQ-NET. The latent space \nformed by Seq2Seq encoder enables us to adapt the decoder to perform several generative tasks ,P a g e  6 | 18 \n \nincluding shape autoencoding, interpolation, new shape generation,  and single-view 3D reconstruction, \nwhere all generated shapes are composed of meaningful parts. \nAs training data, we take the segmented 3D shapes from PartNet, which was built on ShapeNet . It is \nimportant to note that we do not enforce any particular part order or consistency across input shapes. \nThe shape parts are always specified in the file following some linear order in the dataset; our network \ntakes whatever part order that is in a shapefile. We train the part and Seq2Seq autoencoders of PQ -NET \nseparately, either per shape category or across all shape categories, of PartNet.  \nOur part autoencoder adapts IM-NET to encode shape parts, rather than whole shapes, with the decoder \nproducing an implicit field. The part Seq2Seq autoencoder follo ws a similar architecture as the original \nSeq2Seq network developed for machine translation. Specifically, the encoder is a bidirectional stacked  \nrecurrent neural network (RNN) that inputs two sequences of part features, in opposite orders, and \noutputs a latent vector. The decoder is also a stacked RNN, which decodes the latent vector \nrepresenting the whole shape into a sequential part assembly.  \nPQ-NET is the first fully generative network that learns a 3D shape representation in the form of \nsequential part assembly.", "mimetype": "text/plain", "start_char_idx": 490027, "end_char_idx": 494308, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c3732f34-173e-45d7-ba3d-f77a9c0d119a": {"__data__": {"id_": "c3732f34-173e-45d7-ba3d-f77a9c0d119a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e3a05eee-3e81-4991-87e8-27734709aa34", "node_type": "1", "metadata": {}, "hash": "7ec8044c26db560e91679ce96d7f5a85add6023c6a8a00b6fb483eb2a8645de4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "95d6cb79-940f-47d8-ad80-f146833b0f62", "node_type": "1", "metadata": {}, "hash": "5e640a37ac66e57e87af5a1ceab4e22408ce15e19410260132ca7312b7a0ec0a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The only prior part sequence model was 3D-PRNN, which generates part \nboxes, not their geometry \u2014 our network jointly encodes and decodes part structure and geometry. PQ -\nNET can be easily adapted to various generative tasks , including shape autoencoding, novel shape \ngeneration, structured single-view 3D reconstruction from both RGB and depth images, and shape \ncompletion. Through extensive experiments, we demonstrate that performance and output quality of \nour network is comparable or superior to state-of-the-art generative models, including 3D-PRNN, IM-\nNET, and StructureNet. \n \nQ3. What is EDIT? \nAnswer: \nEDIT: Exemplar-Domain Aware Image-to-Image Translation \nA scene can be expressed in various manners using sketches, semantic maps, photographs, and \npainting,artworks, to name just a few. The way that one portrays the scene and expresses his/her vision \nis the so-called style, which can reflect the characteristic of either a class/domain or a specific case. \nImage-to-image translation (I2IT) refers to the process of converting an image I of a particular style to \nanother of the target style St with the content preserved. Formally, seeking the desired translator T can \nbe written in the following form:P a g e  7 | 18 \n \n \n \nFigure 1: Several results by the proposed EDIT. Our EDIT can take arbitrary exemplars as reference \nfor translating images across multiple domains, including photo-painting, shoe-edge, and semantic \nmap-facade in one model. \nWith the emergence of deep techniques, a variety of I2IT strategies have been proposed with excellent \nprogress made over the last decade. In what follows, we briefly review contemporary works along two \nmain technical lines, i.e., one-to-one translation and many-to-many translation. \nOne-to-one Translation. Methods in this category aim at mapping images from a source domain to a \ntarget domain. Benefiting from the generative adversarial networks (GANs), the style of translated \nresults satisfies the distribution of the target domain Y, achieved by S(It,St):=D(It,Y), where D(It, \nY) represents a discriminator to distinguish if It is real with respect to Y. An early attempt by Isola et \nal. uses conditional GANs to learn mappings between two domains. The paired data supervise the \ncontent preservation, i.e., C(It, I):=C(It, Igtt) with Igtt, the ground-truth target. However, in real-world \nsituations, acquiring such paired datasets, if not impossible, is impractical. To alleviate the pressure \nfrom data, inspired by the concept of cycle consistency, cycleGAN in an unsupervised fashion was \nproposed, which adopts C(It,I):=C(FY\u2192X(FX\u2192Y(I)),I) with FX\u2192Y the generator from \ndomain X to Y and FY\u2192X the reverse one. Afterward, StarGAN further extends the translation \nbetween two domains that cross multiple areas in a single model. Though the effectiveness of the \nmentioned methods has been witnessed by a broad spectrum of specific applications such as photo-P a g e  8 | 18 \n \ncaricature, making up-makeup removal, and face manipulation, their main drawback comes from the \nnature of deterministic (uncontrollable) one-to-one mapping. \nMany-to-many Translation. The goal of approaches in this class is to transfer the style controlled by an \nexemplar image to a source image with content maintained. Arguably, the m ost representative work \ngoes to, which uses the pre-trained VGG16 network to extract the content and style features, then \ntransfer style information by minimizing the distance between Gram matrices constructed from the \ngenerated image and the exemplar E, say S(It,St):=S(Gram(It),Gram(E)). Since then, numerous \napplications on the 3D scene, face swap, portrait stylization and font design have been done. \nFurthermore, several schemes have also been developed towards relieving limitations in terms of speed \nand flexibility. For example, to tackle the requirement of training for every new exemplar (style), \nShen et al. built a meta-network, which takes in the style image and produces a corresponding image \ntransformation network directly. Risser et al. proposed the histogram loss to improve the training \ninstability. Huang and Belongie designed a more suitable normalization manner,  i.e., AdaIN, for style \ntransfer. Li et al. replaced the Gram matrices with an alternative distribution alignment manner from \nthe perspective of domain adaption. Johnson et al. trained the network with a specific style image and \nmultiple content images while keeping the parameters at the inference stage.", "mimetype": "text/plain", "start_char_idx": 494309, "end_char_idx": 498816, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "95d6cb79-940f-47d8-ad80-f146833b0f62": {"__data__": {"id_": "95d6cb79-940f-47d8-ad80-f146833b0f62", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c3732f34-173e-45d7-ba3d-f77a9c0d119a", "node_type": "1", "metadata": {}, "hash": "b5a080bbb4e32d98867df0bf4e266b8259287a88963252b737e206455278d8ab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e863e6f1-8053-4d97-b2ef-08b8530f9c70", "node_type": "1", "metadata": {}, "hash": "453fe9ab1fd1800e52d14403cfd47848d61aa04a9d7218e028af3795d5c97064", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Chen  et al. introduced a \nstyle-bank layer containing several filter-banks, each of which represents a specific style. Gu et \nal. proposed a style loss to make parameterized, and non-parameterized methods complement each \nother. Huang et al.designed a new temporal loss to ensure the style consistency between frames of a \nvideo. Also, to mitigate the deterministic nature of on e-to-one translation, several works, for instance, \nadvocated to separately take care of content c(I) and style s(I) subject to I\u2243c(I)\u2218s(I) with \u2218 the \ncombined operation. They manage to control the translated results by combining the content of an \nimage with the style of the target, i.e., c(I)\u2218s(E). Besides, one domain pair requires one independent \nmodel, their performance, as observed from comparisons, is infer ior to our method in visual quality, \ndiversity, and style preservation. Please see the above Fig. , For example produced by our approach \nthat handles multiple domains and arbitrary exemplars in a unified model.  \n \nQ4. What is Doctor2Vec? \nAnswer: \nDoctor2Vec: Dynamic Doctor Representation Learning for   \nClinical Trial Recruitment \nThe rapid growth of electronic health record (EHR) data and other health data enables the training of \ncomplex deep learning models to learn patient representations for disease diagnosis, risk prediction,P a g e  9 | 18 \n \npatient subtyping, and medication recommendation. Ho wever, almost all current works focus on \nmodeling patients. Deep neural networks for doctor representation learning are lacking.  \nDoctors play pivotal roles in connecting patients and treatments, including recruiting patients into \nclinical trials for drug development and treating and caring for their patients. Thus an effective doctor \nrepresentation will better support a broader range of health analytic tasks. For example, identifying the \nright doctors to conduct the trial site selection to improve the chance of completion of the \ntrials [hurtado2017improving] and doctor recommendation for patients. \nIn this work, we focus on studying the clinical trial recruitment problem using doctor representation \nlearning. Current standard practice calculates the median enrollment rate. Enrollment rate of a doctor is \nthe number of patients enrolled by a doctor to the trial.  For the therapeutic area as the predicted \nenrollment success rate for whole participating doctors, which is often incorrect. Also, some develop a \nmulti-step manual matching process for site selection, which is labor-intensive. Recently, deep neural \nnetworks were applied on site selection tasks via static medical concept embedding using only frequent \nmedical codes and simple term matching to trials. Despite the success, two challenges remain open.  \n1. Existing works do not capture the time-evolving patterns of doctors experience and expertise \nencoded in EHR data of patients that the doctor have seen;  \n2. Current jobs learn a static doctor representation. Howe ver, in practice, given a trial for a \nparticular disease, the doctor\u2019s experience of relevant diseases are more important. Hence the \ndoctor representation should change based on the corresponding trial representation.  \nTo fill the gap, we propose Doctor2Vec, which simultaneously learns i) doctor representations from \nlongitudinal patient EHR data and ii) trial embedding from the multimodal trial description. In \nparticular, Doctor2Vec leverages a dynamic memory network where the observations of patients seen \nby the doctor are stored as memory while trial embedding serves as queries for retrieving from the \nmind. Doctor2Vec has the following contributions.  \n1. Patient embedding as a memory for dynamic doctors representation learning. We \nrepresent doctors\u2019 evolving experience based on the representations from the doctors\u2019 patients. \nThe patient representations are stored as a memory for dynamic doctor representation \nextraction. \n2. Trial embedding as a query for improved doctors selection. We learn hierarchical clinical \ntrial embedding where the unstructured trial descriptions were embedded using \nBERT [devlin2018bert]. The trial embedding serves as queries of the memory network and will \nattend over patient representation and dynamically assign weights based on the relevanc e of \ndoctor experience and trial representation to obtain the final context vector for an optimized \ndoctor representation for a specific test.P a g e  10 | 18 \n \nWe evaluated Doctor2Vec using large scale real -world EHR and trial data for predicting trial \nenrollment rates of doctors. Doctor2Vec demonstrated improved performance in the site selection task \nover the best baselines by up to 8.7% in PR-AUC. We also showed that the Doctor2Vec embedding \ncould be transferred to benefit data insufficiency settings, including trial recruitment in less \npopulated/newly explored countries or for rare diseases.", "mimetype": "text/plain", "start_char_idx": 498817, "end_char_idx": 503697, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e863e6f1-8053-4d97-b2ef-08b8530f9c70": {"__data__": {"id_": "e863e6f1-8053-4d97-b2ef-08b8530f9c70", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "95d6cb79-940f-47d8-ad80-f146833b0f62", "node_type": "1", "metadata": {}, "hash": "5e640a37ac66e57e87af5a1ceab4e22408ce15e19410260132ca7312b7a0ec0a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0bdff3d5-ae33-4b87-970c-d8f38deb019d", "node_type": "1", "metadata": {}, "hash": "6256a2cd2c0b1fb501f4b1d8069d9f2d3d8847510d123da384dcee6e18371b21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Experimental results show for the country \ntransfer, Doctor2Vec achieved 13.7% relative improvement in PR-AUC over the best baseline. While \nfor embedding transfer to unique disease trials, Doctor2Vec made 8.1%relative improvements in PR-\nAUC over the best benchmark. \n \nQ5. Explain PAG-Net. \nAnswer: \nPAG: Progressive Attention Guided Depth Super-resolution Network \nA geometric description of a scene, the high-quality depth map is useful in many computer vision \napplications, such as 3D reconstruction, virtual reality, scene understanding, intelligent driving, and \nrobot navigation. Literature mainly contains two classes of techniques for depth information \nacquisition, which are passive methods and active sensors. Firstly, passive methods infer depth maps \nfrom the most widely used dense stereo matching algorithms , but they are time-consuming. Despite the \nadvances in technology, the depth information from passive methods is still inaccurate in occluded and \nlow-texture regions. The acquisition of high-quality depth maps is more challenging to obtain than \nRGB images. \nDepth acquisition from active sensors has become increasingly popular in our daily life and ubiquitous \nto many consumer applications, due to their simplicity, portability, and inexpensive. Unlike passive \nmethods, the depth of a scene can be acquired in real-time, and they are more robust in low-textured \nregions by low-cost sensors such as Time-of-Flight camera and Microsoft Kinect. Current sensing \ntechniques measure depth information of a scene by using echoed light rays from the s tage. Time-of-\nFlight sensor (ToF) is one of the mainstream types which computes depth at each pixel between camera \nand subject, by measuring the round trip time. Although depth-sensing technology has attracted much \nattention, it still suffers from several quality degradations.  \nDepth information captured by ToF sensors suffer s from low-spatial resolutions \n(e.g., 176\u00d7144, 200\u00d7200 or 512\u00d7424) and noise when compared with the corresponding color images. \nDue to the offset between projector and sensor, depth maps captured by Microsoft Kinect sensors \ncontain structural missing along discontinuities and random missing at homogeneous regions. These \nissues restrict the use of depth maps in the development of depth -dependent applications. High-quality \ndepth is significant in many computer vision applications. Therefore, there is a need for restoration ofP a g e  11 | 18 \n \ndepth maps before using in applications. In this work, we consider the problem of depth map super -\nresolution from a given low-resolution depth map and its corresponding high-resolution color image. \n \nExisting depth super-resolution (DSR) methods can be roughly categorized into three groups: filter \ndesign-based, optimization-based, and learning-based algorithms. Many of the existing techniques \nassumed that a corresponding high-resolution color image helps to improve the quality of depth maps \nand used aligned RGB image as guidance for depth SR. However, significant artifacts including texture \ncopying and edge blurring, may occur when the assumption violated. The color texture will be \ntransferred to the super-resolved depth maps if the smooth surface contains rich textures in the \ncorresponding color image. Secondly, depth and color edges might not align in all the cases . \nSubsequently, it leads to ambiguity. Hence, there is a need for optimal guidance for the high-resolution \ndepth map. \nAlthough there have been many algorithms proposed in the literature for the depth super-resolution \n(DSR), most of them still suffer from edge-blurring and texture copying artifacts. In this paper, we \noffer a novel method for attention guided depth map super-resolution. It is based on dense residual \nnetworks and involves a unique attention mechanism. The attention used here to suppress the texture \ncopying problem arises due to improper guidance by RGB images and transfer only the salient features \nfrom the guidance stream. The attention module mainly involves providing spatial attention to the \nguidance image based on the depth features. The entire architecture for the example of super -resolution \nby the factor of 8 is shown in Above Fig. \n \nQ6. An End-to-End Audio Classification System based on Raw \nWaveforms and Mix-Training Strategy  \nAnswer:  \nSound is the indispensable medium for information transmission of surrounding environment. When \nsome sounds happen, such as baby crying, glass breaking , and so on, we usually expect that we can \n\u201chear\u201d sounds immediately, even if we are not around. In this case, an audio classification that aims toP a g e  12 | 18 \n \npredict whether an acoustic event appears has gained significant attention in recent years. It has many \npractical applications in remote surveillance, home automation, and public security.", "mimetype": "text/plain", "start_char_idx": 503698, "end_char_idx": 508547, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0bdff3d5-ae33-4b87-970c-d8f38deb019d": {"__data__": {"id_": "0bdff3d5-ae33-4b87-970c-d8f38deb019d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e863e6f1-8053-4d97-b2ef-08b8530f9c70", "node_type": "1", "metadata": {}, "hash": "453fe9ab1fd1800e52d14403cfd47848d61aa04a9d7218e028af3795d5c97064", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "524beb77-363e-48b0-8082-e82ebc147650", "node_type": "1", "metadata": {}, "hash": "35f674e19835636d9c66ee4e2535d03f2860b8d9732f53d2503c64f13100cceb", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It has many \npractical applications in remote surveillance, home automation, and public security.  \nIn real life, an audio clip usually contains multiple overlapping sounds, and types of sounds are various, \nranging from natural soundscapes to human activities. It is challenging to predict a presence or absence \nof audio events in an audio clip. Audio Set is the common large-scale dataset in this task, which \ncontains about two million multi-label audio clips covering 527 classes. Recently, some methods have \nbeen proposed to learn audio tags on this dataset. Among them, a multi-level attention model achieved \nstate-of-the-art(SOTA) performance, which outperforms Google\u2019s baseline. However, the shortcoming \nof these models is that the input signal is the published bottleneck feature, which causes inform ation \nloss. Considering that the actual length of sound events is different and the handcrafted features may \nthrow away relevant information at a short time scale, raw waveforms containing more valuable \ninformation is a better choice for multi-label classification. In the audio tagging task of DCASE 2017, \n2018 challenge, some works [5, 6] combined handcrafted features with raw waveforms as input signal \non a small dataset consisting of 17 or 41 classes. To our knowledge, none of the works proposes an \nend-to-end network taking raw waveforms as input in the Audio Set classification task. \nIn this paper, we propose a classification system based on two variants of ResNet , which directly \nextracts features from raw waveforms. Firstly, we use one-dimension (1D) ResNet for feature \nextraction. Then, two-dimension (2D) ResNet with multi-level prediction and attention structure is \nused for classification. For obtaining better classification performance further, a mix -training strategy \nis implemented in our system. In this training process, the network is trained with mixed data , which \nextends training distribution and then transferred to the target domain using raw data. \nIn this work, the main contributions are as follows: \n1. The novel end-to-end Audio Set classification system is proposed. To best of our knowledge, it \nis first time to take raw waveforms as input on Audio Set and combine 1D ResNet with 2D \nResNet for feature extraction at different time scales.  \n2. A mix-training strategy is introduced to improve the utilization of limited training data \neffectively. Experiments show that it is robust in multi-label audio classification compared to \nthe existing data augmentation methods.P a g e  13 | 18 \n \n \nFigure 1: Architecture of the end-to-end audio classification network. The raw waveform (1D  vector) is \nthe input signal. First, the 1D ResNet is applied to extract audio features. Then, the elements are \ntransposed from C\u00d71\u00d7Tto 1\u00d7C\u00d7T. Finally, a 2D ResNet with a multi-level prediction structure \nperforms audio classification. The output of network has multiple labels and is the mean of multi-level \nprediction results. The Block is composed of n bottleneck blocks, where n is related to a number of \nlayers in ResNet. \n \nQ7. What is Cnak? : Cluster Number Assisted K-means \nAnswer: \nCnak stands for  Cluster Number Assisted K-means \nIn cluster analysis, it is required to group the set of data points in a multi-dimensional space so that data \npoints in same group are more similar to each other than to those in other groups. These groups are \ncalled clusters. Various distance functions may be used to compute degree of dissimilarity or similarity \namong these data points. Typically Euclidean distance function is widely used in clustering. Th is \nunsupervised technique aims to increase homogeneity in the group and heterogeneity between groups. \nSeveral clustering methods with different characteristics have been proposed for different purposes. \nSome well-known methods include partition-based clustering, hierarchical clustering [Hierarchy1963], \nspectral clustering [onspectral2001], density-based clustering [DBSCAN]. However, they require the \nknowledge of cluster number for a given dataset a \npriori [Lloyd57; onspectral2001; DBSCAN; DBCLASD; DENCLUE].P a g e  14 | 18 \n \nNevertheless, estimation of the number of clusters is difficult problem as the underlying data \ndistribution is unknown. Readers can find several existing techniques for determining cluster number \nin [survey_cluster_number2017; R3_Chiang2010].", "mimetype": "text/plain", "start_char_idx": 508450, "end_char_idx": 512844, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "524beb77-363e-48b0-8082-e82ebc147650": {"__data__": {"id_": "524beb77-363e-48b0-8082-e82ebc147650", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0bdff3d5-ae33-4b87-970c-d8f38deb019d", "node_type": "1", "metadata": {}, "hash": "6256a2cd2c0b1fb501f4b1d8069d9f2d3d8847510d123da384dcee6e18371b21", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6291a13f-0cec-44d4-b2f0-6f06bf996e79", "node_type": "1", "metadata": {}, "hash": "3bdc192a3374810a8361c48988146ca67afe9059b3d3e78d697998ce9756efb1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We have followed the terminology used \nin R3_Chiang2010 for categorizing different methods for the prediction of cluster number s. In this \nwork, we choose to focus only on three approaches: 1) variance-based approach, 2) Structural \napproach, and 3) the Resampling approach. Variance-based plans are based on measuring compactness \nwithin a cluster. Structural approaches include between -cluster separation as well as within-cluster \nvariance. We have chosen these approaches as they are either more suitable for handling big data, or \nappear in a comparative study by several researc hers. Some well-known approaches are Calinski-\nHarabaz [CH], Silhouette Coefficient [sil], Davies-Bouldin [DB], Jump [jump], Gap statistic [gap], etc. \nThese approaches are not appropriate for handling big data, as they are computationally intensive and \nrequire ample storage space. It requires a scalable solution [kluster2018; ISI_LL_LML2018] for \nidentifying the number of clusters. Resampling-based approaches can be considered in such scenario. \nRecently, the concept of stability in clustering has become popular. A few \nmethods [instability2012; CV_A] utilize the idea of clustering robustness against the randomness in the \nchoice of sampled datasets to explore clustering stability. \n \nQ8. What is D3S? \nAnswer: \nD3S \u2013 A Discriminative Single Shot Segmentation Tracker .Visual object tracking is one of the core \ncomputer vision problems. The most common formulation considers the task of reporting the target \nlocation in each frame of the video given a single training image. Currently, the dominant tracking \nparadigm, performing best in evaluations [kristan_vot2017, kristan_vot2018], is correlation bounding \nbox tracking where the target represented by a multi-channel rectangular template is localized by cross -\ncorrelation between the template and a search region.P a g e  15 | 18 \n \n \nFigure 1: The D3S tracker represents the target by two models with complementary geometri c \nproperties, one invariant to a wide range of transformations, including non-rigid deformations (GIM - \ngeometrically invariant model), the other assuming a rigid object with motion well approximated by a \neuclidean change (GEM - geometrically constrained Euclidean model). The D3S, exploiting the \ncomplementary strengths of GIM and GEM, provides both state -of-the-art localization and accurate \nsegmentation, even in the presence of substantial deformation.  \nState-of-the-art template-based trackers apply an efficient brute-force search for target localization. \nSuch a strategy is appropriate for low-dimensional transformations like translation and scale change but \nbecomes inefficient for more general situations, e.g. such that induce an aspect ratio change and \nrotation. As a compromise, modern trackers combine approxi mate exhaustive search with sampling and \nbounding box refinement/regression networks for aspect ratio estimation. However, these approaches \nare restricted to axis-aligned rectangles. \nEstimation of high-dimensional template-based transformation is unreliable when a bounding box is a \nsparse approximation of the target. This is common \u2013 consider, e.g. elongated, rotating, deformableP a g e  16 | 18 \n \nobjects, or a person with spread out hands. In these cases, the most accurate and well -defined target \nlocation model is a binary per-pixel segmentation mask. If such output is required, tracking becomes \nthe video object segmentation task recently popularized by DAVIS  and YoutubeVOS challenges. \nUnlike in tracking, video object segmentation challenges typically consider large target observed for \nless than 100 frames with low background distractor presence. Top video object segmentation \napproaches thus fare poorly in short-term tracking scenarios where the target covers a fraction of the \nimage, substantially changes its appearance over a more extended period, and moves over a cluttered \nbackground. Best trackers apply visual model adaptation, but in the case of segmentation errors , it \nleads to irrecoverable tracking failure. Because of this, in the past, segmentation has played only an \nauxiliary role in template-based trackers, constrained DCF learning and tracking by 3D model \nconstruction.  \nRecently, the SiamRPN tracker has been extended to produce high-quality segmentation masks in two \nstages \u2013 SiamRPN branches first localize the target bounding box, and then segmentation mask is \ncomputed only within this region by another branch. The two -stage processing misses the opportunity \nto treat localization and segmentation jointly to increase robustness. Another drawback is that a fixed \ntemplate is used that cannot be discriminatively adapted to the changing scene.  \nWe propose a new single-shot discriminative segmentation tracker, D3S, that addresses the limitations \nas mentioned above.", "mimetype": "text/plain", "start_char_idx": 512845, "end_char_idx": 517691, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6291a13f-0cec-44d4-b2f0-6f06bf996e79": {"__data__": {"id_": "6291a13f-0cec-44d4-b2f0-6f06bf996e79", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "524beb77-363e-48b0-8082-e82ebc147650", "node_type": "1", "metadata": {}, "hash": "35f674e19835636d9c66ee4e2535d03f2860b8d9732f53d2503c64f13100cceb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d8055aea-7f54-4708-b218-b8e23a78c4c6", "node_type": "1", "metadata": {}, "hash": "9bb87e7b3a58c39e4b18284edbca7c890311eff2bcef7ffbf60afc0225b76b33", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Two discriminative visual models encode the target \u2013 one is adaptive and highly \ndiscriminative but geometrically constrained to a euclidean motion (GEM), while the other is invariant \nto a broad range of transformation (GIM, geometrica lly invariant model), see above Fig. \nGIM sacrifices spatial relations to allow target localization under significant deformation. On the other \nhand, GEM predicts the only position but discriminatively adapts to the target and acts as a selector \nbetween possibly multiple target segmentations inferred by GIM. In contrast to related \ntrackers [siammask_cvpr19, siamrpn_cvpr2019, atom_cvpr19], the primary output of D3S is the \nsegmentation map computed in a single pass through the network, which is trained end -to-end for \nsegmentation only. \nSome applications and most tracking benchmarks require reporting the target location as a bounding \nbox. As a secondary contribution, we propose an effective method for interpreting the segmentation \nmask as a rotated rectangle. This avoids an error -prone greedy search and naturally addresses changes \nin location, scale, aspect ratio, and rotation. \nD3S outperforms all state-of-the-art trackers on most of the significant tracking \nbenchmarks [kristan_vot2016, kristan_vot2018, got10k, muller_trackingnet] despite not being trained \nfor bounding box tracking. In video object segmentation benchmarks [davis16, davis17], D3SP a g e  17 | 18 \n \noutperforms the leading segmentation tracker  [siammask_cvpr19] and performs on par with top video \nobject segmentation algorithms (often tuned to a specific domain), yet running orders of magnitude \nfaster. Note that the D3S is not re-trained for different benchmarks \u2013 a single pre-trained version shows \nremarkable generalization ability, and versatility.PyTorch implementation will be made available.  \n \nQ9. What is DRNet? \nAnswer: \nDRNet stands for Dissect and Reconstruct the Convolutional Neural Network via Interpretable \nManners Convolutional neural networks (CNNs) have been broadly applied on various visual tasks due \nto its superior performance ([vgg], [resnet], [densenet]). But the huge computation burden prevents \nconvolutional neural networks from running on mobile devices. Some works had been done to prune \nneural networks into smaller ones ([slimming], [pruning1], [pruning2]). Also, there are too many \nlightweight network structures ([mobilenet], [mobilenetv2], [shufflenet]) were proposed to adapt \nconvolutional neural networks to computational limited mobile devices. However, these methods \nusually require running a whole pre-trained network, whatever the task is. i.e., the first task requires the \ndiscrimination power of cats and dogs, and the second task requires the discrimination power of apples \nand watermelons. If one has a CNN which was pre-trained on ImageNet, he must run the whole CNN \non each task, which is usually time-consuming and computation wasted. \nOur work focuses on an underlying problem, i.e., can we run only parts of a CNN? To achieve this \ngoal, we need to find a method to dissect the whole network into pieces and reconstruct some of these \npieces according to specific tasks. The reconstructed CNN should have a smaller computation cost and \nbetter performance. Meanwhile, the process of generating this substructure should be quick and easy. \nTherefore this technology can be applied on mobile devices and small robots such  as cell-phones and \nuncrewed aerial vehicles. Using these technologies, these devices only need to store one complete \nCNN and some information about the substructure generating program. When specific tasks come, \nthese devices can create a smaller substructure in an instant and run on it, rather than run the whole \noriginal CNN.P a g e  18 | 18 \n \n \nIn this paper, we proposed a novel and interpretable algorithm to generate these smaller substructures. \nAn interpretable way of CNN inspires our method. As shown in Figure 1: the original CNN has many \nchannels, but not every channel is useful for the discrimination of every class. What we need to do is to \nfind the channels relevant to every type and combine them for the specific task. This method looks \nsimilar to the previous work: structured network pruning ([slimming], [pruning3], [pruning4]). \nHowever, all of these pruning methods need fine-tuning, which is time-consuming and not allowed on \nmobile devices. And these pruning methods are usually lack of interpre tability which is much needed \nby human-beings when using CNNs.", "mimetype": "text/plain", "start_char_idx": 517692, "end_char_idx": 522204, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d8055aea-7f54-4708-b218-b8e23a78c4c6": {"__data__": {"id_": "d8055aea-7f54-4708-b218-b8e23a78c4c6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6291a13f-0cec-44d4-b2f0-6f06bf996e79", "node_type": "1", "metadata": {}, "hash": "3bdc192a3374810a8361c48988146ca67afe9059b3d3e78d697998ce9756efb1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b18a7acd-ee88-4480-b9f1-4d446213ac6f", "node_type": "1", "metadata": {}, "hash": "bd91ca4b11c891cea71aea1811127df2bc88bea4a5e076931bfd81501d3ded05", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Therefore, we do not mean to propose a pruning method and \nmake CNN smaller, but to find the best channels for each class, and combine them for specific tasks. \nOur approach not only can be used on VGG and ResNet but also on some light structures such as \nMobileNetV2. Also, we make this process quick and interpretable.P a g e  1 | 9 \n \n \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview \nPreparation) \n \n# DAY 09P a g e  2 | 9 \n \nQ1: How would you define Machine Learning? \nAns: \nMachine learning: It is an application of artificial intelligence (AI) that provides systems the ability \nto learn automatically and to improve from experiences without being programmed. It focuses on the \ndevelopment of computer applications that can access the data and used it to learn for themselves. \nThe process of learning starts with the observations or data, such as examples, direct experience, or \ninstruction, to look for the patterns in data and  to make bette r decisions in the future based on \nexamples that we provide. The primary aim is to allow the computers to learn automatically without \nhuman intervention or assistance and adjust actions accordingly. \n \nQ2. What is a labeled training set? \nAns: \nMachine learning  is derived from  the availability of the labeled data in the form of a  training \nset and test set that is used by the learning algorithm. The separation of data into the training portion \nand a test portion is t he way the algorithm learns.  We split up the data containing known response \nvariable values into two pieces. The training set is used to train the algorithm, and then you use the \ntrained model on the test set to predict the variable response values that are already known. The final \nstep is to compare with the predicted responses against actual (observed) responses to see how close \nthey are. The difference is the test error metric. Depending on the test error, you can go back to refine \nthe model and repeat the process until you\u2019re satisfi ed with the accuracy.P a g e  3 | 9 \n \nQ3. What are the two common supervised tasks? \nAns: \nThe two common supervised tasks are regression and classification. \nRegression- \nThe regression problem is when the output variable is the real or continuous value, such as \u201csalary\u201d \nor \u201cweight.\u201d Many different models can be used, and the simplest is linear regression. It tries to fit \nthe data with the best hyper-plane, which goes through the points. \n \nClassification \nIt is the type of supervised learning. It specifies the class to which the data elements belong to and \nis best used when the output has finite and discrete values. It predicts a class for an input variable, \nas well. \n \n \nQ4. Can you name four common unsupervised tasks? \nAns: \nThe common unsupervised tasks include clustering, visualization, dimensionality reduction, and \nassociation rule learning. \nClusteringP a g e  4 | 9 \n \nIt is a Machine Learning technique that involves the grouping of the data points. Given a set of data \npoints, and we can use a clustering algorithm to classify each data point into the specific group. In \ntheory, data points that lie in the same group should have similar properties and/ or features, and \ndata points in the different groups should have high dissimilar properties and/or features. Clustering \nis the method of unsupervised learning and is a common technique for statistical data analysis used \nin many fields. \n \nVisualization \nData visualization is the technique that uses an array of static and interactive visuals within the \nspecific context to help people to understand and make sense of the large amounts of data. The data \nis often displayed in the story format that visualizes patterns, trends, and correlations that may go \notherwise unnoticed. It is regularly used as an avenue to monetize data as the product. An example \nof using monetization and data visualization is Uber. The app combines visualization with real-time \ndata so that customers can request a ride.  \n \nQ5. What type of Machine Learning algorithm we use to  \n       allow a robot to walk in various unknown terrains? \nAns: \nReinforcement Learning is likely to perform the best if we want a robot to learn  how to walk in the \nvarious unknown terrains since this is typically the type of problem that the reinforcement learningP a g e  5 | 9 \n \ntackles. It may be possible to express the problem as a supervised or semisupervised learning \nproblem, but it would be less natural. \nReinforcement Learning- \nIt\u2019s about to take suitable actions to maximize rewards in a particular situation.", "mimetype": "text/plain", "start_char_idx": 522205, "end_char_idx": 526782, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b18a7acd-ee88-4480-b9f1-4d446213ac6f": {"__data__": {"id_": "b18a7acd-ee88-4480-b9f1-4d446213ac6f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d8055aea-7f54-4708-b218-b8e23a78c4c6", "node_type": "1", "metadata": {}, "hash": "9bb87e7b3a58c39e4b18284edbca7c890311eff2bcef7ffbf60afc0225b76b33", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "66a3def4-f002-4286-91d6-dffc853ff270", "node_type": "1", "metadata": {}, "hash": "dd0d9daa41046d746215bcef2266a1fd850e627decb54b5eebc5960fdb06d7bf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is employed by the \nvarious software and machines to find out the best possible behavior/path it should take in specific \nsituations. Reinforcement learning is different  from the supervised learning in a  way that in \nsupervised learning, training data has answer key with it so that the model is trained with the correct \nanswer itself, but in reinforcement learning, there is no answer, and the reinforcement agent decides \nwhat to do to perform the given task. In the absence of the training dataset, it is bound to learn from \nits experience. \n \nQ6. What type of algorithm would we use to segment your  \n       customers into multiple groups? \nAns: \nIf we don\u2019t know how to define the groups, then we can use the clustering algorithm (unsupervised \nlearning) to segment our customers into clusters of similar customers. However, if we know what \ngroups we would like to have, then we can feed many examples of each group to a classification \nalgorithm (supervised learning), and it will classify all your customers into these groups. \nQ7: What is an online machine learning? \nAns: \nOnline machine learning: It is a method of machine learning in which data becomes available in \nsequential order and to update our best predictor for the future data at each step, as opposed to \nbatch learning techniques that generate the best predictor by learning on entire training data set at \nonce. Online learning is a common technique and used in the areas of machine learning where it is \ncomputationally infeasible to train over the datasets, requiring the need for Out- of- \nCore algorithms. It is also used in situations where the algorithm must adapt to new patterns in the \ndata dynamically or when the data itself is generated as the function of time, for example, stockP a g e  6 | 9 \n \nprice prediction. Online learning algorithms might be prone to catastrophic interference and \nproblem that can be addressed by the incremental learning approaches. \n \n \nQ8: What is out-of-core learning? \nAns: \nOut-of-core: It refers to the processing data that is too large to fit into the computer\u2019s main \nmemory. Typically, when the dataset fits neatly into the computer\u2019s main memory, randomly \naccessing sections of data has a (relatively) small performance penalty. \nWhen data must be stored in a medium like a large spinning hard drive or an external computer \nnetwork, it becomes very expensive to seek an arbitrary section of data randomly or to process the \nsame data multiple times. In such a case, an out-of-core algorithm will try to access all the relevant \ndata in a sequence. \nHowever, modern computers have deep memory hierarchy, and replacing random access with the \nsequential access can increase the performance even on datasets that fit within memory.P a g e  7 | 9 \n \n \nQ9. What is the Model Parameter? \nAns: \nModel parameter: It is a configuration variable that is internal to a model and whose value can be \npredicted from the data. \n\uf0b7 While making predictions, the model parameter is needed. \n\uf0b7 The values define the skill of a model on problems. \n\uf0b7 It is estimated or learned from data. \n\uf0b7 It is often not set manually by the practitioner. \n\uf0b7 It is often saved as part of the learned model.P a g e  8 | 9 \n \nParameters are key to machine learning algorithms. They are part of the model that is learned from \nhistorical training data. \nQ11: What is Model Hyperparameter? \nAns: \nModel hyperparameter: It is a configuration that is external to a model and whose values cannot \nbe estimated from the data. \n\uf0b7 It is often used in processes to help estimate model parameters. \n\uf0b7 The practitioner often specifies them. \n\uf0b7 It can often be the set using heuristics. \n\uf0b7 It is tuned for the given predictive modeling problems. \nWe cannot know the best value for the model hyperparameter on the given problem. We may use \nthe rules of thumb, copy values used on other problems, or search for the best value by trial and \nerror. \n \nQ12. What is cross-validation? \nAns: \nCross-validation: It is a technique for evaluating Machine Learning models by training several \nMachine Learning models on subsets of available input data and evaluating them on the \ncomplementary subset of data. Use cross-validation to detect overfitting, i.e., failing to generalize a \npattern. \nThere are  three steps involved in cross-validation are as follows : \n\uf0b7 Reserve some portion of the sample dataset.P a g e  9 | 9 \n \n\uf0b7 Using the rest dataset and train models. \n\uf0b7 Test the model using a reserve portion of the data-set.", "mimetype": "text/plain", "start_char_idx": 526783, "end_char_idx": 531289, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "66a3def4-f002-4286-91d6-dffc853ff270": {"__data__": {"id_": "66a3def4-f002-4286-91d6-dffc853ff270", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b18a7acd-ee88-4480-b9f1-4d446213ac6f", "node_type": "1", "metadata": {}, "hash": "bd91ca4b11c891cea71aea1811127df2bc88bea4a5e076931bfd81501d3ded05", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0561237a-aa07-4c97-9d98-c8ba80791ef3", "node_type": "1", "metadata": {}, "hash": "e3fb93d3b0a3ce0b1884082eb3aba846a7375102a48c45def5ef7b459dc9ddb7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Test the model using a reserve portion of the data-set. \n \n \n \n--------------------------------------------------------------------------------------------------------------P a g e  1 | 17 \n \n \nDATA SCIENCE \nINTERVIEW \nPREPARATION \n(30 Days of Interview Preparation) \n                              \n \n \n#FinaleDay30 \nMost important questions \nRelated to ProjectP a g e  2 | 17 \n \nDisclaimer: The answers given here are not generic ones. These answers are given based \non the attendance system that we have developed to do face detection. The answers will vary \nbased on the projects done, methodologies used and based on the person being interviewed.  \n \nFace Recognition and Identification system Project \n \nQ1. Tell me about your current project. \nAnswer: \nThe project is called Attendance System using facial recognition.   \nThe goal of the pr oject is to identify the person and mark their attendance . First, the user has to \nregister himself/herself in the application providing the required details. The application takes \nmultiple snaps of the user and then stores it into the database. Once the same user comes before the \ncamera again, the application captures the image, references it against the already stored images in \nthe database, and then marks the attendance, if the user is prese nt in the database.  Reports can be \ngenerated for a particular duration based on the user requirement.  \nSome snaps from the project are as follows: \n1st-time registration:P a g e  3 | 17 \n \nMarking the Attendance: \nWith un-registered user: \n \n \nWith a registered user:P a g e  4 | 17 \n \n \nSeeing the reports: \n \n \n \n \n Features: \n\uf0b7 Works with generic IP cameras with good quality.  \n\uf0b7 Works even with PC, you don\u2019t need high-end systems. \n\uf0b7 Works in both indoor as well as outdoor environments.  \n\uf0b7 Works with limited pose changes. \n\uf0b7 Works with spectacles. \n\uf0b7 Works for people of different ethnicity. \n\uf0b7 Works for tens of thousands of registered faces.  \n\uf0b7 Works with limited lighting conditions. \n\uf0b7 Works with partial facial landmarks. \n\uf0b7 Non-recognition of static input images when provided by the user.P a g e  5 | 17 \n \nFunctionalities in the Attendance System \n\uf0b7 Registration of users in the system. \n\uf0b7 Capturing the user details during registration using Passport, Adhar Card, and Pan \nCard. \n\uf0b7 All details will be extracted using the in-house OCR technique. \n\uf0b7 Tracking of the login and logout timings of the users from the system. \n\uf0b7 Generation of user logs on a temporal basis.  \n\uf0b7 Generation of timely reports. \nDeployment/Installation \n\uf0b7 The application can be easily installed as a web-based API on any cloud platform. This \ninstallation is similar to a plug and play scenario.  \n\uf0b7 The application can also be installed in an edge device (like the Google Coral). This \ninstallation provides realtime streaming capabilities to the application.  \nQ2. What was the size of the data? \nAnswer: \nThe number of images used for training was 12,313. \nQ3. What was the data type? \nAnswer: \nThe data used for training this model consisted of thousands of images; the images then are converted \nto tensor objects, which have a float 32 representation. \nQ4. What was the team size and distribution?  \nAnswer:  \nThe team consisted of: \n\uf0b7 1 Product Manager, \n\uf0b7 1 Solution Architect, \n\uf0b7 1 Lead, \n\uf0b7 2 Dev-Ops engineers, \n\uf0b7 2 QA engineers,  \n\uf0b7 2 UI developers, and  \n\uf0b7 3 Data Scientists.P a g e  6 | 17 \n \n \nQ5.What Hadoop distribution were you using?  \nAnswer: \nThe Hadoop distribution from Cloudera was used as it provides many of the much-needed capabilities \nout of the box like multi -function analytics, shared data experience with optimum security and \ngovernance, hybrid capabilities for support to clouds, on -premise servers as well as multi-clouds. \nQ6.What is the version of distribution?  \nAnswer: \nCDH \u2013 5.8.0 \nQ7.What was the size of the cluster?  \nAnswer: \nThe cluster(production setup) consisted of 15 servers with \n\uf0b7 Intel i7 processors \n\uf0b7 56 GB of RAM \n\uf0b7 500 GB of Secondary storage each   \n\uf0b7 Mounted NAS locations \nQ8. How many nodes were there in all the Dev, UAT, and Prod \nenvironments? \nAnswer: \nThe necessary coding was done on one development server.", "mimetype": "text/plain", "start_char_idx": 531232, "end_char_idx": 535407, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0561237a-aa07-4c97-9d98-c8ba80791ef3": {"__data__": {"id_": "0561237a-aa07-4c97-9d98-c8ba80791ef3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "66a3def4-f002-4286-91d6-dffc853ff270", "node_type": "1", "metadata": {}, "hash": "dd0d9daa41046d746215bcef2266a1fd850e627decb54b5eebc5960fdb06d7bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cf2a6039-d9a3-4d8c-809b-cbb70b975561", "node_type": "1", "metadata": {}, "hash": "4fccc8ca1ad6f5ced40a2c31689cd59f6b42a85d53190635d42440416a5139f5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Answer: \nThe necessary coding was done on one development server. But as a standalone machine won\u2019t give \nenough speed to train the model in a short time, once we saw that the model\u2019s loss is decreasing for \na few numbers of epochs in the standalone machine, the same code was deployed to a cloud -based \nGPU machine for training . Once the model was trained there, we used the saved model file for \nprediction/classification. The same model file was deployed to the cloud UAT and Production \nenvironments.  \nIn total, we had:  \n\uf0b7 5 nodes in the dev environment,  \n\uf0b7 5 nodes in UAT, and  \n\uf0b7 15  nodes in production.P a g e  7 | 17 \n \nQ9.How were you creating and maintaining the logs? \nAnswer: \nThe logs are maintained using MongoDB. The logging starts with the start of the application. The \nstart time of the application gets  logged. After that, there are loggings for entry and exits to the \nindividual methods. There are loggings for the error scenarios and exception block as well.P a g e  8 | 17 \n \nQ10.What techniques were you using for data pre-processing for \nvarious data science use cases and visualization? \nAnswer: \nThere are multiple steps that we do for data preprocessing, like data cleaning, data integration, data \nscaling, etc. Some of them are listed as follows: \n\uf0e8 For Machine Learning: \n While preparing data for a model, data should be verified using multiple tables or files \nto ensure data integrity.  \n Identifying and removing unnecessary attributes.  \nFor example,  \n \nHere, the user_ID column does not contribute to the customer behavior for \npurchasing the products. So, it can be dropped fro m the dataset. \n \n Identifying, filling or droping the rows/columns containing missing values based on the \nrequirement.P a g e  9 | 17 \n \n \nHere, the Product_Category_3 has about 5.5 lac missing values. It can be \ndropped using the command\uf0e0 df.drop(\u2018Product_Category_3\u2019,axis=1, \ninplace=True) \nOr, if the count of null values have been lower, they could have been imputed \nusing\uf0e0 \ndf['Purchase'] = df['Purchase'].fillna(df['Purchase'].mean())  \n \n \n Identifying and removing outliersP a g e  10 | 17 \n \n In the image above, one point lies very far from the other data points, i.e., it\u2019s an outlier \nthat is not following the general trend of the data. So, that point can be dropped.  \n Based on the requirement, form clusters of data to avoid an overfitted model.  \n \nContrary to the example in the previous point, there can be several points that do \nnot follow a particular pattern or which have a pattern of their own. If those points \nare too many, they can\u2019t be considered as outliers.  Then we need to consider \nthose points separately. In that kind of scenario, we create the clusters of similar \npoints, and then we try and train our model on those clusters.  \n Scaling the data so that the difference between the magnitudes of the data points in \ndifferent columns are not very big. \n \nIn the diagram above, the magnitude of the values in the \u2018Purchase\u2019  column is \nway larger than the other columns. This kind of data makes our model \nsensitive. To rectify this, we can do\uf0e0 \n# Feature Scaling So that data in all the columns are to the same scale  \nfrom sklearn.preprocessing import StandardScaler \nsc = StandardScaler() \nX_train = sc.fit_transform(X_train)  \nAfter scaling the data looks like:P a g e  11 | 17 \n \n \n \n Converting the categorical data into numerical data . \nFor example, gender data (Male or Female) is a categorical one. It can be \nconverted to numeric values, as shown below: \ndf['Gender']=df['Gender'].map({'F':0, 'M':1}) \n Replacing or combining two or more attributes to generate a new attribute which serves \nthe same purpose.  \nFor example, if we use one -hot encoding in the example above, it will generate \ntwo separate columns for males and females. But if we observe, a person who is \nnot a male is automatically a female(if we co nsider only two genders). So, the \ntwo columns essentially convey the same information in that case. This is called \nthe dummy variable trap. So, one column can be conveniently dropped.  \n \n Trying out dimensionality reduction techniques like PCA(Principal Component \nAnalysis), which tries to represent the same information but in a space with reduced \ndimensions.", "mimetype": "text/plain", "start_char_idx": 535342, "end_char_idx": 539600, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cf2a6039-d9a3-4d8c-809b-cbb70b975561": {"__data__": {"id_": "cf2a6039-d9a3-4d8c-809b-cbb70b975561", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0561237a-aa07-4c97-9d98-c8ba80791ef3", "node_type": "1", "metadata": {}, "hash": "e3fb93d3b0a3ce0b1884082eb3aba846a7375102a48c45def5ef7b459dc9ddb7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "65b79e60-42cc-44d8-9df3-ee7f1b87163c", "node_type": "1", "metadata": {}, "hash": "d108e0e23ee4b069347a7059bd45c49fa59e768c808d1ccdf84f7ed97ae5107f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0e8 For Deep Learning: \n Data augmentation strategies followed by image annotation. Data augmentation \nconsists of image rotation, contrast, and color adjustments, lighting variations, \nrandom erasing, etc. \n Then all the images are made of identical size. \n Then image annotation is done.P a g e  12 | 17 \n \nQ11. How were you maintaining the failure cases? \nAnswer: \nLet\u2019s say that our model was not able to make a correct prediction for an image. In that case, that \nimage gets stored in the database. There will be a report triggered to the support team at the end of \nthe day with all the failed scenarios where they can inspect the cause of failure. Once we have a \nsufficient number of cases, we can label and include those images while retraining the model for \nbetter model performance. \nQ12.What kind of automation have you done for data processing? \nAnswer: \nWe had a full-fledged ETL pipeline in place for data extraction . Employers already have images of \ntheir employees. That data can be easily used after doing pre -processing for training the image \nidentification model. \n \nQ13.Have you used any scheduler? \nAnswer: \nYes, a scheduler was used for retraining the model after a fixed time(20 days).  \nQ14.How are you monitoring your job? \nAnswer: \nThere are logging set-ups done. We regularly monitor the logs to see for any error scenarios. For fatal \nerrors, we had email notifications in place. Whenever a specific error code, which has been classified \nas a fatal error occurs, email gets triggered to the concerned parties.  \nQ15. What were your roles and responsibilities in the project? \nAnswer: \nMy responsibilities consisted of gathering the dataset, labeling  the images for the model training, \ntraining the model on the prepared dataset, deploying the trained model to the cloud, monitoring the \ndeployed model for any issues , providing QA support before deployment and then providing the \nwarranty support post-deployment.P a g e  13 | 17 \n \nQ16.What was your day to day task? \nAnswer: \nMy day to day tasks involved completing the JIRA tasks assigned to me, attending the scrum \nmeetings, participating in design discussions and requirement gathering, doing the requirement \nanalysis, data validation, image labeling, Unit test for the models, providing UAT support , etc. \nQ17.In which area you have contributed the most? \nAnswer: \nI contributed the most to image labeling and model training areas. Also, we did a lot of brainstorming \nfor finding and selecting the best algorithms for our use cases. After that, we identified and finalized \nthe best practices  for implementation , sc alable deployment  of the model , and best practices for \nseamless deployments as well. \n \nQ18.In which technology you are most comfortable? \nAnswer: \nI have worked in almost all the fields viz. Machine Learning, Deep Learning, and Natural Language \nProcessing, and I have nearly equivalent knowledge in these fields. But  if you talk about personal \npreference, I have loved working in Deep Learning and NLP the most.  \n \nQ19.How you rate yourself in big data technology? \nAnswer: \nI gave worked often in the big data computing technology with ample knowledge in distributed and \ncluster-based computing. But my focus and extensive contribution have been as a data scientist.  \n \n \nQ20. In how many projects you have already worked? \nAnswer: \nIt\u2019s difficult to give a number. But I have worked in various small and large scale projects, e.g., object \ndetection, object classification, object identification, NLP projects, chatbot building, machine \nlearning regression, and classification problems.P a g e  14 | 17 \n \nQ21. How were you doing deployment? \nAnswer: \nThe mechanism of deployment depends on the client 's requirement. For example, some clients want \ntheir models to be deployed in the cloud , and the real -time calls they take place from one cloud \napplication to another. On the other hand, some client s want an on -premise deployment, and then \nthey do API calls to the model. Generally, we prepare a model file first and then try to expose it \nthrough an API for predictions/classifications. The mechanism in which he API gets called depends \non the client requirement. \nQ22.What kind of challenges have you faced during the project? \nAnswer: \nThe biggest challenge that we face is in terms of obtaining a good dataset, cleaning it to be fit for \nfeeding it to a model, and then labeling the prepared datasets. Labeling is a rigorous task and it burns \na lot of hours. Then comes the task of finding the correct algorithm to be used for that business case.", "mimetype": "text/plain", "start_char_idx": 539604, "end_char_idx": 544193, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "65b79e60-42cc-44d8-9df3-ee7f1b87163c": {"__data__": {"id_": "65b79e60-42cc-44d8-9df3-ee7f1b87163c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cf2a6039-d9a3-4d8c-809b-cbb70b975561", "node_type": "1", "metadata": {}, "hash": "4fccc8ca1ad6f5ced40a2c31689cd59f6b42a85d53190635d42440416a5139f5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "52b82c3c-46ad-4066-bab2-ca59a9718da0", "node_type": "1", "metadata": {}, "hash": "b559b2b5c8cb3b10ac31a4f3195e27de6e4de987fdaf24779c2a1fa74011a33c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Then comes the task of finding the correct algorithm to be used for that business case. \nThen that model is optimized. If we are exposing the model as an API, then we need to work on the \nSLA for the API as well, so that it responds in optimum time.  \n \nQ23.What will be your expectations? \nAnswer: \nIt\u2019s said that the best learning is what we learn on the job with experience. I expect to work on new \nprojects which require a broad set of skills so that I can hone my existing skills and learn new things \nsimultaneously. \n \nQ24. What is your future objective? \nAnswer: \nThe field of data science is continuously changing. Almost daily, there is a research paper that \nchanges the way we approach an AI problem. So, it really makes it exciting to work on things that \nare new to the entire world. My objective is to learn  new things as fast as possible and try and \nimplement that knowledge to the work that we do for better code, robust application and in turn, a \nbetter user/customer experience.P a g e  15 | 17 \n \nQ25. Why are you leaving your current organization? \nAnswer: \nI was working on similar kinds of proje cts for some time now. But the market is rapidly changing, \nand the skill set required to be relevant in the market is changing as well. The reason for searching a \nnew job is to work on several kinds of projects and improve my skill se t. <Mention about the \ncompany profile and if you have the project name that you are being interviewed for as new \nlearning opportunities for you>. \n \nQ26. How did you do Data validation? \nAnswer:  \nData validation is done by  looking at the images gathered . There should be ample images for the \nvaried number of cases like change in the lighting conditions, distance from the camera, movement \nof the user, the angle at which camera is installed, the position at which the camera is installed, the \nangle at which the sna p of the user has been taken, the alignment of the image, the ratio of the face \nand the other areas in the image etc. \n \nQ27. How did you do Data enrichment? \nAnswer: \nData enrichment in vision problems mostly consists of image augmentation. Apart from image \naugmentation, we tried to train the model with images with different lighting conditions, with b/w \nand colored images, images from different angles, etc.   \n \nQ28. How would you rate yourself in machine learning?  \nAnswer: \nWell, honestly, my 10 and your 10 will be a lot different as we have dif ferent kinds of experiences. \nOn my scale of 1 to 10, I\u2019ll rate myself as an 8.2. \n \nQ29. How would you rate your self in distributed computation?  \nAnswer: \nI\u2019d rate myself a 7.7 out of 10.P a g e  16 | 17 \n \nQ30. What are the areas of machine learning algorithms that you \nalready have explored? \nAnswer: \nI have explored various machine learning algorithms like Linear Regression, Logistic Regression, L1 \nand L2 Regression, Polynomial Regression, Multi Linear Regression, Decision Trees, Random \nForests, Extra Trees Classifier, PCA, TSnE, UMAP, XG Boost,CAT Boost, ADA Boost, Gradient \nBoosting, Light Boost,  K-Means,K-Means ++,LDA, QDA,  KNN, SVM, SVR,Na\u00efve Bayes , \nAgglomerative clustering, DBScan, Hierarchical clustering, TFIDF, Word to Vec, Bag of words, Doc \nto Vec, Kernel Density Estimation are some of them.  \n \nQ31. In which part of machine learning have you already worked \non? \nAnswer: \nI have worked on both supervised and unsupervised machine learning approaches and building \ndifferent models using the as per the user requirement . \nQ32.How did you optimize your solution? \nAnswer: \nWell, model optimization depends on a lot of factors.  \n\uf0b7 Train with better data(increase the quality), or do data pre -processing steps more \nefficiently. \n\uf0b7 Keep the resolution of the images identical. \n\uf0b7 Increase the quantity of data used for training.  \n\uf0b7 Increase the number of epochs for which the model was trained  \n\uf0b7 Tweak the batch input size, the number of hidden layers, the learning rate, rate of \ndecay, etc. to produce the best results. \n\uf0b7 If you are not using transfer learning, then you can alter the numbe r of hidden layers, \nactivation function. \n\uf0b7 Change the function used in the output layer based on the requirement.", "mimetype": "text/plain", "start_char_idx": 544106, "end_char_idx": 548295, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "52b82c3c-46ad-4066-bab2-ca59a9718da0": {"__data__": {"id_": "52b82c3c-46ad-4066-bab2-ca59a9718da0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1955f812-c049-4b9a-a5e2-a3ff2b394541", "node_type": "4", "metadata": {}, "hash": "38aab3bda0b323905e7be01eb4d6fedc9fa9b21247f448b4ac9bd4f40f61f8c7", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "65b79e60-42cc-44d8-9df3-ee7f1b87163c", "node_type": "1", "metadata": {}, "hash": "d108e0e23ee4b069347a7059bd45c49fa59e768c808d1ccdf84f7ed97ae5107f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Change the function used in the output layer based on the requirement. The sigmoid \nfunctions work well with binary classification problems, whereas for multi -class \nproblems, we use a sigmoid model. \n\uf0b7 Try and use multithreaded approaches, if possible.  \n\uf0b7 Reduce Learning Rate in plateau reasons optimizes the model even further.P a g e  17 | 17 \n \nQ33.How much time did your model take to get trained? \nAnswer: \nWith a batch size of 128 and the number of epochs 100000 with 7000 images,  it took around 110 \nhours to train the model using Nvidia Pascal Titan GPU. \n \nQ34. At what frequency are you retraining and updating your \nmodel? \nAnswer: \nThe model gets retrained every 20 days. \n \nQ35. In which mode have you deployed your model? \nAnswer: \nI have deployed the model both in cloud envi ronments as well in the on -premise ones based on the \nclient and project requirements. \n \nQ36. What is your area of specialization in machine learning? \nAnswer: \nI have worked on various algorithms. So, It\u2019s difficult to point out one  strong area . Let\u2019s have a \ndiscussion on any specific requirement that you have, and then we can take it further from there.", "mimetype": "text/plain", "start_char_idx": 548223, "end_char_idx": 549383, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"1955f812-c049-4b9a-a5e2-a3ff2b394541": {"node_ids": ["34489436-cae2-4523-9287-3364957dd669", "73bd3a44-5f9c-4ada-90d0-6a232bf6b973", "925ab3a0-1a19-4dce-8c8f-5843901ff1bc", "0f18dbdf-03f7-4afd-8b5a-b883eee4490e", "e5f3c955-d456-4449-8a6f-a82304e9acd5", "a23085ae-b0a8-44d0-8af9-0454c89cc701", "c549c20d-91eb-4b4e-a135-3c2ab732ac8f", "34417008-d287-4ec6-8824-9c4a9933dadb", "41fbfc9f-e337-43b9-b0a7-37bb0df3e3a5", "3d640b84-a669-4a62-87c0-7b9bffae4355", "0011a0e6-717f-46ae-ac2c-969b0bbacc17", "547a846e-32a9-49f1-b232-d23b43ec936d", "ff0550ba-a042-4733-a9bc-58c67f3ee653", "7208c8a8-83ca-44e0-a1fa-e344602ee6ad", "a204aba6-d397-475b-bcb9-cb577a450202", "b3843e16-8251-4032-b8c1-0ed0f9209e73", "86ff8e56-9330-43f8-8440-f649b9cd0bdb", "bf070696-46bc-4850-af0b-206ec2fcc097", "34031934-93cc-4830-b3e3-ab9c1aec029c", "cf1825e8-4831-47fc-9ca6-c9dfb2b81855", "d6943e2a-102e-4f56-848a-1c3b2ff88f9a", "33447fc7-8cb5-4459-aa82-11f6680ea241", "88885557-bd8c-403d-984c-cf5894235e12", "0edf1415-de36-4270-9cef-7ec443a8c197", "a9a3b6b9-ac9b-47b4-bb63-8933783ea95d", "4908e5d1-f2e8-4fdc-8a2d-729037dec439", "cbcfe87f-7a52-4219-b9c2-30df358238a4", "52938472-3f0e-46be-b9b9-9aff5e70391d", "ccfc7cac-7479-4e04-97c5-a17ffd3610bf", "e476761c-7a95-4b3b-b61c-fa2eab14e5af", "d19c585e-1e41-4651-9d48-40e3972eb08a", "3c8fc582-44e8-4266-bf4e-2074786d0c60", "2f530467-8fbb-4808-83ec-099ae4805751", "8693e9b3-d9f2-4952-8a90-8891b0455b31", "9189b8e0-7f66-479a-afec-6b653f695be5", "ac8cafeb-3622-4928-991d-bd5ce6a15521", "70c3a405-717b-499e-b5b3-2abb9dd4b19c", "c0efc1cf-f839-45d2-99a2-f73458812cef", "118c9f4c-ed95-423c-ab24-c12cc0664fa8", "c6fdb29b-089e-4e68-a1fe-29bd215b9666", "ac439d6a-4376-4bba-83b3-786ab995cdfb", "d7c0aece-b729-4a43-901e-4c64c0876c83", "7346b2bf-b20f-4a61-87b0-14401e8fed02", "a2807378-86ca-4366-984c-deeb7f761b80", "55bddff7-0185-4eec-843f-2b7b85d8a430", "32d2c2b1-cca3-4db5-8526-9a479f487626", "1c41f3b6-c094-4aea-8875-79e68c9311c2", "4f76dce8-3ccc-4bb1-add1-175abf8d9995", "25d66321-35b9-4363-be72-76e33629616a", "e6928295-da83-4da1-95a5-2be6f0d6718b", "2f5b5056-6011-4570-bd8f-163a18bd4b46", "88548a1f-7190-4cf4-bf1d-835c87aa68ac", "81d1a5b1-88ac-4c37-a933-c2971cb47c7b", "53a6498f-cbe1-40e5-8cb0-195758c1d8d5", "03766a7a-c507-4508-8bce-1a378a8e8272", "7b97b026-d0b9-4ab7-be8f-0326743db861", "76229b56-26d6-410d-81e1-abdd9cb2a72b", "7bdf8503-85ae-4272-a72e-3ee2562fc3a0", "54ecedd6-5cd5-4e61-b6b3-f01069a7927a", "ed2dd69e-328d-4c19-953d-f3d9cc7a3895", "c21972ca-1389-4f54-be2a-b2c8854b1e56", "21b2ae83-3834-4907-afb4-0986b06ee2e9", "e217dbf9-60c7-412a-a252-ea141a98edad", "076c1e04-b35c-4a6e-902b-680056f01004", "e14964cb-028f-4385-8537-37b90a5f3080", "de0df7ac-b806-4fdb-964b-1b6fbcff1ae7", "6904bdec-6926-4c17-b0d9-4b23688e9672", "4121a336-0668-4093-b5db-67770641776f", "10df4883-3f01-4dc7-855f-c21452e6f3fe", "5b497545-33fc-4541-9428-67df266167b4", "ba2aeae3-a9a8-4603-9e73-b96220b79327", "0086a0b8-7a23-4d3c-9805-738e51efb9ed", "8bbbf261-9544-439f-a918-4ec17020447c", "2d057317-de9e-4c7a-b3f3-b6ed462c1149", "2ab1c494-338f-4cf5-aad1-5f9253332cdb", "f92d2480-e358-4a68-a3cf-5d16bbdaa9e3", "f586e01e-8c96-4521-bd66-ab7d03a7f88a", "c444de1f-f91d-4553-9f5e-8d36c83f4cad", "e6391154-f38e-41b3-bcf3-54e2ef40c2d8", "a44724e1-44dd-4dc4-9a07-f500a1ae805b", "d3a0c950-8cb5-4290-937a-66495246d14f", "df8777e6-9a03-45b4-9e9a-940f6ae289f5", "6705304c-622e-4201-9e8c-4cdf5a33b542", "f2f6e694-2f58-4dcc-950a-e4a1ca0dc6e0", "950be4a2-a43d-4b84-a984-430d561cf74a", "ac151282-3067-4f6d-9c24-3dfbbad239bd", "afcc9754-0f7d-445b-8adc-46f40fbc30c7", "bbb5f82b-4ebf-48de-9b0d-1b49aefe13b8", "80ac7d83-369c-480c-a643-7ca6f1a37acc", "314a4b5a-5952-4da1-9218-17074321c302", "50ba301a-e6df-4641-b025-c565c6088b16", "6aa18799-fa30-41d3-bd1f-440824be6e22", "baaa615a-af4a-45ba-bbf1-cfa67a4da6df", "e907cdcf-5dcb-4b4f-94fd-3c5842eaf70a", "d71e50de-da67-41dd-8340-d754324987c8", "bbe816f8-8a7f-4e26-bf41-dd1102129f7f", "c2c634d1-50f4-4a42-9e5f-600ecd38ec0d", "9fea6d73-ba39-4916-8889-e3e6d0ca947a", "750889aa-8c7f-4f64-a702-59b5978021a5", "4d26a338-2094-415b-b90a-e4d55fb27348", "aef1a3a4-c638-477e-b9b3-64d2e035ce76", "b68aa1f7-767a-4429-8f99-7f64db0c7186", "46e73ea5-a864-4ee0-95b1-f43a302154a5", "8febec41-e86f-44d8-8ab6-7e53506d7de3", "36eeb847-6299-4dda-a0d4-073813419d88", "c8fea01d-a524-4b90-8512-a76e2be893ee", "89ca04f0-cb42-49a9-a293-245323c797de", "b361279c-08c2-4c70-b3d4-8eab9098f2e2", "15349f6a-4972-4fa3-9149-6337e2c01b66", "48c4dd2e-b382-4689-94cc-181761e99161", "ae298954-0179-4ebb-a91b-3c238cb39670", "e3a05eee-3e81-4991-87e8-27734709aa34", "c3732f34-173e-45d7-ba3d-f77a9c0d119a", "95d6cb79-940f-47d8-ad80-f146833b0f62", "e863e6f1-8053-4d97-b2ef-08b8530f9c70", "0bdff3d5-ae33-4b87-970c-d8f38deb019d", "524beb77-363e-48b0-8082-e82ebc147650", "6291a13f-0cec-44d4-b2f0-6f06bf996e79", "d8055aea-7f54-4708-b218-b8e23a78c4c6", "b18a7acd-ee88-4480-b9f1-4d446213ac6f", "66a3def4-f002-4286-91d6-dffc853ff270", "0561237a-aa07-4c97-9d98-c8ba80791ef3", "cf2a6039-d9a3-4d8c-809b-cbb70b975561", "65b79e60-42cc-44d8-9df3-ee7f1b87163c", "52b82c3c-46ad-4066-bab2-ca59a9718da0"], "metadata": {}}}}